"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const execa = require("execa");
const fs = require("fs");
const path = require("path");
const delay_1 = require("./delay");
const flags_1 = require("./flags");
const PORT_FILENAME = "DevToolsActivePort";
const NEWLINE = /\r?\n/;
// roughly the same as the chromedriver chrome_launcher
// https://chromium.googlesource.com/chromium/src/+/6fd4390daea50497e5ead4583829e2e8f9b215b2/chrome/test/chromedriver/chrome_launcher.cc#445
// Launch chrome, wait for the DevToolsActivePort port file 60 second timeout polling on a 50ms interval.
function spawnBrowser(executablePath, dataDir, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const portFile = path.join(dataDir, PORT_FILENAME);
        // delete port file before launching
        yield tryDeleteFile(portFile);
        const args = getArguments(dataDir, options);
        const process = new BrowserProcess(executablePath, args, options === undefined ? undefined : options.stdio);
        const deadline = Date.now() + 60 * 1000;
        try {
            let port = 0;
            let wsPath;
            while (true) {
                yield delay_1.delay(50);
                [port, wsPath] = yield tryReadPort(portFile);
                process.validate();
                if (port > 0) {
                    process.remoteDebuggingPort = port;
                    process.remoteDebuggingPath = wsPath;
                    process.dataDir = dataDir;
                    break;
                }
                if (Date.now() > deadline) {
                    throw new Error(`timeout waiting for ${portFile}`);
                }
            }
            return process;
        }
        catch (err) {
            yield process.dispose();
            throw err;
        }
    });
}
exports.default = spawnBrowser;
function getArguments(dataDir, options) {
    const windowSize = (options && options.windowSize) || {
        height: 736,
        width: 414,
    };
    const defaultArguments = options === undefined || options.disableDefaultArguments !== true
        ? flags_1.DEFAULT_FLAGS
        : [];
    const additionalArguments = (options && options.additionalArguments) || [];
    return [
        "--remote-debugging-port=0",
        `--user-data-dir=${dataDir}`,
        `--window-size=${windowSize.width},${windowSize.height}`,
    ].concat(defaultArguments, additionalArguments, ["about:blank"]);
}
/* tslint:disable:max-classes-per-file */
class BrowserProcess {
    constructor(executablePath, args, stdio = "inherit") {
        this.remoteDebuggingPort = 0;
        this.hasExited = false;
        // the types aren't current for this
        // disabling buffer used to be maxBuffer: null
        // now it is buffer: false
        const child = execa(executablePath, args, {
            // disable buffer, pipe or drain
            buffer: false,
            stdio,
        });
        // child is now a thenable for the duration of the promise
        // ensure we handle its error or we will get an
        // unhandled rejection warning
        child.catch(err => (this.lastError = err));
        child.on("exit", () => (this.hasExited = true));
        this.process = child;
        this.pid = child.pid;
    }
    get webSocketDebuggerUrl() {
        return `ws://127.0.0.1:${this.remoteDebuggingPort}${this.remoteDebuggingPath}`;
    }
    dispose() {
        return new Promise(resolve => {
            if (this.hasExited) {
                resolve();
            }
            else {
                this.process.on("exit", resolve);
                this.process.kill();
                // race
                setTimeout(resolve, 2000);
                setTimeout(() => this.process.kill("SIGKILL"), 2000);
            }
        })
            .then(() => {
            this.process.removeAllListeners();
        })
            .catch(err => {
            /* tslint:disable:no-console */
            console.error(err);
            /* tslint:enable:no-console */
        });
    }
    validate() {
        if (this.hasExited) {
            throw new Error("process exited");
        }
        if (this.lastError) {
            throw this.lastError;
        }
    }
}
function tryDeleteFile(filename) {
    return new Promise(resolve => fs.unlink(filename, () => resolve()));
}
function tryReadPort(filename) {
    return new Promise(resolve => {
        fs.readFile(filename, "utf8", (err, data) => {
            if (err || data.length === 0) {
                resolve([0, undefined]);
            }
            else {
                const [portStr, wsPath] = data.split(NEWLINE, 2);
                const port = parseInt(portStr, 10);
                // handles NaN if write was created but port not written
                port > 0 ? resolve([port, wsPath]) : resolve([0, wsPath]);
            }
        });
    });
}
//# sourceMappingURL=spawn-browser.js.map