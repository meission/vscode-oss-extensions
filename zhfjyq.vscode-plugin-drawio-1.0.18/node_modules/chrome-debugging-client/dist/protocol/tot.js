"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Accessibility {
    constructor(client) {
        this._client = client;
    }
    /** Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. */
    getPartialAXTree(params) {
        return this._client.send("Accessibility.getPartialAXTree", params);
    }
}
exports.Accessibility = Accessibility;
class Animation {
    constructor(client) {
        this._animationCanceled = null;
        this._animationCreated = null;
        this._animationStarted = null;
        this._client = client;
    }
    /** Disables animation domain notifications. */
    disable() {
        return this._client.send("Animation.disable");
    }
    /** Enables animation domain notifications. */
    enable() {
        return this._client.send("Animation.enable");
    }
    /** Returns the current time of the an animation. */
    getCurrentTime(params) {
        return this._client.send("Animation.getCurrentTime", params);
    }
    /** Gets the playback rate of the document timeline. */
    getPlaybackRate() {
        return this._client.send("Animation.getPlaybackRate");
    }
    /** Releases a set of animations to no longer be manipulated. */
    releaseAnimations(params) {
        return this._client.send("Animation.releaseAnimations", params);
    }
    /** Gets the remote object of the Animation. */
    resolveAnimation(params) {
        return this._client.send("Animation.resolveAnimation", params);
    }
    /** Seek a set of animations to a particular time within each animation. */
    seekAnimations(params) {
        return this._client.send("Animation.seekAnimations", params);
    }
    /** Sets the paused state of a set of animations. */
    setPaused(params) {
        return this._client.send("Animation.setPaused", params);
    }
    /** Sets the playback rate of the document timeline. */
    setPlaybackRate(params) {
        return this._client.send("Animation.setPlaybackRate", params);
    }
    /** Sets the timing of an animation node. */
    setTiming(params) {
        return this._client.send("Animation.setTiming", params);
    }
    /** Event for when an animation has been cancelled. */
    get animationCanceled() {
        return this._animationCanceled;
    }
    set animationCanceled(handler) {
        if (this._animationCanceled) {
            this._client.removeListener("Animation.animationCanceled", this._animationCanceled);
        }
        this._animationCanceled = handler;
        if (handler) {
            this._client.on("Animation.animationCanceled", handler);
        }
    }
    /** Event for each animation that has been created. */
    get animationCreated() {
        return this._animationCreated;
    }
    set animationCreated(handler) {
        if (this._animationCreated) {
            this._client.removeListener("Animation.animationCreated", this._animationCreated);
        }
        this._animationCreated = handler;
        if (handler) {
            this._client.on("Animation.animationCreated", handler);
        }
    }
    /** Event for animation that has been started. */
    get animationStarted() {
        return this._animationStarted;
    }
    set animationStarted(handler) {
        if (this._animationStarted) {
            this._client.removeListener("Animation.animationStarted", this._animationStarted);
        }
        this._animationStarted = handler;
        if (handler) {
            this._client.on("Animation.animationStarted", handler);
        }
    }
}
exports.Animation = Animation;
class ApplicationCache {
    constructor(client) {
        this._applicationCacheStatusUpdated = null;
        this._networkStateUpdated = null;
        this._client = client;
    }
    /** Enables application cache domain notifications. */
    enable() {
        return this._client.send("ApplicationCache.enable");
    }
    /** Returns relevant application cache data for the document in given frame. */
    getApplicationCacheForFrame(params) {
        return this._client.send("ApplicationCache.getApplicationCacheForFrame", params);
    }
    /** Returns array of frame identifiers with manifest urls for each frame containing a document
  associated with some application cache. */
    getFramesWithManifests() {
        return this._client.send("ApplicationCache.getFramesWithManifests");
    }
    /** Returns manifest URL for document in the given frame. */
    getManifestForFrame(params) {
        return this._client.send("ApplicationCache.getManifestForFrame", params);
    }
    get applicationCacheStatusUpdated() {
        return this._applicationCacheStatusUpdated;
    }
    set applicationCacheStatusUpdated(handler) {
        if (this._applicationCacheStatusUpdated) {
            this._client.removeListener("ApplicationCache.applicationCacheStatusUpdated", this._applicationCacheStatusUpdated);
        }
        this._applicationCacheStatusUpdated = handler;
        if (handler) {
            this._client.on("ApplicationCache.applicationCacheStatusUpdated", handler);
        }
    }
    get networkStateUpdated() {
        return this._networkStateUpdated;
    }
    set networkStateUpdated(handler) {
        if (this._networkStateUpdated) {
            this._client.removeListener("ApplicationCache.networkStateUpdated", this._networkStateUpdated);
        }
        this._networkStateUpdated = handler;
        if (handler) {
            this._client.on("ApplicationCache.networkStateUpdated", handler);
        }
    }
}
exports.ApplicationCache = ApplicationCache;
/** Audits domain allows investigation of page violations and possible improvements. */
class Audits {
    constructor(client) {
        this._client = client;
    }
    /** Returns the response body and size if it were re-encoded with the specified settings. Only
  applies to images. */
    getEncodedResponse(params) {
        return this._client.send("Audits.getEncodedResponse", params);
    }
}
exports.Audits = Audits;
/** The Browser domain defines methods and events for browser managing. */
class Browser {
    constructor(client) {
        this._client = client;
    }
    /** Grant specific permissions to the given origin and reject all others. */
    grantPermissions(params) {
        return this._client.send("Browser.grantPermissions", params);
    }
    /** Reset all permission management for all origins. */
    resetPermissions(params) {
        return this._client.send("Browser.resetPermissions", params);
    }
    /** Close browser gracefully. */
    close() {
        return this._client.send("Browser.close");
    }
    /** Crashes browser on the main thread. */
    crash() {
        return this._client.send("Browser.crash");
    }
    /** Returns version information. */
    getVersion() {
        return this._client.send("Browser.getVersion");
    }
    /** Returns the command line switches for the browser process if, and only if
  --enable-automation is on the commandline. */
    getBrowserCommandLine() {
        return this._client.send("Browser.getBrowserCommandLine");
    }
    /** Get Chrome histograms. */
    getHistograms(params) {
        return this._client.send("Browser.getHistograms", params);
    }
    /** Get a Chrome histogram by name. */
    getHistogram(params) {
        return this._client.send("Browser.getHistogram", params);
    }
    /** Get position and size of the browser window. */
    getWindowBounds(params) {
        return this._client.send("Browser.getWindowBounds", params);
    }
    /** Get the browser window that contains the devtools target. */
    getWindowForTarget(params) {
        return this._client.send("Browser.getWindowForTarget", params);
    }
    /** Set position and/or size of the browser window. */
    setWindowBounds(params) {
        return this._client.send("Browser.setWindowBounds", params);
    }
}
exports.Browser = Browser;
/** This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
have an associated `id` used in subsequent operations on the related object. Each object type has
a specific `id` structure, and those are not interchangeable between objects of different kinds.
CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods. */
class CSS {
    constructor(client) {
        this._fontsUpdated = null;
        this._mediaQueryResultChanged = null;
        this._styleSheetAdded = null;
        this._styleSheetChanged = null;
        this._styleSheetRemoved = null;
        this._client = client;
    }
    /** Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
  position specified by `location`. */
    addRule(params) {
        return this._client.send("CSS.addRule", params);
    }
    /** Returns all class names from specified stylesheet. */
    collectClassNames(params) {
        return this._client.send("CSS.collectClassNames", params);
    }
    /** Creates a new special "via-inspector" stylesheet in the frame with given `frameId`. */
    createStyleSheet(params) {
        return this._client.send("CSS.createStyleSheet", params);
    }
    /** Disables the CSS agent for the given page. */
    disable() {
        return this._client.send("CSS.disable");
    }
    /** Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
  enabled until the result of this command is received. */
    enable() {
        return this._client.send("CSS.enable");
    }
    /** Ensures that the given node will have specified pseudo-classes whenever its style is computed by
  the browser. */
    forcePseudoState(params) {
        return this._client.send("CSS.forcePseudoState", params);
    }
    getBackgroundColors(params) {
        return this._client.send("CSS.getBackgroundColors", params);
    }
    /** Returns the computed style for a DOM node identified by `nodeId`. */
    getComputedStyleForNode(params) {
        return this._client.send("CSS.getComputedStyleForNode", params);
    }
    /** Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
  attributes) for a DOM node identified by `nodeId`. */
    getInlineStylesForNode(params) {
        return this._client.send("CSS.getInlineStylesForNode", params);
    }
    /** Returns requested styles for a DOM node identified by `nodeId`. */
    getMatchedStylesForNode(params) {
        return this._client.send("CSS.getMatchedStylesForNode", params);
    }
    /** Returns all media queries parsed by the rendering engine. */
    getMediaQueries() {
        return this._client.send("CSS.getMediaQueries");
    }
    /** Requests information about platform fonts which we used to render child TextNodes in the given
  node. */
    getPlatformFontsForNode(params) {
        return this._client.send("CSS.getPlatformFontsForNode", params);
    }
    /** Returns the current textual content for a stylesheet. */
    getStyleSheetText(params) {
        return this._client.send("CSS.getStyleSheetText", params);
    }
    /** Find a rule with the given active property for the given node and set the new value for this
  property */
    setEffectivePropertyValueForNode(params) {
        return this._client.send("CSS.setEffectivePropertyValueForNode", params);
    }
    /** Modifies the keyframe rule key text. */
    setKeyframeKey(params) {
        return this._client.send("CSS.setKeyframeKey", params);
    }
    /** Modifies the rule selector. */
    setMediaText(params) {
        return this._client.send("CSS.setMediaText", params);
    }
    /** Modifies the rule selector. */
    setRuleSelector(params) {
        return this._client.send("CSS.setRuleSelector", params);
    }
    /** Sets the new stylesheet text. */
    setStyleSheetText(params) {
        return this._client.send("CSS.setStyleSheetText", params);
    }
    /** Applies specified style edits one after another in the given order. */
    setStyleTexts(params) {
        return this._client.send("CSS.setStyleTexts", params);
    }
    /** Enables the selector recording. */
    startRuleUsageTracking() {
        return this._client.send("CSS.startRuleUsageTracking");
    }
    /** Stop tracking rule usage and return the list of rules that were used since last call to
  `takeCoverageDelta` (or since start of coverage instrumentation) */
    stopRuleUsageTracking() {
        return this._client.send("CSS.stopRuleUsageTracking");
    }
    /** Obtain list of rules that became used since last call to this method (or since start of coverage
  instrumentation) */
    takeCoverageDelta() {
        return this._client.send("CSS.takeCoverageDelta");
    }
    /** Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
  web font */
    get fontsUpdated() {
        return this._fontsUpdated;
    }
    set fontsUpdated(handler) {
        if (this._fontsUpdated) {
            this._client.removeListener("CSS.fontsUpdated", this._fontsUpdated);
        }
        this._fontsUpdated = handler;
        if (handler) {
            this._client.on("CSS.fontsUpdated", handler);
        }
    }
    /** Fires whenever a MediaQuery result changes (for example, after a browser window has been
  resized.) The current implementation considers only viewport-dependent media features. */
    get mediaQueryResultChanged() {
        return this._mediaQueryResultChanged;
    }
    set mediaQueryResultChanged(handler) {
        if (this._mediaQueryResultChanged) {
            this._client.removeListener("CSS.mediaQueryResultChanged", this._mediaQueryResultChanged);
        }
        this._mediaQueryResultChanged = handler;
        if (handler) {
            this._client.on("CSS.mediaQueryResultChanged", handler);
        }
    }
    /** Fired whenever an active document stylesheet is added. */
    get styleSheetAdded() {
        return this._styleSheetAdded;
    }
    set styleSheetAdded(handler) {
        if (this._styleSheetAdded) {
            this._client.removeListener("CSS.styleSheetAdded", this._styleSheetAdded);
        }
        this._styleSheetAdded = handler;
        if (handler) {
            this._client.on("CSS.styleSheetAdded", handler);
        }
    }
    /** Fired whenever a stylesheet is changed as a result of the client operation. */
    get styleSheetChanged() {
        return this._styleSheetChanged;
    }
    set styleSheetChanged(handler) {
        if (this._styleSheetChanged) {
            this._client.removeListener("CSS.styleSheetChanged", this._styleSheetChanged);
        }
        this._styleSheetChanged = handler;
        if (handler) {
            this._client.on("CSS.styleSheetChanged", handler);
        }
    }
    /** Fired whenever an active document stylesheet is removed. */
    get styleSheetRemoved() {
        return this._styleSheetRemoved;
    }
    set styleSheetRemoved(handler) {
        if (this._styleSheetRemoved) {
            this._client.removeListener("CSS.styleSheetRemoved", this._styleSheetRemoved);
        }
        this._styleSheetRemoved = handler;
        if (handler) {
            this._client.on("CSS.styleSheetRemoved", handler);
        }
    }
}
exports.CSS = CSS;
class CacheStorage {
    constructor(client) {
        this._client = client;
    }
    /** Deletes a cache. */
    deleteCache(params) {
        return this._client.send("CacheStorage.deleteCache", params);
    }
    /** Deletes a cache entry. */
    deleteEntry(params) {
        return this._client.send("CacheStorage.deleteEntry", params);
    }
    /** Requests cache names. */
    requestCacheNames(params) {
        return this._client.send("CacheStorage.requestCacheNames", params);
    }
    /** Fetches cache entry. */
    requestCachedResponse(params) {
        return this._client.send("CacheStorage.requestCachedResponse", params);
    }
    /** Requests data from cache. */
    requestEntries(params) {
        return this._client.send("CacheStorage.requestEntries", params);
    }
}
exports.CacheStorage = CacheStorage;
/** This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
and never sends the same node twice. It is client's responsibility to collect information about
the nodes that were sent to the client.<p>Note that `iframe` owner elements will return
corresponding document elements as their child nodes.</p> */
class DOM {
    constructor(client) {
        this._attributeModified = null;
        this._attributeRemoved = null;
        this._characterDataModified = null;
        this._childNodeCountUpdated = null;
        this._childNodeInserted = null;
        this._childNodeRemoved = null;
        this._distributedNodesUpdated = null;
        this._documentUpdated = null;
        this._inlineStyleInvalidated = null;
        this._pseudoElementAdded = null;
        this._pseudoElementRemoved = null;
        this._setChildNodes = null;
        this._shadowRootPopped = null;
        this._shadowRootPushed = null;
        this._client = client;
    }
    /** Collects class names for the node with given id and all of it's child nodes. */
    collectClassNamesFromSubtree(params) {
        return this._client.send("DOM.collectClassNamesFromSubtree", params);
    }
    /** Creates a deep copy of the specified node and places it into the target container before the
  given anchor. */
    copyTo(params) {
        return this._client.send("DOM.copyTo", params);
    }
    /** Describes node given its id, does not require domain to be enabled. Does not start tracking any
  objects, can be used for automation. */
    describeNode(params) {
        return this._client.send("DOM.describeNode", params);
    }
    /** Disables DOM agent for the given page. */
    disable() {
        return this._client.send("DOM.disable");
    }
    /** Discards search results from the session with the given id. `getSearchResults` should no longer
  be called for that search. */
    discardSearchResults(params) {
        return this._client.send("DOM.discardSearchResults", params);
    }
    /** Enables DOM agent for the given page. */
    enable() {
        return this._client.send("DOM.enable");
    }
    /** Focuses the given element. */
    focus(params) {
        return this._client.send("DOM.focus", params);
    }
    /** Returns attributes for the specified node. */
    getAttributes(params) {
        return this._client.send("DOM.getAttributes", params);
    }
    /** Returns boxes for the given node. */
    getBoxModel(params) {
        return this._client.send("DOM.getBoxModel", params);
    }
    /** Returns quads that describe node position on the page. This method
  might return multiple quads for inline nodes. */
    getContentQuads(params) {
        return this._client.send("DOM.getContentQuads", params);
    }
    /** Returns the root DOM node (and optionally the subtree) to the caller. */
    getDocument(params) {
        return this._client.send("DOM.getDocument", params);
    }
    /** Returns the root DOM node (and optionally the subtree) to the caller. */
    getFlattenedDocument(params) {
        return this._client.send("DOM.getFlattenedDocument", params);
    }
    /** Returns node id at given location. */
    getNodeForLocation(params) {
        return this._client.send("DOM.getNodeForLocation", params);
    }
    /** Returns node's HTML markup. */
    getOuterHTML(params) {
        return this._client.send("DOM.getOuterHTML", params);
    }
    /** Returns the id of the nearest ancestor that is a relayout boundary. */
    getRelayoutBoundary(params) {
        return this._client.send("DOM.getRelayoutBoundary", params);
    }
    /** Returns search results from given `fromIndex` to given `toIndex` from the search with the given
  identifier. */
    getSearchResults(params) {
        return this._client.send("DOM.getSearchResults", params);
    }
    /** Hides any highlight. */
    hideHighlight() {
        return this._client.send("DOM.hideHighlight");
    }
    /** Highlights DOM node. */
    highlightNode() {
        return this._client.send("DOM.highlightNode");
    }
    /** Highlights given rectangle. */
    highlightRect() {
        return this._client.send("DOM.highlightRect");
    }
    /** Marks last undoable state. */
    markUndoableState() {
        return this._client.send("DOM.markUndoableState");
    }
    /** Moves node into the new container, places it before the given anchor. */
    moveTo(params) {
        return this._client.send("DOM.moveTo", params);
    }
    /** Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
  `cancelSearch` to end this search session. */
    performSearch(params) {
        return this._client.send("DOM.performSearch", params);
    }
    /** Requests that the node is sent to the caller given its path. // FIXME, use XPath */
    pushNodeByPathToFrontend(params) {
        return this._client.send("DOM.pushNodeByPathToFrontend", params);
    }
    /** Requests that a batch of nodes is sent to the caller given their backend node ids. */
    pushNodesByBackendIdsToFrontend(params) {
        return this._client.send("DOM.pushNodesByBackendIdsToFrontend", params);
    }
    /** Executes `querySelector` on a given node. */
    querySelector(params) {
        return this._client.send("DOM.querySelector", params);
    }
    /** Executes `querySelectorAll` on a given node. */
    querySelectorAll(params) {
        return this._client.send("DOM.querySelectorAll", params);
    }
    /** Re-does the last undone action. */
    redo() {
        return this._client.send("DOM.redo");
    }
    /** Removes attribute with given name from an element with given id. */
    removeAttribute(params) {
        return this._client.send("DOM.removeAttribute", params);
    }
    /** Removes node with given id. */
    removeNode(params) {
        return this._client.send("DOM.removeNode", params);
    }
    /** Requests that children of the node with given id are returned to the caller in form of
  `setChildNodes` events where not only immediate children are retrieved, but all children down to
  the specified depth. */
    requestChildNodes(params) {
        return this._client.send("DOM.requestChildNodes", params);
    }
    /** Requests that the node is sent to the caller given the JavaScript node object reference. All
  nodes that form the path from the node to the root are also sent to the client as a series of
  `setChildNodes` notifications. */
    requestNode(params) {
        return this._client.send("DOM.requestNode", params);
    }
    /** Resolves the JavaScript node object for a given NodeId or BackendNodeId. */
    resolveNode(params) {
        return this._client.send("DOM.resolveNode", params);
    }
    /** Sets attribute for an element with given id. */
    setAttributeValue(params) {
        return this._client.send("DOM.setAttributeValue", params);
    }
    /** Sets attributes on element with given id. This method is useful when user edits some existing
  attribute value and types in several attribute name/value pairs. */
    setAttributesAsText(params) {
        return this._client.send("DOM.setAttributesAsText", params);
    }
    /** Sets files for the given file input element. */
    setFileInputFiles(params) {
        return this._client.send("DOM.setFileInputFiles", params);
    }
    /** Enables console to refer to the node with given id via $x (see Command Line API for more details
  $x functions). */
    setInspectedNode(params) {
        return this._client.send("DOM.setInspectedNode", params);
    }
    /** Sets node name for a node with given id. */
    setNodeName(params) {
        return this._client.send("DOM.setNodeName", params);
    }
    /** Sets node value for a node with given id. */
    setNodeValue(params) {
        return this._client.send("DOM.setNodeValue", params);
    }
    /** Sets node HTML markup, returns new node id. */
    setOuterHTML(params) {
        return this._client.send("DOM.setOuterHTML", params);
    }
    /** Undoes the last performed action. */
    undo() {
        return this._client.send("DOM.undo");
    }
    /** Returns iframe node that owns iframe with the given domain. */
    getFrameOwner(params) {
        return this._client.send("DOM.getFrameOwner", params);
    }
    /** Fired when `Element`'s attribute is modified. */
    get attributeModified() {
        return this._attributeModified;
    }
    set attributeModified(handler) {
        if (this._attributeModified) {
            this._client.removeListener("DOM.attributeModified", this._attributeModified);
        }
        this._attributeModified = handler;
        if (handler) {
            this._client.on("DOM.attributeModified", handler);
        }
    }
    /** Fired when `Element`'s attribute is removed. */
    get attributeRemoved() {
        return this._attributeRemoved;
    }
    set attributeRemoved(handler) {
        if (this._attributeRemoved) {
            this._client.removeListener("DOM.attributeRemoved", this._attributeRemoved);
        }
        this._attributeRemoved = handler;
        if (handler) {
            this._client.on("DOM.attributeRemoved", handler);
        }
    }
    /** Mirrors `DOMCharacterDataModified` event. */
    get characterDataModified() {
        return this._characterDataModified;
    }
    set characterDataModified(handler) {
        if (this._characterDataModified) {
            this._client.removeListener("DOM.characterDataModified", this._characterDataModified);
        }
        this._characterDataModified = handler;
        if (handler) {
            this._client.on("DOM.characterDataModified", handler);
        }
    }
    /** Fired when `Container`'s child node count has changed. */
    get childNodeCountUpdated() {
        return this._childNodeCountUpdated;
    }
    set childNodeCountUpdated(handler) {
        if (this._childNodeCountUpdated) {
            this._client.removeListener("DOM.childNodeCountUpdated", this._childNodeCountUpdated);
        }
        this._childNodeCountUpdated = handler;
        if (handler) {
            this._client.on("DOM.childNodeCountUpdated", handler);
        }
    }
    /** Mirrors `DOMNodeInserted` event. */
    get childNodeInserted() {
        return this._childNodeInserted;
    }
    set childNodeInserted(handler) {
        if (this._childNodeInserted) {
            this._client.removeListener("DOM.childNodeInserted", this._childNodeInserted);
        }
        this._childNodeInserted = handler;
        if (handler) {
            this._client.on("DOM.childNodeInserted", handler);
        }
    }
    /** Mirrors `DOMNodeRemoved` event. */
    get childNodeRemoved() {
        return this._childNodeRemoved;
    }
    set childNodeRemoved(handler) {
        if (this._childNodeRemoved) {
            this._client.removeListener("DOM.childNodeRemoved", this._childNodeRemoved);
        }
        this._childNodeRemoved = handler;
        if (handler) {
            this._client.on("DOM.childNodeRemoved", handler);
        }
    }
    /** Called when distrubution is changed. */
    get distributedNodesUpdated() {
        return this._distributedNodesUpdated;
    }
    set distributedNodesUpdated(handler) {
        if (this._distributedNodesUpdated) {
            this._client.removeListener("DOM.distributedNodesUpdated", this._distributedNodesUpdated);
        }
        this._distributedNodesUpdated = handler;
        if (handler) {
            this._client.on("DOM.distributedNodesUpdated", handler);
        }
    }
    /** Fired when `Document` has been totally updated. Node ids are no longer valid. */
    get documentUpdated() {
        return this._documentUpdated;
    }
    set documentUpdated(handler) {
        if (this._documentUpdated) {
            this._client.removeListener("DOM.documentUpdated", this._documentUpdated);
        }
        this._documentUpdated = handler;
        if (handler) {
            this._client.on("DOM.documentUpdated", handler);
        }
    }
    /** Fired when `Element`'s inline style is modified via a CSS property modification. */
    get inlineStyleInvalidated() {
        return this._inlineStyleInvalidated;
    }
    set inlineStyleInvalidated(handler) {
        if (this._inlineStyleInvalidated) {
            this._client.removeListener("DOM.inlineStyleInvalidated", this._inlineStyleInvalidated);
        }
        this._inlineStyleInvalidated = handler;
        if (handler) {
            this._client.on("DOM.inlineStyleInvalidated", handler);
        }
    }
    /** Called when a pseudo element is added to an element. */
    get pseudoElementAdded() {
        return this._pseudoElementAdded;
    }
    set pseudoElementAdded(handler) {
        if (this._pseudoElementAdded) {
            this._client.removeListener("DOM.pseudoElementAdded", this._pseudoElementAdded);
        }
        this._pseudoElementAdded = handler;
        if (handler) {
            this._client.on("DOM.pseudoElementAdded", handler);
        }
    }
    /** Called when a pseudo element is removed from an element. */
    get pseudoElementRemoved() {
        return this._pseudoElementRemoved;
    }
    set pseudoElementRemoved(handler) {
        if (this._pseudoElementRemoved) {
            this._client.removeListener("DOM.pseudoElementRemoved", this._pseudoElementRemoved);
        }
        this._pseudoElementRemoved = handler;
        if (handler) {
            this._client.on("DOM.pseudoElementRemoved", handler);
        }
    }
    /** Fired when backend wants to provide client with the missing DOM structure. This happens upon
  most of the calls requesting node ids. */
    get setChildNodes() {
        return this._setChildNodes;
    }
    set setChildNodes(handler) {
        if (this._setChildNodes) {
            this._client.removeListener("DOM.setChildNodes", this._setChildNodes);
        }
        this._setChildNodes = handler;
        if (handler) {
            this._client.on("DOM.setChildNodes", handler);
        }
    }
    /** Called when shadow root is popped from the element. */
    get shadowRootPopped() {
        return this._shadowRootPopped;
    }
    set shadowRootPopped(handler) {
        if (this._shadowRootPopped) {
            this._client.removeListener("DOM.shadowRootPopped", this._shadowRootPopped);
        }
        this._shadowRootPopped = handler;
        if (handler) {
            this._client.on("DOM.shadowRootPopped", handler);
        }
    }
    /** Called when shadow root is pushed into the element. */
    get shadowRootPushed() {
        return this._shadowRootPushed;
    }
    set shadowRootPushed(handler) {
        if (this._shadowRootPushed) {
            this._client.removeListener("DOM.shadowRootPushed", this._shadowRootPushed);
        }
        this._shadowRootPushed = handler;
        if (handler) {
            this._client.on("DOM.shadowRootPushed", handler);
        }
    }
}
exports.DOM = DOM;
/** DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
execution will stop on these operations as if there was a regular breakpoint set. */
class DOMDebugger {
    constructor(client) {
        this._client = client;
    }
    /** Returns event listeners of the given object. */
    getEventListeners(params) {
        return this._client.send("DOMDebugger.getEventListeners", params);
    }
    /** Removes DOM breakpoint that was set using `setDOMBreakpoint`. */
    removeDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.removeDOMBreakpoint", params);
    }
    /** Removes breakpoint on particular DOM event. */
    removeEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.removeEventListenerBreakpoint", params);
    }
    /** Removes breakpoint on particular native event. */
    removeInstrumentationBreakpoint(params) {
        return this._client.send("DOMDebugger.removeInstrumentationBreakpoint", params);
    }
    /** Removes breakpoint from XMLHttpRequest. */
    removeXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.removeXHRBreakpoint", params);
    }
    /** Sets breakpoint on particular operation with DOM. */
    setDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.setDOMBreakpoint", params);
    }
    /** Sets breakpoint on particular DOM event. */
    setEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.setEventListenerBreakpoint", params);
    }
    /** Sets breakpoint on particular native event. */
    setInstrumentationBreakpoint(params) {
        return this._client.send("DOMDebugger.setInstrumentationBreakpoint", params);
    }
    /** Sets breakpoint on XMLHttpRequest. */
    setXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.setXHRBreakpoint", params);
    }
}
exports.DOMDebugger = DOMDebugger;
/** This domain facilitates obtaining document snapshots with DOM, layout, and style information. */
class DOMSnapshot {
    constructor(client) {
        this._client = client;
    }
    /** Disables DOM snapshot agent for the given page. */
    disable() {
        return this._client.send("DOMSnapshot.disable");
    }
    /** Enables DOM snapshot agent for the given page. */
    enable() {
        return this._client.send("DOMSnapshot.enable");
    }
    /** Returns a document snapshot, including the full DOM tree of the root node (including iframes,
  template contents, and imported documents) in a flattened array, as well as layout and
  white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
  flattened. */
    getSnapshot(params) {
        return this._client.send("DOMSnapshot.getSnapshot", params);
    }
    /** Returns a document snapshot, including the full DOM tree of the root node (including iframes,
  template contents, and imported documents) in a flattened array, as well as layout and
  white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
  flattened. */
    captureSnapshot(params) {
        return this._client.send("DOMSnapshot.captureSnapshot", params);
    }
}
exports.DOMSnapshot = DOMSnapshot;
/** Query and modify DOM storage. */
class DOMStorage {
    constructor(client) {
        this._domStorageItemAdded = null;
        this._domStorageItemRemoved = null;
        this._domStorageItemUpdated = null;
        this._domStorageItemsCleared = null;
        this._client = client;
    }
    clear(params) {
        return this._client.send("DOMStorage.clear", params);
    }
    /** Disables storage tracking, prevents storage events from being sent to the client. */
    disable() {
        return this._client.send("DOMStorage.disable");
    }
    /** Enables storage tracking, storage events will now be delivered to the client. */
    enable() {
        return this._client.send("DOMStorage.enable");
    }
    getDOMStorageItems(params) {
        return this._client.send("DOMStorage.getDOMStorageItems", params);
    }
    removeDOMStorageItem(params) {
        return this._client.send("DOMStorage.removeDOMStorageItem", params);
    }
    setDOMStorageItem(params) {
        return this._client.send("DOMStorage.setDOMStorageItem", params);
    }
    get domStorageItemAdded() {
        return this._domStorageItemAdded;
    }
    set domStorageItemAdded(handler) {
        if (this._domStorageItemAdded) {
            this._client.removeListener("DOMStorage.domStorageItemAdded", this._domStorageItemAdded);
        }
        this._domStorageItemAdded = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemAdded", handler);
        }
    }
    get domStorageItemRemoved() {
        return this._domStorageItemRemoved;
    }
    set domStorageItemRemoved(handler) {
        if (this._domStorageItemRemoved) {
            this._client.removeListener("DOMStorage.domStorageItemRemoved", this._domStorageItemRemoved);
        }
        this._domStorageItemRemoved = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemRemoved", handler);
        }
    }
    get domStorageItemUpdated() {
        return this._domStorageItemUpdated;
    }
    set domStorageItemUpdated(handler) {
        if (this._domStorageItemUpdated) {
            this._client.removeListener("DOMStorage.domStorageItemUpdated", this._domStorageItemUpdated);
        }
        this._domStorageItemUpdated = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemUpdated", handler);
        }
    }
    get domStorageItemsCleared() {
        return this._domStorageItemsCleared;
    }
    set domStorageItemsCleared(handler) {
        if (this._domStorageItemsCleared) {
            this._client.removeListener("DOMStorage.domStorageItemsCleared", this._domStorageItemsCleared);
        }
        this._domStorageItemsCleared = handler;
        if (handler) {
            this._client.on("DOMStorage.domStorageItemsCleared", handler);
        }
    }
}
exports.DOMStorage = DOMStorage;
class Database {
    constructor(client) {
        this._addDatabase = null;
        this._client = client;
    }
    /** Disables database tracking, prevents database events from being sent to the client. */
    disable() {
        return this._client.send("Database.disable");
    }
    /** Enables database tracking, database events will now be delivered to the client. */
    enable() {
        return this._client.send("Database.enable");
    }
    executeSQL(params) {
        return this._client.send("Database.executeSQL", params);
    }
    getDatabaseTableNames(params) {
        return this._client.send("Database.getDatabaseTableNames", params);
    }
    get addDatabase() {
        return this._addDatabase;
    }
    set addDatabase(handler) {
        if (this._addDatabase) {
            this._client.removeListener("Database.addDatabase", this._addDatabase);
        }
        this._addDatabase = handler;
        if (handler) {
            this._client.on("Database.addDatabase", handler);
        }
    }
}
exports.Database = Database;
class DeviceOrientation {
    constructor(client) {
        this._client = client;
    }
    /** Clears the overridden Device Orientation. */
    clearDeviceOrientationOverride() {
        return this._client.send("DeviceOrientation.clearDeviceOrientationOverride");
    }
    /** Overrides the Device Orientation. */
    setDeviceOrientationOverride(params) {
        return this._client.send("DeviceOrientation.setDeviceOrientationOverride", params);
    }
}
exports.DeviceOrientation = DeviceOrientation;
/** This domain emulates different environments for the page. */
class Emulation {
    constructor(client) {
        this._virtualTimeAdvanced = null;
        this._virtualTimeBudgetExpired = null;
        this._virtualTimePaused = null;
        this._client = client;
    }
    /** Tells whether emulation is supported. */
    canEmulate() {
        return this._client.send("Emulation.canEmulate");
    }
    /** Clears the overriden device metrics. */
    clearDeviceMetricsOverride() {
        return this._client.send("Emulation.clearDeviceMetricsOverride");
    }
    /** Clears the overriden Geolocation Position and Error. */
    clearGeolocationOverride() {
        return this._client.send("Emulation.clearGeolocationOverride");
    }
    /** Requests that page scale factor is reset to initial values. */
    resetPageScaleFactor() {
        return this._client.send("Emulation.resetPageScaleFactor");
    }
    /** Enables CPU throttling to emulate slow CPUs. */
    setCPUThrottlingRate(params) {
        return this._client.send("Emulation.setCPUThrottlingRate", params);
    }
    /** Sets or clears an override of the default background color of the frame. This override is used
  if the content does not specify one. */
    setDefaultBackgroundColorOverride(params) {
        return this._client.send("Emulation.setDefaultBackgroundColorOverride", params);
    }
    /** Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
  window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
  query results). */
    setDeviceMetricsOverride(params) {
        return this._client.send("Emulation.setDeviceMetricsOverride", params);
    }
    setScrollbarsHidden(params) {
        return this._client.send("Emulation.setScrollbarsHidden", params);
    }
    setDocumentCookieDisabled(params) {
        return this._client.send("Emulation.setDocumentCookieDisabled", params);
    }
    setEmitTouchEventsForMouse(params) {
        return this._client.send("Emulation.setEmitTouchEventsForMouse", params);
    }
    /** Emulates the given media for CSS media queries. */
    setEmulatedMedia(params) {
        return this._client.send("Emulation.setEmulatedMedia", params);
    }
    /** Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
  unavailable. */
    setGeolocationOverride(params) {
        return this._client.send("Emulation.setGeolocationOverride", params);
    }
    /** Overrides value returned by the javascript navigator object. */
    setNavigatorOverrides(params) {
        return this._client.send("Emulation.setNavigatorOverrides", params);
    }
    /** Sets a specified page scale factor. */
    setPageScaleFactor(params) {
        return this._client.send("Emulation.setPageScaleFactor", params);
    }
    /** Switches script execution in the page. */
    setScriptExecutionDisabled(params) {
        return this._client.send("Emulation.setScriptExecutionDisabled", params);
    }
    /** Enables touch on platforms which do not support them. */
    setTouchEmulationEnabled(params) {
        return this._client.send("Emulation.setTouchEmulationEnabled", params);
    }
    /** Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
  the current virtual time policy.  Note this supersedes any previous time budget. */
    setVirtualTimePolicy(params) {
        return this._client.send("Emulation.setVirtualTimePolicy", params);
    }
    /** Resizes the frame/viewport of the page. Note that this does not affect the frame's container
  (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
  on Android. */
    setVisibleSize(params) {
        return this._client.send("Emulation.setVisibleSize", params);
    }
    /** Allows overriding user agent with the given string. */
    setUserAgentOverride(params) {
        return this._client.send("Emulation.setUserAgentOverride", params);
    }
    /** Notification sent after the virtual time has advanced. */
    get virtualTimeAdvanced() {
        return this._virtualTimeAdvanced;
    }
    set virtualTimeAdvanced(handler) {
        if (this._virtualTimeAdvanced) {
            this._client.removeListener("Emulation.virtualTimeAdvanced", this._virtualTimeAdvanced);
        }
        this._virtualTimeAdvanced = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimeAdvanced", handler);
        }
    }
    /** Notification sent after the virtual time budget for the current VirtualTimePolicy has run out. */
    get virtualTimeBudgetExpired() {
        return this._virtualTimeBudgetExpired;
    }
    set virtualTimeBudgetExpired(handler) {
        if (this._virtualTimeBudgetExpired) {
            this._client.removeListener("Emulation.virtualTimeBudgetExpired", this._virtualTimeBudgetExpired);
        }
        this._virtualTimeBudgetExpired = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimeBudgetExpired", handler);
        }
    }
    /** Notification sent after the virtual time has paused. */
    get virtualTimePaused() {
        return this._virtualTimePaused;
    }
    set virtualTimePaused(handler) {
        if (this._virtualTimePaused) {
            this._client.removeListener("Emulation.virtualTimePaused", this._virtualTimePaused);
        }
        this._virtualTimePaused = handler;
        if (handler) {
            this._client.on("Emulation.virtualTimePaused", handler);
        }
    }
}
exports.Emulation = Emulation;
/** This domain provides experimental commands only supported in headless mode. */
class HeadlessExperimental {
    constructor(client) {
        this._needsBeginFramesChanged = null;
        this._client = client;
    }
    /** Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
  screenshot from the resulting frame. Requires that the target was created with enabled
  BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
  https://goo.gl/3zHXhB for more background. */
    beginFrame(params) {
        return this._client.send("HeadlessExperimental.beginFrame", params);
    }
    /** Disables headless events for the target. */
    disable() {
        return this._client.send("HeadlessExperimental.disable");
    }
    /** Enables headless events for the target. */
    enable() {
        return this._client.send("HeadlessExperimental.enable");
    }
    /** Issued when the target starts or stops needing BeginFrames. */
    get needsBeginFramesChanged() {
        return this._needsBeginFramesChanged;
    }
    set needsBeginFramesChanged(handler) {
        if (this._needsBeginFramesChanged) {
            this._client.removeListener("HeadlessExperimental.needsBeginFramesChanged", this._needsBeginFramesChanged);
        }
        this._needsBeginFramesChanged = handler;
        if (handler) {
            this._client.on("HeadlessExperimental.needsBeginFramesChanged", handler);
        }
    }
}
exports.HeadlessExperimental = HeadlessExperimental;
/** Input/Output operations for streams produced by DevTools. */
class IO {
    constructor(client) {
        this._client = client;
    }
    /** Close the stream, discard any temporary backing storage. */
    close(params) {
        return this._client.send("IO.close", params);
    }
    /** Read a chunk of the stream */
    read(params) {
        return this._client.send("IO.read", params);
    }
    /** Return UUID of Blob object specified by a remote object id. */
    resolveBlob(params) {
        return this._client.send("IO.resolveBlob", params);
    }
}
exports.IO = IO;
class IndexedDB {
    constructor(client) {
        this._client = client;
    }
    /** Clears all entries from an object store. */
    clearObjectStore(params) {
        return this._client.send("IndexedDB.clearObjectStore", params);
    }
    /** Deletes a database. */
    deleteDatabase(params) {
        return this._client.send("IndexedDB.deleteDatabase", params);
    }
    /** Delete a range of entries from an object store */
    deleteObjectStoreEntries(params) {
        return this._client.send("IndexedDB.deleteObjectStoreEntries", params);
    }
    /** Disables events from backend. */
    disable() {
        return this._client.send("IndexedDB.disable");
    }
    /** Enables events from backend. */
    enable() {
        return this._client.send("IndexedDB.enable");
    }
    /** Requests data from object store or index. */
    requestData(params) {
        return this._client.send("IndexedDB.requestData", params);
    }
    /** Requests database with given name in given frame. */
    requestDatabase(params) {
        return this._client.send("IndexedDB.requestDatabase", params);
    }
    /** Requests database names for given security origin. */
    requestDatabaseNames(params) {
        return this._client.send("IndexedDB.requestDatabaseNames", params);
    }
}
exports.IndexedDB = IndexedDB;
class Input {
    constructor(client) {
        this._client = client;
    }
    /** Dispatches a key event to the page. */
    dispatchKeyEvent(params) {
        return this._client.send("Input.dispatchKeyEvent", params);
    }
    /** This method emulates inserting text that doesn't come from a key press,
  for example an emoji keyboard or an IME. */
    insertText(params) {
        return this._client.send("Input.insertText", params);
    }
    /** Dispatches a mouse event to the page. */
    dispatchMouseEvent(params) {
        return this._client.send("Input.dispatchMouseEvent", params);
    }
    /** Dispatches a touch event to the page. */
    dispatchTouchEvent(params) {
        return this._client.send("Input.dispatchTouchEvent", params);
    }
    /** Emulates touch event from the mouse event parameters. */
    emulateTouchFromMouseEvent(params) {
        return this._client.send("Input.emulateTouchFromMouseEvent", params);
    }
    /** Ignores input events (useful while auditing page). */
    setIgnoreInputEvents(params) {
        return this._client.send("Input.setIgnoreInputEvents", params);
    }
    /** Synthesizes a pinch gesture over a time period by issuing appropriate touch events. */
    synthesizePinchGesture(params) {
        return this._client.send("Input.synthesizePinchGesture", params);
    }
    /** Synthesizes a scroll gesture over a time period by issuing appropriate touch events. */
    synthesizeScrollGesture(params) {
        return this._client.send("Input.synthesizeScrollGesture", params);
    }
    /** Synthesizes a tap gesture over a time period by issuing appropriate touch events. */
    synthesizeTapGesture(params) {
        return this._client.send("Input.synthesizeTapGesture", params);
    }
}
exports.Input = Input;
class Inspector {
    constructor(client) {
        this._detached = null;
        this._targetCrashed = null;
        this._targetReloadedAfterCrash = null;
        this._client = client;
    }
    /** Disables inspector domain notifications. */
    disable() {
        return this._client.send("Inspector.disable");
    }
    /** Enables inspector domain notifications. */
    enable() {
        return this._client.send("Inspector.enable");
    }
    /** Fired when remote debugging connection is about to be terminated. Contains detach reason. */
    get detached() {
        return this._detached;
    }
    set detached(handler) {
        if (this._detached) {
            this._client.removeListener("Inspector.detached", this._detached);
        }
        this._detached = handler;
        if (handler) {
            this._client.on("Inspector.detached", handler);
        }
    }
    /** Fired when debugging target has crashed */
    get targetCrashed() {
        return this._targetCrashed;
    }
    set targetCrashed(handler) {
        if (this._targetCrashed) {
            this._client.removeListener("Inspector.targetCrashed", this._targetCrashed);
        }
        this._targetCrashed = handler;
        if (handler) {
            this._client.on("Inspector.targetCrashed", handler);
        }
    }
    /** Fired when debugging target has reloaded after crash */
    get targetReloadedAfterCrash() {
        return this._targetReloadedAfterCrash;
    }
    set targetReloadedAfterCrash(handler) {
        if (this._targetReloadedAfterCrash) {
            this._client.removeListener("Inspector.targetReloadedAfterCrash", this._targetReloadedAfterCrash);
        }
        this._targetReloadedAfterCrash = handler;
        if (handler) {
            this._client.on("Inspector.targetReloadedAfterCrash", handler);
        }
    }
}
exports.Inspector = Inspector;
class LayerTree {
    constructor(client) {
        this._layerPainted = null;
        this._layerTreeDidChange = null;
        this._client = client;
    }
    /** Provides the reasons why the given layer was composited. */
    compositingReasons(params) {
        return this._client.send("LayerTree.compositingReasons", params);
    }
    /** Disables compositing tree inspection. */
    disable() {
        return this._client.send("LayerTree.disable");
    }
    /** Enables compositing tree inspection. */
    enable() {
        return this._client.send("LayerTree.enable");
    }
    /** Returns the snapshot identifier. */
    loadSnapshot(params) {
        return this._client.send("LayerTree.loadSnapshot", params);
    }
    /** Returns the layer snapshot identifier. */
    makeSnapshot(params) {
        return this._client.send("LayerTree.makeSnapshot", params);
    }
    profileSnapshot(params) {
        return this._client.send("LayerTree.profileSnapshot", params);
    }
    /** Releases layer snapshot captured by the back-end. */
    releaseSnapshot(params) {
        return this._client.send("LayerTree.releaseSnapshot", params);
    }
    /** Replays the layer snapshot and returns the resulting bitmap. */
    replaySnapshot(params) {
        return this._client.send("LayerTree.replaySnapshot", params);
    }
    /** Replays the layer snapshot and returns canvas log. */
    snapshotCommandLog(params) {
        return this._client.send("LayerTree.snapshotCommandLog", params);
    }
    get layerPainted() {
        return this._layerPainted;
    }
    set layerPainted(handler) {
        if (this._layerPainted) {
            this._client.removeListener("LayerTree.layerPainted", this._layerPainted);
        }
        this._layerPainted = handler;
        if (handler) {
            this._client.on("LayerTree.layerPainted", handler);
        }
    }
    get layerTreeDidChange() {
        return this._layerTreeDidChange;
    }
    set layerTreeDidChange(handler) {
        if (this._layerTreeDidChange) {
            this._client.removeListener("LayerTree.layerTreeDidChange", this._layerTreeDidChange);
        }
        this._layerTreeDidChange = handler;
        if (handler) {
            this._client.on("LayerTree.layerTreeDidChange", handler);
        }
    }
}
exports.LayerTree = LayerTree;
/** Provides access to log entries. */
class Log {
    constructor(client) {
        this._entryAdded = null;
        this._client = client;
    }
    /** Clears the log. */
    clear() {
        return this._client.send("Log.clear");
    }
    /** Disables log domain, prevents further log entries from being reported to the client. */
    disable() {
        return this._client.send("Log.disable");
    }
    /** Enables log domain, sends the entries collected so far to the client by means of the
  `entryAdded` notification. */
    enable() {
        return this._client.send("Log.enable");
    }
    /** start violation reporting. */
    startViolationsReport(params) {
        return this._client.send("Log.startViolationsReport", params);
    }
    /** Stop violation reporting. */
    stopViolationsReport() {
        return this._client.send("Log.stopViolationsReport");
    }
    /** Issued when new message was logged. */
    get entryAdded() {
        return this._entryAdded;
    }
    set entryAdded(handler) {
        if (this._entryAdded) {
            this._client.removeListener("Log.entryAdded", this._entryAdded);
        }
        this._entryAdded = handler;
        if (handler) {
            this._client.on("Log.entryAdded", handler);
        }
    }
}
exports.Log = Log;
class Memory {
    constructor(client) {
        this._client = client;
    }
    getDOMCounters() {
        return this._client.send("Memory.getDOMCounters");
    }
    prepareForLeakDetection() {
        return this._client.send("Memory.prepareForLeakDetection");
    }
    /** Enable/disable suppressing memory pressure notifications in all processes. */
    setPressureNotificationsSuppressed(params) {
        return this._client.send("Memory.setPressureNotificationsSuppressed", params);
    }
    /** Simulate a memory pressure notification in all processes. */
    simulatePressureNotification(params) {
        return this._client.send("Memory.simulatePressureNotification", params);
    }
    /** Start collecting native memory profile. */
    startSampling(params) {
        return this._client.send("Memory.startSampling", params);
    }
    /** Stop collecting native memory profile. */
    stopSampling() {
        return this._client.send("Memory.stopSampling");
    }
    /** Retrieve native memory allocations profile
  collected since renderer process startup. */
    getAllTimeSamplingProfile() {
        return this._client.send("Memory.getAllTimeSamplingProfile");
    }
    /** Retrieve native memory allocations profile
  collected since browser process startup. */
    getBrowserSamplingProfile() {
        return this._client.send("Memory.getBrowserSamplingProfile");
    }
    /** Retrieve native memory allocations profile collected since last
  `startSampling` call. */
    getSamplingProfile() {
        return this._client.send("Memory.getSamplingProfile");
    }
}
exports.Memory = Memory;
/** Network domain allows tracking network activities of the page. It exposes information about http,
file, data and other requests and responses, their headers, bodies, timing, etc. */
class Network {
    constructor(client) {
        this._dataReceived = null;
        this._eventSourceMessageReceived = null;
        this._loadingFailed = null;
        this._loadingFinished = null;
        this._requestIntercepted = null;
        this._requestServedFromCache = null;
        this._requestWillBeSent = null;
        this._resourceChangedPriority = null;
        this._signedExchangeReceived = null;
        this._responseReceived = null;
        this._webSocketClosed = null;
        this._webSocketCreated = null;
        this._webSocketFrameError = null;
        this._webSocketFrameReceived = null;
        this._webSocketFrameSent = null;
        this._webSocketHandshakeResponseReceived = null;
        this._webSocketWillSendHandshakeRequest = null;
        this._client = client;
    }
    /** Tells whether clearing browser cache is supported. */
    canClearBrowserCache() {
        return this._client.send("Network.canClearBrowserCache");
    }
    /** Tells whether clearing browser cookies is supported. */
    canClearBrowserCookies() {
        return this._client.send("Network.canClearBrowserCookies");
    }
    /** Tells whether emulation of network conditions is supported. */
    canEmulateNetworkConditions() {
        return this._client.send("Network.canEmulateNetworkConditions");
    }
    /** Clears browser cache. */
    clearBrowserCache() {
        return this._client.send("Network.clearBrowserCache");
    }
    /** Clears browser cookies. */
    clearBrowserCookies() {
        return this._client.send("Network.clearBrowserCookies");
    }
    /** Response to Network.requestIntercepted which either modifies the request to continue with any
  modifications, or blocks it, or completes it with the provided response bytes. If a network
  fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
  event will be sent with the same InterceptionId. */
    continueInterceptedRequest(params) {
        return this._client.send("Network.continueInterceptedRequest", params);
    }
    /** Deletes browser cookies with matching name and url or domain/path pair. */
    deleteCookies(params) {
        return this._client.send("Network.deleteCookies", params);
    }
    /** Disables network tracking, prevents network events from being sent to the client. */
    disable() {
        return this._client.send("Network.disable");
    }
    /** Activates emulation of network conditions. */
    emulateNetworkConditions(params) {
        return this._client.send("Network.emulateNetworkConditions", params);
    }
    /** Enables network tracking, network events will now be delivered to the client. */
    enable(params) {
        return this._client.send("Network.enable", params);
    }
    /** Returns all browser cookies. Depending on the backend support, will return detailed cookie
  information in the `cookies` field. */
    getAllCookies() {
        return this._client.send("Network.getAllCookies");
    }
    /** Returns the DER-encoded certificate. */
    getCertificate(params) {
        return this._client.send("Network.getCertificate", params);
    }
    /** Returns all browser cookies for the current URL. Depending on the backend support, will return
  detailed cookie information in the `cookies` field. */
    getCookies(params) {
        return this._client.send("Network.getCookies", params);
    }
    /** Returns content served for the given request. */
    getResponseBody(params) {
        return this._client.send("Network.getResponseBody", params);
    }
    /** Returns post data sent with the request. Returns an error when no data was sent with the request. */
    getRequestPostData(params) {
        return this._client.send("Network.getRequestPostData", params);
    }
    /** Returns content served for the given currently intercepted request. */
    getResponseBodyForInterception(params) {
        return this._client.send("Network.getResponseBodyForInterception", params);
    }
    /** Returns a handle to the stream representing the response body. Note that after this command,
  the intercepted request can't be continued as is -- you either need to cancel it or to provide
  the response body. The stream only supports sequential read, IO.read will fail if the position
  is specified. */
    takeResponseBodyForInterceptionAsStream(params) {
        return this._client.send("Network.takeResponseBodyForInterceptionAsStream", params);
    }
    /** This method sends a new XMLHttpRequest which is identical to the original one. The following
  parameters should be identical: method, url, async, request body, extra headers, withCredentials
  attribute, user, password. */
    replayXHR(params) {
        return this._client.send("Network.replayXHR", params);
    }
    /** Searches for given string in response content. */
    searchInResponseBody(params) {
        return this._client.send("Network.searchInResponseBody", params);
    }
    /** Blocks URLs from loading. */
    setBlockedURLs(params) {
        return this._client.send("Network.setBlockedURLs", params);
    }
    /** Toggles ignoring of service worker for each request. */
    setBypassServiceWorker(params) {
        return this._client.send("Network.setBypassServiceWorker", params);
    }
    /** Toggles ignoring cache for each request. If `true`, cache will not be used. */
    setCacheDisabled(params) {
        return this._client.send("Network.setCacheDisabled", params);
    }
    /** Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. */
    setCookie(params) {
        return this._client.send("Network.setCookie", params);
    }
    /** Sets given cookies. */
    setCookies(params) {
        return this._client.send("Network.setCookies", params);
    }
    /** For testing. */
    setDataSizeLimitsForTest(params) {
        return this._client.send("Network.setDataSizeLimitsForTest", params);
    }
    /** Specifies whether to always send extra HTTP headers with the requests from this page. */
    setExtraHTTPHeaders(params) {
        return this._client.send("Network.setExtraHTTPHeaders", params);
    }
    /** Sets the requests to intercept that match a the provided patterns and optionally resource types. */
    setRequestInterception(params) {
        return this._client.send("Network.setRequestInterception", params);
    }
    /** Allows overriding user agent with the given string. */
    setUserAgentOverride(params) {
        return this._client.send("Network.setUserAgentOverride", params);
    }
    /** Fired when data chunk was received over the network. */
    get dataReceived() {
        return this._dataReceived;
    }
    set dataReceived(handler) {
        if (this._dataReceived) {
            this._client.removeListener("Network.dataReceived", this._dataReceived);
        }
        this._dataReceived = handler;
        if (handler) {
            this._client.on("Network.dataReceived", handler);
        }
    }
    /** Fired when EventSource message is received. */
    get eventSourceMessageReceived() {
        return this._eventSourceMessageReceived;
    }
    set eventSourceMessageReceived(handler) {
        if (this._eventSourceMessageReceived) {
            this._client.removeListener("Network.eventSourceMessageReceived", this._eventSourceMessageReceived);
        }
        this._eventSourceMessageReceived = handler;
        if (handler) {
            this._client.on("Network.eventSourceMessageReceived", handler);
        }
    }
    /** Fired when HTTP request has failed to load. */
    get loadingFailed() {
        return this._loadingFailed;
    }
    set loadingFailed(handler) {
        if (this._loadingFailed) {
            this._client.removeListener("Network.loadingFailed", this._loadingFailed);
        }
        this._loadingFailed = handler;
        if (handler) {
            this._client.on("Network.loadingFailed", handler);
        }
    }
    /** Fired when HTTP request has finished loading. */
    get loadingFinished() {
        return this._loadingFinished;
    }
    set loadingFinished(handler) {
        if (this._loadingFinished) {
            this._client.removeListener("Network.loadingFinished", this._loadingFinished);
        }
        this._loadingFinished = handler;
        if (handler) {
            this._client.on("Network.loadingFinished", handler);
        }
    }
    /** Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
  mocked. */
    get requestIntercepted() {
        return this._requestIntercepted;
    }
    set requestIntercepted(handler) {
        if (this._requestIntercepted) {
            this._client.removeListener("Network.requestIntercepted", this._requestIntercepted);
        }
        this._requestIntercepted = handler;
        if (handler) {
            this._client.on("Network.requestIntercepted", handler);
        }
    }
    /** Fired if request ended up loading from cache. */
    get requestServedFromCache() {
        return this._requestServedFromCache;
    }
    set requestServedFromCache(handler) {
        if (this._requestServedFromCache) {
            this._client.removeListener("Network.requestServedFromCache", this._requestServedFromCache);
        }
        this._requestServedFromCache = handler;
        if (handler) {
            this._client.on("Network.requestServedFromCache", handler);
        }
    }
    /** Fired when page is about to send HTTP request. */
    get requestWillBeSent() {
        return this._requestWillBeSent;
    }
    set requestWillBeSent(handler) {
        if (this._requestWillBeSent) {
            this._client.removeListener("Network.requestWillBeSent", this._requestWillBeSent);
        }
        this._requestWillBeSent = handler;
        if (handler) {
            this._client.on("Network.requestWillBeSent", handler);
        }
    }
    /** Fired when resource loading priority is changed */
    get resourceChangedPriority() {
        return this._resourceChangedPriority;
    }
    set resourceChangedPriority(handler) {
        if (this._resourceChangedPriority) {
            this._client.removeListener("Network.resourceChangedPriority", this._resourceChangedPriority);
        }
        this._resourceChangedPriority = handler;
        if (handler) {
            this._client.on("Network.resourceChangedPriority", handler);
        }
    }
    /** Fired when a signed exchange was received over the network */
    get signedExchangeReceived() {
        return this._signedExchangeReceived;
    }
    set signedExchangeReceived(handler) {
        if (this._signedExchangeReceived) {
            this._client.removeListener("Network.signedExchangeReceived", this._signedExchangeReceived);
        }
        this._signedExchangeReceived = handler;
        if (handler) {
            this._client.on("Network.signedExchangeReceived", handler);
        }
    }
    /** Fired when HTTP response is available. */
    get responseReceived() {
        return this._responseReceived;
    }
    set responseReceived(handler) {
        if (this._responseReceived) {
            this._client.removeListener("Network.responseReceived", this._responseReceived);
        }
        this._responseReceived = handler;
        if (handler) {
            this._client.on("Network.responseReceived", handler);
        }
    }
    /** Fired when WebSocket is closed. */
    get webSocketClosed() {
        return this._webSocketClosed;
    }
    set webSocketClosed(handler) {
        if (this._webSocketClosed) {
            this._client.removeListener("Network.webSocketClosed", this._webSocketClosed);
        }
        this._webSocketClosed = handler;
        if (handler) {
            this._client.on("Network.webSocketClosed", handler);
        }
    }
    /** Fired upon WebSocket creation. */
    get webSocketCreated() {
        return this._webSocketCreated;
    }
    set webSocketCreated(handler) {
        if (this._webSocketCreated) {
            this._client.removeListener("Network.webSocketCreated", this._webSocketCreated);
        }
        this._webSocketCreated = handler;
        if (handler) {
            this._client.on("Network.webSocketCreated", handler);
        }
    }
    /** Fired when WebSocket frame error occurs. */
    get webSocketFrameError() {
        return this._webSocketFrameError;
    }
    set webSocketFrameError(handler) {
        if (this._webSocketFrameError) {
            this._client.removeListener("Network.webSocketFrameError", this._webSocketFrameError);
        }
        this._webSocketFrameError = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameError", handler);
        }
    }
    /** Fired when WebSocket frame is received. */
    get webSocketFrameReceived() {
        return this._webSocketFrameReceived;
    }
    set webSocketFrameReceived(handler) {
        if (this._webSocketFrameReceived) {
            this._client.removeListener("Network.webSocketFrameReceived", this._webSocketFrameReceived);
        }
        this._webSocketFrameReceived = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameReceived", handler);
        }
    }
    /** Fired when WebSocket frame is sent. */
    get webSocketFrameSent() {
        return this._webSocketFrameSent;
    }
    set webSocketFrameSent(handler) {
        if (this._webSocketFrameSent) {
            this._client.removeListener("Network.webSocketFrameSent", this._webSocketFrameSent);
        }
        this._webSocketFrameSent = handler;
        if (handler) {
            this._client.on("Network.webSocketFrameSent", handler);
        }
    }
    /** Fired when WebSocket handshake response becomes available. */
    get webSocketHandshakeResponseReceived() {
        return this._webSocketHandshakeResponseReceived;
    }
    set webSocketHandshakeResponseReceived(handler) {
        if (this._webSocketHandshakeResponseReceived) {
            this._client.removeListener("Network.webSocketHandshakeResponseReceived", this._webSocketHandshakeResponseReceived);
        }
        this._webSocketHandshakeResponseReceived = handler;
        if (handler) {
            this._client.on("Network.webSocketHandshakeResponseReceived", handler);
        }
    }
    /** Fired when WebSocket is about to initiate handshake. */
    get webSocketWillSendHandshakeRequest() {
        return this._webSocketWillSendHandshakeRequest;
    }
    set webSocketWillSendHandshakeRequest(handler) {
        if (this._webSocketWillSendHandshakeRequest) {
            this._client.removeListener("Network.webSocketWillSendHandshakeRequest", this._webSocketWillSendHandshakeRequest);
        }
        this._webSocketWillSendHandshakeRequest = handler;
        if (handler) {
            this._client.on("Network.webSocketWillSendHandshakeRequest", handler);
        }
    }
}
exports.Network = Network;
/** This domain provides various functionality related to drawing atop the inspected page. */
class Overlay {
    constructor(client) {
        this._inspectNodeRequested = null;
        this._nodeHighlightRequested = null;
        this._screenshotRequested = null;
        this._client = client;
    }
    /** Disables domain notifications. */
    disable() {
        return this._client.send("Overlay.disable");
    }
    /** Enables domain notifications. */
    enable() {
        return this._client.send("Overlay.enable");
    }
    /** For testing. */
    getHighlightObjectForTest(params) {
        return this._client.send("Overlay.getHighlightObjectForTest", params);
    }
    /** Hides any highlight. */
    hideHighlight() {
        return this._client.send("Overlay.hideHighlight");
    }
    /** Highlights owner element of the frame with given id. */
    highlightFrame(params) {
        return this._client.send("Overlay.highlightFrame", params);
    }
    /** Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
  objectId must be specified. */
    highlightNode(params) {
        return this._client.send("Overlay.highlightNode", params);
    }
    /** Highlights given quad. Coordinates are absolute with respect to the main frame viewport. */
    highlightQuad(params) {
        return this._client.send("Overlay.highlightQuad", params);
    }
    /** Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. */
    highlightRect(params) {
        return this._client.send("Overlay.highlightRect", params);
    }
    /** Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
  Backend then generates 'inspectNodeRequested' event upon element selection. */
    setInspectMode(params) {
        return this._client.send("Overlay.setInspectMode", params);
    }
    setPausedInDebuggerMessage(params) {
        return this._client.send("Overlay.setPausedInDebuggerMessage", params);
    }
    /** Requests that backend shows debug borders on layers */
    setShowDebugBorders(params) {
        return this._client.send("Overlay.setShowDebugBorders", params);
    }
    /** Requests that backend shows the FPS counter */
    setShowFPSCounter(params) {
        return this._client.send("Overlay.setShowFPSCounter", params);
    }
    /** Requests that backend shows paint rectangles */
    setShowPaintRects(params) {
        return this._client.send("Overlay.setShowPaintRects", params);
    }
    /** Requests that backend shows scroll bottleneck rects */
    setShowScrollBottleneckRects(params) {
        return this._client.send("Overlay.setShowScrollBottleneckRects", params);
    }
    /** Paints viewport size upon main frame resize. */
    setShowViewportSizeOnResize(params) {
        return this._client.send("Overlay.setShowViewportSizeOnResize", params);
    }
    setSuspended(params) {
        return this._client.send("Overlay.setSuspended", params);
    }
    /** Fired when the node should be inspected. This happens after call to `setInspectMode` or when
  user manually inspects an element. */
    get inspectNodeRequested() {
        return this._inspectNodeRequested;
    }
    set inspectNodeRequested(handler) {
        if (this._inspectNodeRequested) {
            this._client.removeListener("Overlay.inspectNodeRequested", this._inspectNodeRequested);
        }
        this._inspectNodeRequested = handler;
        if (handler) {
            this._client.on("Overlay.inspectNodeRequested", handler);
        }
    }
    /** Fired when the node should be highlighted. This happens after call to `setInspectMode`. */
    get nodeHighlightRequested() {
        return this._nodeHighlightRequested;
    }
    set nodeHighlightRequested(handler) {
        if (this._nodeHighlightRequested) {
            this._client.removeListener("Overlay.nodeHighlightRequested", this._nodeHighlightRequested);
        }
        this._nodeHighlightRequested = handler;
        if (handler) {
            this._client.on("Overlay.nodeHighlightRequested", handler);
        }
    }
    /** Fired when user asks to capture screenshot of some area on the page. */
    get screenshotRequested() {
        return this._screenshotRequested;
    }
    set screenshotRequested(handler) {
        if (this._screenshotRequested) {
            this._client.removeListener("Overlay.screenshotRequested", this._screenshotRequested);
        }
        this._screenshotRequested = handler;
        if (handler) {
            this._client.on("Overlay.screenshotRequested", handler);
        }
    }
}
exports.Overlay = Overlay;
/** Actions and events related to the inspected page belong to the page domain. */
class Page {
    constructor(client) {
        this._domContentEventFired = null;
        this._frameAttached = null;
        this._frameClearedScheduledNavigation = null;
        this._frameDetached = null;
        this._frameNavigated = null;
        this._frameResized = null;
        this._frameScheduledNavigation = null;
        this._frameStartedLoading = null;
        this._frameStoppedLoading = null;
        this._interstitialHidden = null;
        this._interstitialShown = null;
        this._javascriptDialogClosed = null;
        this._javascriptDialogOpening = null;
        this._lifecycleEvent = null;
        this._loadEventFired = null;
        this._navigatedWithinDocument = null;
        this._screencastFrame = null;
        this._screencastVisibilityChanged = null;
        this._windowOpen = null;
        this._compilationCacheProduced = null;
        this._client = client;
    }
    /** Deprecated, please use addScriptToEvaluateOnNewDocument instead. */
    addScriptToEvaluateOnLoad(params) {
        return this._client.send("Page.addScriptToEvaluateOnLoad", params);
    }
    /** Evaluates given script in every frame upon creation (before loading frame's scripts). */
    addScriptToEvaluateOnNewDocument(params) {
        return this._client.send("Page.addScriptToEvaluateOnNewDocument", params);
    }
    /** Brings page to front (activates tab). */
    bringToFront() {
        return this._client.send("Page.bringToFront");
    }
    /** Capture page screenshot. */
    captureScreenshot(params) {
        return this._client.send("Page.captureScreenshot", params);
    }
    /** Clears the overriden device metrics. */
    clearDeviceMetricsOverride() {
        return this._client.send("Page.clearDeviceMetricsOverride");
    }
    /** Clears the overridden Device Orientation. */
    clearDeviceOrientationOverride() {
        return this._client.send("Page.clearDeviceOrientationOverride");
    }
    /** Clears the overriden Geolocation Position and Error. */
    clearGeolocationOverride() {
        return this._client.send("Page.clearGeolocationOverride");
    }
    /** Creates an isolated world for the given frame. */
    createIsolatedWorld(params) {
        return this._client.send("Page.createIsolatedWorld", params);
    }
    /** Deletes browser cookie with given name, domain and path. */
    deleteCookie(params) {
        return this._client.send("Page.deleteCookie", params);
    }
    /** Disables page domain notifications. */
    disable() {
        return this._client.send("Page.disable");
    }
    /** Enables page domain notifications. */
    enable() {
        return this._client.send("Page.enable");
    }
    getAppManifest() {
        return this._client.send("Page.getAppManifest");
    }
    /** Returns all browser cookies. Depending on the backend support, will return detailed cookie
  information in the `cookies` field. */
    getCookies() {
        return this._client.send("Page.getCookies");
    }
    /** Returns present frame tree structure. */
    getFrameTree() {
        return this._client.send("Page.getFrameTree");
    }
    /** Returns metrics relating to the layouting of the page, such as viewport bounds/scale. */
    getLayoutMetrics() {
        return this._client.send("Page.getLayoutMetrics");
    }
    /** Returns navigation history for the current page. */
    getNavigationHistory() {
        return this._client.send("Page.getNavigationHistory");
    }
    /** Returns content of the given resource. */
    getResourceContent(params) {
        return this._client.send("Page.getResourceContent", params);
    }
    /** Returns present frame / resource tree structure. */
    getResourceTree() {
        return this._client.send("Page.getResourceTree");
    }
    /** Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). */
    handleJavaScriptDialog(params) {
        return this._client.send("Page.handleJavaScriptDialog", params);
    }
    /** Navigates current page to the given URL. */
    navigate(params) {
        return this._client.send("Page.navigate", params);
    }
    /** Navigates current page to the given history entry. */
    navigateToHistoryEntry(params) {
        return this._client.send("Page.navigateToHistoryEntry", params);
    }
    /** Print page as PDF. */
    printToPDF(params) {
        return this._client.send("Page.printToPDF", params);
    }
    /** Reloads given page optionally ignoring the cache. */
    reload(params) {
        return this._client.send("Page.reload", params);
    }
    /** Deprecated, please use removeScriptToEvaluateOnNewDocument instead. */
    removeScriptToEvaluateOnLoad(params) {
        return this._client.send("Page.removeScriptToEvaluateOnLoad", params);
    }
    /** Removes given script from the list. */
    removeScriptToEvaluateOnNewDocument(params) {
        return this._client.send("Page.removeScriptToEvaluateOnNewDocument", params);
    }
    requestAppBanner() {
        return this._client.send("Page.requestAppBanner");
    }
    /** Acknowledges that a screencast frame has been received by the frontend. */
    screencastFrameAck(params) {
        return this._client.send("Page.screencastFrameAck", params);
    }
    /** Searches for given string in resource content. */
    searchInResource(params) {
        return this._client.send("Page.searchInResource", params);
    }
    /** Enable Chrome's experimental ad filter on all sites. */
    setAdBlockingEnabled(params) {
        return this._client.send("Page.setAdBlockingEnabled", params);
    }
    /** Enable page Content Security Policy by-passing. */
    setBypassCSP(params) {
        return this._client.send("Page.setBypassCSP", params);
    }
    /** Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
  window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
  query results). */
    setDeviceMetricsOverride(params) {
        return this._client.send("Page.setDeviceMetricsOverride", params);
    }
    /** Overrides the Device Orientation. */
    setDeviceOrientationOverride(params) {
        return this._client.send("Page.setDeviceOrientationOverride", params);
    }
    /** Set generic font families. */
    setFontFamilies(params) {
        return this._client.send("Page.setFontFamilies", params);
    }
    /** Set default font sizes. */
    setFontSizes(params) {
        return this._client.send("Page.setFontSizes", params);
    }
    /** Sets given markup as the document's HTML. */
    setDocumentContent(params) {
        return this._client.send("Page.setDocumentContent", params);
    }
    /** Set the behavior when downloading a file. */
    setDownloadBehavior(params) {
        return this._client.send("Page.setDownloadBehavior", params);
    }
    /** Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
  unavailable. */
    setGeolocationOverride(params) {
        return this._client.send("Page.setGeolocationOverride", params);
    }
    /** Controls whether page will emit lifecycle events. */
    setLifecycleEventsEnabled(params) {
        return this._client.send("Page.setLifecycleEventsEnabled", params);
    }
    /** Toggles mouse event-based touch event emulation. */
    setTouchEmulationEnabled(params) {
        return this._client.send("Page.setTouchEmulationEnabled", params);
    }
    /** Starts sending each frame using the `screencastFrame` event. */
    startScreencast(params) {
        return this._client.send("Page.startScreencast", params);
    }
    /** Force the page stop all navigations and pending resource fetches. */
    stopLoading() {
        return this._client.send("Page.stopLoading");
    }
    /** Crashes renderer on the IO thread, generates minidumps. */
    crash() {
        return this._client.send("Page.crash");
    }
    /** Tries to close page, running its beforeunload hooks, if any. */
    close() {
        return this._client.send("Page.close");
    }
    /** Tries to update the web lifecycle state of the page.
  It will transition the page to the given state according to:
  https://github.com/WICG/web-lifecycle/ */
    setWebLifecycleState(params) {
        return this._client.send("Page.setWebLifecycleState", params);
    }
    /** Stops sending each frame in the `screencastFrame`. */
    stopScreencast() {
        return this._client.send("Page.stopScreencast");
    }
    /** Forces compilation cache to be generated for every subresource script. */
    setProduceCompilationCache(params) {
        return this._client.send("Page.setProduceCompilationCache", params);
    }
    /** Seeds compilation cache for given url. Compilation cache does not survive
  cross-process navigation. */
    addCompilationCache(params) {
        return this._client.send("Page.addCompilationCache", params);
    }
    /** Clears seeded compilation cache. */
    clearCompilationCache() {
        return this._client.send("Page.clearCompilationCache");
    }
    /** Generates a report for testing. */
    generateTestReport(params) {
        return this._client.send("Page.generateTestReport", params);
    }
    get domContentEventFired() {
        return this._domContentEventFired;
    }
    set domContentEventFired(handler) {
        if (this._domContentEventFired) {
            this._client.removeListener("Page.domContentEventFired", this._domContentEventFired);
        }
        this._domContentEventFired = handler;
        if (handler) {
            this._client.on("Page.domContentEventFired", handler);
        }
    }
    /** Fired when frame has been attached to its parent. */
    get frameAttached() {
        return this._frameAttached;
    }
    set frameAttached(handler) {
        if (this._frameAttached) {
            this._client.removeListener("Page.frameAttached", this._frameAttached);
        }
        this._frameAttached = handler;
        if (handler) {
            this._client.on("Page.frameAttached", handler);
        }
    }
    /** Fired when frame no longer has a scheduled navigation. */
    get frameClearedScheduledNavigation() {
        return this._frameClearedScheduledNavigation;
    }
    set frameClearedScheduledNavigation(handler) {
        if (this._frameClearedScheduledNavigation) {
            this._client.removeListener("Page.frameClearedScheduledNavigation", this._frameClearedScheduledNavigation);
        }
        this._frameClearedScheduledNavigation = handler;
        if (handler) {
            this._client.on("Page.frameClearedScheduledNavigation", handler);
        }
    }
    /** Fired when frame has been detached from its parent. */
    get frameDetached() {
        return this._frameDetached;
    }
    set frameDetached(handler) {
        if (this._frameDetached) {
            this._client.removeListener("Page.frameDetached", this._frameDetached);
        }
        this._frameDetached = handler;
        if (handler) {
            this._client.on("Page.frameDetached", handler);
        }
    }
    /** Fired once navigation of the frame has completed. Frame is now associated with the new loader. */
    get frameNavigated() {
        return this._frameNavigated;
    }
    set frameNavigated(handler) {
        if (this._frameNavigated) {
            this._client.removeListener("Page.frameNavigated", this._frameNavigated);
        }
        this._frameNavigated = handler;
        if (handler) {
            this._client.on("Page.frameNavigated", handler);
        }
    }
    get frameResized() {
        return this._frameResized;
    }
    set frameResized(handler) {
        if (this._frameResized) {
            this._client.removeListener("Page.frameResized", this._frameResized);
        }
        this._frameResized = handler;
        if (handler) {
            this._client.on("Page.frameResized", handler);
        }
    }
    /** Fired when frame schedules a potential navigation. */
    get frameScheduledNavigation() {
        return this._frameScheduledNavigation;
    }
    set frameScheduledNavigation(handler) {
        if (this._frameScheduledNavigation) {
            this._client.removeListener("Page.frameScheduledNavigation", this._frameScheduledNavigation);
        }
        this._frameScheduledNavigation = handler;
        if (handler) {
            this._client.on("Page.frameScheduledNavigation", handler);
        }
    }
    /** Fired when frame has started loading. */
    get frameStartedLoading() {
        return this._frameStartedLoading;
    }
    set frameStartedLoading(handler) {
        if (this._frameStartedLoading) {
            this._client.removeListener("Page.frameStartedLoading", this._frameStartedLoading);
        }
        this._frameStartedLoading = handler;
        if (handler) {
            this._client.on("Page.frameStartedLoading", handler);
        }
    }
    /** Fired when frame has stopped loading. */
    get frameStoppedLoading() {
        return this._frameStoppedLoading;
    }
    set frameStoppedLoading(handler) {
        if (this._frameStoppedLoading) {
            this._client.removeListener("Page.frameStoppedLoading", this._frameStoppedLoading);
        }
        this._frameStoppedLoading = handler;
        if (handler) {
            this._client.on("Page.frameStoppedLoading", handler);
        }
    }
    /** Fired when interstitial page was hidden */
    get interstitialHidden() {
        return this._interstitialHidden;
    }
    set interstitialHidden(handler) {
        if (this._interstitialHidden) {
            this._client.removeListener("Page.interstitialHidden", this._interstitialHidden);
        }
        this._interstitialHidden = handler;
        if (handler) {
            this._client.on("Page.interstitialHidden", handler);
        }
    }
    /** Fired when interstitial page was shown */
    get interstitialShown() {
        return this._interstitialShown;
    }
    set interstitialShown(handler) {
        if (this._interstitialShown) {
            this._client.removeListener("Page.interstitialShown", this._interstitialShown);
        }
        this._interstitialShown = handler;
        if (handler) {
            this._client.on("Page.interstitialShown", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
  closed. */
    get javascriptDialogClosed() {
        return this._javascriptDialogClosed;
    }
    set javascriptDialogClosed(handler) {
        if (this._javascriptDialogClosed) {
            this._client.removeListener("Page.javascriptDialogClosed", this._javascriptDialogClosed);
        }
        this._javascriptDialogClosed = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogClosed", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
  open. */
    get javascriptDialogOpening() {
        return this._javascriptDialogOpening;
    }
    set javascriptDialogOpening(handler) {
        if (this._javascriptDialogOpening) {
            this._client.removeListener("Page.javascriptDialogOpening", this._javascriptDialogOpening);
        }
        this._javascriptDialogOpening = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogOpening", handler);
        }
    }
    /** Fired for top level page lifecycle events such as navigation, load, paint, etc. */
    get lifecycleEvent() {
        return this._lifecycleEvent;
    }
    set lifecycleEvent(handler) {
        if (this._lifecycleEvent) {
            this._client.removeListener("Page.lifecycleEvent", this._lifecycleEvent);
        }
        this._lifecycleEvent = handler;
        if (handler) {
            this._client.on("Page.lifecycleEvent", handler);
        }
    }
    get loadEventFired() {
        return this._loadEventFired;
    }
    set loadEventFired(handler) {
        if (this._loadEventFired) {
            this._client.removeListener("Page.loadEventFired", this._loadEventFired);
        }
        this._loadEventFired = handler;
        if (handler) {
            this._client.on("Page.loadEventFired", handler);
        }
    }
    /** Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation. */
    get navigatedWithinDocument() {
        return this._navigatedWithinDocument;
    }
    set navigatedWithinDocument(handler) {
        if (this._navigatedWithinDocument) {
            this._client.removeListener("Page.navigatedWithinDocument", this._navigatedWithinDocument);
        }
        this._navigatedWithinDocument = handler;
        if (handler) {
            this._client.on("Page.navigatedWithinDocument", handler);
        }
    }
    /** Compressed image data requested by the `startScreencast`. */
    get screencastFrame() {
        return this._screencastFrame;
    }
    set screencastFrame(handler) {
        if (this._screencastFrame) {
            this._client.removeListener("Page.screencastFrame", this._screencastFrame);
        }
        this._screencastFrame = handler;
        if (handler) {
            this._client.on("Page.screencastFrame", handler);
        }
    }
    /** Fired when the page with currently enabled screencast was shown or hidden `. */
    get screencastVisibilityChanged() {
        return this._screencastVisibilityChanged;
    }
    set screencastVisibilityChanged(handler) {
        if (this._screencastVisibilityChanged) {
            this._client.removeListener("Page.screencastVisibilityChanged", this._screencastVisibilityChanged);
        }
        this._screencastVisibilityChanged = handler;
        if (handler) {
            this._client.on("Page.screencastVisibilityChanged", handler);
        }
    }
    /** Fired when a new window is going to be opened, via window.open(), link click, form submission,
  etc. */
    get windowOpen() {
        return this._windowOpen;
    }
    set windowOpen(handler) {
        if (this._windowOpen) {
            this._client.removeListener("Page.windowOpen", this._windowOpen);
        }
        this._windowOpen = handler;
        if (handler) {
            this._client.on("Page.windowOpen", handler);
        }
    }
    /** Issued for every compilation cache generated. Is only available
  if Page.setGenerateCompilationCache is enabled. */
    get compilationCacheProduced() {
        return this._compilationCacheProduced;
    }
    set compilationCacheProduced(handler) {
        if (this._compilationCacheProduced) {
            this._client.removeListener("Page.compilationCacheProduced", this._compilationCacheProduced);
        }
        this._compilationCacheProduced = handler;
        if (handler) {
            this._client.on("Page.compilationCacheProduced", handler);
        }
    }
}
exports.Page = Page;
class Performance {
    constructor(client) {
        this._metrics = null;
        this._client = client;
    }
    /** Disable collecting and reporting metrics. */
    disable() {
        return this._client.send("Performance.disable");
    }
    /** Enable collecting and reporting metrics. */
    enable() {
        return this._client.send("Performance.enable");
    }
    /** Retrieve current values of run-time metrics. */
    getMetrics() {
        return this._client.send("Performance.getMetrics");
    }
    /** Current values of the metrics. */
    get metrics() {
        return this._metrics;
    }
    set metrics(handler) {
        if (this._metrics) {
            this._client.removeListener("Performance.metrics", this._metrics);
        }
        this._metrics = handler;
        if (handler) {
            this._client.on("Performance.metrics", handler);
        }
    }
}
exports.Performance = Performance;
/** Security */
class Security {
    constructor(client) {
        this._certificateError = null;
        this._securityStateChanged = null;
        this._client = client;
    }
    /** Disables tracking security state changes. */
    disable() {
        return this._client.send("Security.disable");
    }
    /** Enables tracking security state changes. */
    enable() {
        return this._client.send("Security.enable");
    }
    /** Enable/disable whether all certificate errors should be ignored. */
    setIgnoreCertificateErrors(params) {
        return this._client.send("Security.setIgnoreCertificateErrors", params);
    }
    /** Handles a certificate error that fired a certificateError event. */
    handleCertificateError(params) {
        return this._client.send("Security.handleCertificateError", params);
    }
    /** Enable/disable overriding certificate errors. If enabled, all certificate error events need to
  be handled by the DevTools client and should be answered with `handleCertificateError` commands. */
    setOverrideCertificateErrors(params) {
        return this._client.send("Security.setOverrideCertificateErrors", params);
    }
    /** There is a certificate error. If overriding certificate errors is enabled, then it should be
  handled with the `handleCertificateError` command. Note: this event does not fire if the
  certificate error has been allowed internally. Only one client per target should override
  certificate errors at the same time. */
    get certificateError() {
        return this._certificateError;
    }
    set certificateError(handler) {
        if (this._certificateError) {
            this._client.removeListener("Security.certificateError", this._certificateError);
        }
        this._certificateError = handler;
        if (handler) {
            this._client.on("Security.certificateError", handler);
        }
    }
    /** The security state of the page changed. */
    get securityStateChanged() {
        return this._securityStateChanged;
    }
    set securityStateChanged(handler) {
        if (this._securityStateChanged) {
            this._client.removeListener("Security.securityStateChanged", this._securityStateChanged);
        }
        this._securityStateChanged = handler;
        if (handler) {
            this._client.on("Security.securityStateChanged", handler);
        }
    }
}
exports.Security = Security;
class ServiceWorker {
    constructor(client) {
        this._workerErrorReported = null;
        this._workerRegistrationUpdated = null;
        this._workerVersionUpdated = null;
        this._client = client;
    }
    deliverPushMessage(params) {
        return this._client.send("ServiceWorker.deliverPushMessage", params);
    }
    disable() {
        return this._client.send("ServiceWorker.disable");
    }
    dispatchSyncEvent(params) {
        return this._client.send("ServiceWorker.dispatchSyncEvent", params);
    }
    enable() {
        return this._client.send("ServiceWorker.enable");
    }
    inspectWorker(params) {
        return this._client.send("ServiceWorker.inspectWorker", params);
    }
    setForceUpdateOnPageLoad(params) {
        return this._client.send("ServiceWorker.setForceUpdateOnPageLoad", params);
    }
    skipWaiting(params) {
        return this._client.send("ServiceWorker.skipWaiting", params);
    }
    startWorker(params) {
        return this._client.send("ServiceWorker.startWorker", params);
    }
    stopAllWorkers() {
        return this._client.send("ServiceWorker.stopAllWorkers");
    }
    stopWorker(params) {
        return this._client.send("ServiceWorker.stopWorker", params);
    }
    unregister(params) {
        return this._client.send("ServiceWorker.unregister", params);
    }
    updateRegistration(params) {
        return this._client.send("ServiceWorker.updateRegistration", params);
    }
    get workerErrorReported() {
        return this._workerErrorReported;
    }
    set workerErrorReported(handler) {
        if (this._workerErrorReported) {
            this._client.removeListener("ServiceWorker.workerErrorReported", this._workerErrorReported);
        }
        this._workerErrorReported = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerErrorReported", handler);
        }
    }
    get workerRegistrationUpdated() {
        return this._workerRegistrationUpdated;
    }
    set workerRegistrationUpdated(handler) {
        if (this._workerRegistrationUpdated) {
            this._client.removeListener("ServiceWorker.workerRegistrationUpdated", this._workerRegistrationUpdated);
        }
        this._workerRegistrationUpdated = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerRegistrationUpdated", handler);
        }
    }
    get workerVersionUpdated() {
        return this._workerVersionUpdated;
    }
    set workerVersionUpdated(handler) {
        if (this._workerVersionUpdated) {
            this._client.removeListener("ServiceWorker.workerVersionUpdated", this._workerVersionUpdated);
        }
        this._workerVersionUpdated = handler;
        if (handler) {
            this._client.on("ServiceWorker.workerVersionUpdated", handler);
        }
    }
}
exports.ServiceWorker = ServiceWorker;
class Storage {
    constructor(client) {
        this._cacheStorageContentUpdated = null;
        this._cacheStorageListUpdated = null;
        this._indexedDBContentUpdated = null;
        this._indexedDBListUpdated = null;
        this._client = client;
    }
    /** Clears storage for origin. */
    clearDataForOrigin(params) {
        return this._client.send("Storage.clearDataForOrigin", params);
    }
    /** Returns usage and quota in bytes. */
    getUsageAndQuota(params) {
        return this._client.send("Storage.getUsageAndQuota", params);
    }
    /** Registers origin to be notified when an update occurs to its cache storage list. */
    trackCacheStorageForOrigin(params) {
        return this._client.send("Storage.trackCacheStorageForOrigin", params);
    }
    /** Registers origin to be notified when an update occurs to its IndexedDB. */
    trackIndexedDBForOrigin(params) {
        return this._client.send("Storage.trackIndexedDBForOrigin", params);
    }
    /** Unregisters origin from receiving notifications for cache storage. */
    untrackCacheStorageForOrigin(params) {
        return this._client.send("Storage.untrackCacheStorageForOrigin", params);
    }
    /** Unregisters origin from receiving notifications for IndexedDB. */
    untrackIndexedDBForOrigin(params) {
        return this._client.send("Storage.untrackIndexedDBForOrigin", params);
    }
    /** A cache's contents have been modified. */
    get cacheStorageContentUpdated() {
        return this._cacheStorageContentUpdated;
    }
    set cacheStorageContentUpdated(handler) {
        if (this._cacheStorageContentUpdated) {
            this._client.removeListener("Storage.cacheStorageContentUpdated", this._cacheStorageContentUpdated);
        }
        this._cacheStorageContentUpdated = handler;
        if (handler) {
            this._client.on("Storage.cacheStorageContentUpdated", handler);
        }
    }
    /** A cache has been added/deleted. */
    get cacheStorageListUpdated() {
        return this._cacheStorageListUpdated;
    }
    set cacheStorageListUpdated(handler) {
        if (this._cacheStorageListUpdated) {
            this._client.removeListener("Storage.cacheStorageListUpdated", this._cacheStorageListUpdated);
        }
        this._cacheStorageListUpdated = handler;
        if (handler) {
            this._client.on("Storage.cacheStorageListUpdated", handler);
        }
    }
    /** The origin's IndexedDB object store has been modified. */
    get indexedDBContentUpdated() {
        return this._indexedDBContentUpdated;
    }
    set indexedDBContentUpdated(handler) {
        if (this._indexedDBContentUpdated) {
            this._client.removeListener("Storage.indexedDBContentUpdated", this._indexedDBContentUpdated);
        }
        this._indexedDBContentUpdated = handler;
        if (handler) {
            this._client.on("Storage.indexedDBContentUpdated", handler);
        }
    }
    /** The origin's IndexedDB database list has been modified. */
    get indexedDBListUpdated() {
        return this._indexedDBListUpdated;
    }
    set indexedDBListUpdated(handler) {
        if (this._indexedDBListUpdated) {
            this._client.removeListener("Storage.indexedDBListUpdated", this._indexedDBListUpdated);
        }
        this._indexedDBListUpdated = handler;
        if (handler) {
            this._client.on("Storage.indexedDBListUpdated", handler);
        }
    }
}
exports.Storage = Storage;
/** The SystemInfo domain defines methods and events for querying low-level system information. */
class SystemInfo {
    constructor(client) {
        this._client = client;
    }
    /** Returns information about the system. */
    getInfo() {
        return this._client.send("SystemInfo.getInfo");
    }
}
exports.SystemInfo = SystemInfo;
/** Supports additional targets discovery and allows to attach to them. */
class Target {
    constructor(client) {
        this._attachedToTarget = null;
        this._detachedFromTarget = null;
        this._receivedMessageFromTarget = null;
        this._targetCreated = null;
        this._targetDestroyed = null;
        this._targetCrashed = null;
        this._targetInfoChanged = null;
        this._client = client;
    }
    /** Activates (focuses) the target. */
    activateTarget(params) {
        return this._client.send("Target.activateTarget", params);
    }
    /** Attaches to the target with given id. */
    attachToTarget(params) {
        return this._client.send("Target.attachToTarget", params);
    }
    /** Attaches to the browser target, only uses flat sessionId mode. */
    attachToBrowserTarget() {
        return this._client.send("Target.attachToBrowserTarget");
    }
    /** Closes the target. If the target is a page that gets closed too. */
    closeTarget(params) {
        return this._client.send("Target.closeTarget", params);
    }
    /** Inject object to the target's main frame that provides a communication
  channel with browser target.
  
  Injected object will be available as `window[bindingName]`.
  
  The object has the follwing API:
  - `binding.send(json)` - a method to send messages over the remote debugging protocol
  - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. */
    exposeDevToolsProtocol(params) {
        return this._client.send("Target.exposeDevToolsProtocol", params);
    }
    /** Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
  one. */
    createBrowserContext() {
        return this._client.send("Target.createBrowserContext");
    }
    /** Returns all browser contexts created with `Target.createBrowserContext` method. */
    getBrowserContexts() {
        return this._client.send("Target.getBrowserContexts");
    }
    /** Creates a new page. */
    createTarget(params) {
        return this._client.send("Target.createTarget", params);
    }
    /** Detaches session with given id. */
    detachFromTarget(params) {
        return this._client.send("Target.detachFromTarget", params);
    }
    /** Deletes a BrowserContext. All the belonging pages will be closed without calling their
  beforeunload hooks. */
    disposeBrowserContext(params) {
        return this._client.send("Target.disposeBrowserContext", params);
    }
    /** Returns information about a target. */
    getTargetInfo(params) {
        return this._client.send("Target.getTargetInfo", params);
    }
    /** Retrieves a list of available targets. */
    getTargets() {
        return this._client.send("Target.getTargets");
    }
    /** Sends protocol message over session with given id. */
    sendMessageToTarget(params) {
        return this._client.send("Target.sendMessageToTarget", params);
    }
    /** Controls whether to automatically attach to new targets which are considered to be related to
  this one. When turned on, attaches to all existing related targets as well. When turned off,
  automatically detaches from all currently attached targets. */
    setAutoAttach(params) {
        return this._client.send("Target.setAutoAttach", params);
    }
    /** Controls whether to discover available targets and notify via
  `targetCreated/targetInfoChanged/targetDestroyed` events. */
    setDiscoverTargets(params) {
        return this._client.send("Target.setDiscoverTargets", params);
    }
    /** Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
  `true`. */
    setRemoteLocations(params) {
        return this._client.send("Target.setRemoteLocations", params);
    }
    /** Issued when attached to target because of auto-attach or `attachToTarget` command. */
    get attachedToTarget() {
        return this._attachedToTarget;
    }
    set attachedToTarget(handler) {
        if (this._attachedToTarget) {
            this._client.removeListener("Target.attachedToTarget", this._attachedToTarget);
        }
        this._attachedToTarget = handler;
        if (handler) {
            this._client.on("Target.attachedToTarget", handler);
        }
    }
    /** Issued when detached from target for any reason (including `detachFromTarget` command). Can be
  issued multiple times per target if multiple sessions have been attached to it. */
    get detachedFromTarget() {
        return this._detachedFromTarget;
    }
    set detachedFromTarget(handler) {
        if (this._detachedFromTarget) {
            this._client.removeListener("Target.detachedFromTarget", this._detachedFromTarget);
        }
        this._detachedFromTarget = handler;
        if (handler) {
            this._client.on("Target.detachedFromTarget", handler);
        }
    }
    /** Notifies about a new protocol message received from the session (as reported in
  `attachedToTarget` event). */
    get receivedMessageFromTarget() {
        return this._receivedMessageFromTarget;
    }
    set receivedMessageFromTarget(handler) {
        if (this._receivedMessageFromTarget) {
            this._client.removeListener("Target.receivedMessageFromTarget", this._receivedMessageFromTarget);
        }
        this._receivedMessageFromTarget = handler;
        if (handler) {
            this._client.on("Target.receivedMessageFromTarget", handler);
        }
    }
    /** Issued when a possible inspection target is created. */
    get targetCreated() {
        return this._targetCreated;
    }
    set targetCreated(handler) {
        if (this._targetCreated) {
            this._client.removeListener("Target.targetCreated", this._targetCreated);
        }
        this._targetCreated = handler;
        if (handler) {
            this._client.on("Target.targetCreated", handler);
        }
    }
    /** Issued when a target is destroyed. */
    get targetDestroyed() {
        return this._targetDestroyed;
    }
    set targetDestroyed(handler) {
        if (this._targetDestroyed) {
            this._client.removeListener("Target.targetDestroyed", this._targetDestroyed);
        }
        this._targetDestroyed = handler;
        if (handler) {
            this._client.on("Target.targetDestroyed", handler);
        }
    }
    /** Issued when a target has crashed. */
    get targetCrashed() {
        return this._targetCrashed;
    }
    set targetCrashed(handler) {
        if (this._targetCrashed) {
            this._client.removeListener("Target.targetCrashed", this._targetCrashed);
        }
        this._targetCrashed = handler;
        if (handler) {
            this._client.on("Target.targetCrashed", handler);
        }
    }
    /** Issued when some information about a target has changed. This only happens between
  `targetCreated` and `targetDestroyed`. */
    get targetInfoChanged() {
        return this._targetInfoChanged;
    }
    set targetInfoChanged(handler) {
        if (this._targetInfoChanged) {
            this._client.removeListener("Target.targetInfoChanged", this._targetInfoChanged);
        }
        this._targetInfoChanged = handler;
        if (handler) {
            this._client.on("Target.targetInfoChanged", handler);
        }
    }
}
exports.Target = Target;
/** The Tethering domain defines methods and events for browser port binding. */
class Tethering {
    constructor(client) {
        this._accepted = null;
        this._client = client;
    }
    /** Request browser port binding. */
    bind(params) {
        return this._client.send("Tethering.bind", params);
    }
    /** Request browser port unbinding. */
    unbind(params) {
        return this._client.send("Tethering.unbind", params);
    }
    /** Informs that port was successfully bound and got a specified connection id. */
    get accepted() {
        return this._accepted;
    }
    set accepted(handler) {
        if (this._accepted) {
            this._client.removeListener("Tethering.accepted", this._accepted);
        }
        this._accepted = handler;
        if (handler) {
            this._client.on("Tethering.accepted", handler);
        }
    }
}
exports.Tethering = Tethering;
class Tracing {
    constructor(client) {
        this._bufferUsage = null;
        this._dataCollected = null;
        this._tracingComplete = null;
        this._client = client;
    }
    /** Stop trace events collection. */
    end() {
        return this._client.send("Tracing.end");
    }
    /** Gets supported tracing categories. */
    getCategories() {
        return this._client.send("Tracing.getCategories");
    }
    /** Record a clock sync marker in the trace. */
    recordClockSyncMarker(params) {
        return this._client.send("Tracing.recordClockSyncMarker", params);
    }
    /** Request a global memory dump. */
    requestMemoryDump() {
        return this._client.send("Tracing.requestMemoryDump");
    }
    /** Start trace events collection. */
    start(params) {
        return this._client.send("Tracing.start", params);
    }
    get bufferUsage() {
        return this._bufferUsage;
    }
    set bufferUsage(handler) {
        if (this._bufferUsage) {
            this._client.removeListener("Tracing.bufferUsage", this._bufferUsage);
        }
        this._bufferUsage = handler;
        if (handler) {
            this._client.on("Tracing.bufferUsage", handler);
        }
    }
    /** Contains an bucket of collected trace events. When tracing is stopped collected events will be
  send as a sequence of dataCollected events followed by tracingComplete event. */
    get dataCollected() {
        return this._dataCollected;
    }
    set dataCollected(handler) {
        if (this._dataCollected) {
            this._client.removeListener("Tracing.dataCollected", this._dataCollected);
        }
        this._dataCollected = handler;
        if (handler) {
            this._client.on("Tracing.dataCollected", handler);
        }
    }
    /** Signals that tracing is stopped and there is no trace buffers pending flush, all data were
  delivered via dataCollected events. */
    get tracingComplete() {
        return this._tracingComplete;
    }
    set tracingComplete(handler) {
        if (this._tracingComplete) {
            this._client.removeListener("Tracing.tracingComplete", this._tracingComplete);
        }
        this._tracingComplete = handler;
        if (handler) {
            this._client.on("Tracing.tracingComplete", handler);
        }
    }
}
exports.Tracing = Tracing;
/** Testing domain is a dumping ground for the capabilities requires for browser or app testing that do not fit other
domains. */
class Testing {
    constructor(client) {
        this._client = client;
    }
    /** Generates a report for testing. */
    generateTestReport(params) {
        return this._client.send("Testing.generateTestReport", params);
    }
}
exports.Testing = Testing;
/** This domain is deprecated - use Runtime or Log instead. */
class Console {
    constructor(client) {
        this._messageAdded = null;
        this._client = client;
    }
    /** Does nothing. */
    clearMessages() {
        return this._client.send("Console.clearMessages");
    }
    /** Disables console domain, prevents further console messages from being reported to the client. */
    disable() {
        return this._client.send("Console.disable");
    }
    /** Enables console domain, sends the messages collected so far to the client by means of the
  `messageAdded` notification. */
    enable() {
        return this._client.send("Console.enable");
    }
    /** Issued when new console message is added. */
    get messageAdded() {
        return this._messageAdded;
    }
    set messageAdded(handler) {
        if (this._messageAdded) {
            this._client.removeListener("Console.messageAdded", this._messageAdded);
        }
        this._messageAdded = handler;
        if (handler) {
            this._client.on("Console.messageAdded", handler);
        }
    }
}
exports.Console = Console;
/** Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
breakpoints, stepping through execution, exploring stack traces, etc. */
class Debugger {
    constructor(client) {
        this._breakpointResolved = null;
        this._paused = null;
        this._resumed = null;
        this._scriptFailedToParse = null;
        this._scriptParsed = null;
        this._client = client;
    }
    /** Continues execution until specific location is reached. */
    continueToLocation(params) {
        return this._client.send("Debugger.continueToLocation", params);
    }
    /** Disables debugger for given page. */
    disable() {
        return this._client.send("Debugger.disable");
    }
    /** Enables debugger for the given page. Clients should not assume that the debugging has been
  enabled until the result for this command is received. */
    enable() {
        return this._client.send("Debugger.enable");
    }
    /** Evaluates expression on a given call frame. */
    evaluateOnCallFrame(params) {
        return this._client.send("Debugger.evaluateOnCallFrame", params);
    }
    /** Returns possible locations for breakpoint. scriptId in start and end range locations should be
  the same. */
    getPossibleBreakpoints(params) {
        return this._client.send("Debugger.getPossibleBreakpoints", params);
    }
    /** Returns source for the script with given id. */
    getScriptSource(params) {
        return this._client.send("Debugger.getScriptSource", params);
    }
    /** Returns stack trace with given `stackTraceId`. */
    getStackTrace(params) {
        return this._client.send("Debugger.getStackTrace", params);
    }
    /** Stops on the next JavaScript statement. */
    pause() {
        return this._client.send("Debugger.pause");
    }
    pauseOnAsyncCall(params) {
        return this._client.send("Debugger.pauseOnAsyncCall", params);
    }
    /** Removes JavaScript breakpoint. */
    removeBreakpoint(params) {
        return this._client.send("Debugger.removeBreakpoint", params);
    }
    /** Restarts particular call frame from the beginning. */
    restartFrame(params) {
        return this._client.send("Debugger.restartFrame", params);
    }
    /** Resumes JavaScript execution. */
    resume() {
        return this._client.send("Debugger.resume");
    }
    /** This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and
  Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled
  before next pause. Returns success when async task is actually scheduled, returns error if no
  task were scheduled or another scheduleStepIntoAsync was called. */
    scheduleStepIntoAsync() {
        return this._client.send("Debugger.scheduleStepIntoAsync");
    }
    /** Searches for given string in script content. */
    searchInContent(params) {
        return this._client.send("Debugger.searchInContent", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Debugger.setAsyncCallStackDepth", params);
    }
    /** Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
  scripts with url matching one of the patterns. VM will try to leave blackboxed script by
  performing 'step in' several times, finally resorting to 'step out' if unsuccessful. */
    setBlackboxPatterns(params) {
        return this._client.send("Debugger.setBlackboxPatterns", params);
    }
    /** Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
  scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
  Positions array contains positions where blackbox state is changed. First interval isn't
  blackboxed. Array should be sorted. */
    setBlackboxedRanges(params) {
        return this._client.send("Debugger.setBlackboxedRanges", params);
    }
    /** Sets JavaScript breakpoint at a given location. */
    setBreakpoint(params) {
        return this._client.send("Debugger.setBreakpoint", params);
    }
    /** Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
  command is issued, all existing parsed scripts will have breakpoints resolved and returned in
  `locations` property. Further matching script parsing will result in subsequent
  `breakpointResolved` events issued. This logical breakpoint will survive page reloads. */
    setBreakpointByUrl(params) {
        return this._client.send("Debugger.setBreakpointByUrl", params);
    }
    /** Sets JavaScript breakpoint before each call to the given function.
  If another function was created from the same source as a given one,
  calling it will also trigger the breakpoint. */
    setBreakpointOnFunctionCall(params) {
        return this._client.send("Debugger.setBreakpointOnFunctionCall", params);
    }
    /** Activates / deactivates all breakpoints on the page. */
    setBreakpointsActive(params) {
        return this._client.send("Debugger.setBreakpointsActive", params);
    }
    /** Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
  no exceptions. Initial pause on exceptions state is `none`. */
    setPauseOnExceptions(params) {
        return this._client.send("Debugger.setPauseOnExceptions", params);
    }
    /** Changes return value in top frame. Available only at return break position. */
    setReturnValue(params) {
        return this._client.send("Debugger.setReturnValue", params);
    }
    /** Edits JavaScript source live. */
    setScriptSource(params) {
        return this._client.send("Debugger.setScriptSource", params);
    }
    /** Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). */
    setSkipAllPauses(params) {
        return this._client.send("Debugger.setSkipAllPauses", params);
    }
    /** Changes value of variable in a callframe. Object-based scopes are not supported and must be
  mutated manually. */
    setVariableValue(params) {
        return this._client.send("Debugger.setVariableValue", params);
    }
    /** Steps into the function call. */
    stepInto(params) {
        return this._client.send("Debugger.stepInto", params);
    }
    /** Steps out of the function call. */
    stepOut() {
        return this._client.send("Debugger.stepOut");
    }
    /** Steps over the statement. */
    stepOver() {
        return this._client.send("Debugger.stepOver");
    }
    /** Fired when breakpoint is resolved to an actual script and location. */
    get breakpointResolved() {
        return this._breakpointResolved;
    }
    set breakpointResolved(handler) {
        if (this._breakpointResolved) {
            this._client.removeListener("Debugger.breakpointResolved", this._breakpointResolved);
        }
        this._breakpointResolved = handler;
        if (handler) {
            this._client.on("Debugger.breakpointResolved", handler);
        }
    }
    /** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. */
    get paused() {
        return this._paused;
    }
    set paused(handler) {
        if (this._paused) {
            this._client.removeListener("Debugger.paused", this._paused);
        }
        this._paused = handler;
        if (handler) {
            this._client.on("Debugger.paused", handler);
        }
    }
    /** Fired when the virtual machine resumed execution. */
    get resumed() {
        return this._resumed;
    }
    set resumed(handler) {
        if (this._resumed) {
            this._client.removeListener("Debugger.resumed", this._resumed);
        }
        this._resumed = handler;
        if (handler) {
            this._client.on("Debugger.resumed", handler);
        }
    }
    /** Fired when virtual machine fails to parse the script. */
    get scriptFailedToParse() {
        return this._scriptFailedToParse;
    }
    set scriptFailedToParse(handler) {
        if (this._scriptFailedToParse) {
            this._client.removeListener("Debugger.scriptFailedToParse", this._scriptFailedToParse);
        }
        this._scriptFailedToParse = handler;
        if (handler) {
            this._client.on("Debugger.scriptFailedToParse", handler);
        }
    }
    /** Fired when virtual machine parses script. This event is also fired for all known and uncollected
  scripts upon enabling debugger. */
    get scriptParsed() {
        return this._scriptParsed;
    }
    set scriptParsed(handler) {
        if (this._scriptParsed) {
            this._client.removeListener("Debugger.scriptParsed", this._scriptParsed);
        }
        this._scriptParsed = handler;
        if (handler) {
            this._client.on("Debugger.scriptParsed", handler);
        }
    }
}
exports.Debugger = Debugger;
class HeapProfiler {
    constructor(client) {
        this._addHeapSnapshotChunk = null;
        this._heapStatsUpdate = null;
        this._lastSeenObjectId = null;
        this._reportHeapSnapshotProgress = null;
        this._resetProfiles = null;
        this._client = client;
    }
    /** Enables console to refer to the node with given id via $x (see Command Line API for more details
  $x functions). */
    addInspectedHeapObject(params) {
        return this._client.send("HeapProfiler.addInspectedHeapObject", params);
    }
    collectGarbage() {
        return this._client.send("HeapProfiler.collectGarbage");
    }
    disable() {
        return this._client.send("HeapProfiler.disable");
    }
    enable() {
        return this._client.send("HeapProfiler.enable");
    }
    getHeapObjectId(params) {
        return this._client.send("HeapProfiler.getHeapObjectId", params);
    }
    getObjectByHeapObjectId(params) {
        return this._client.send("HeapProfiler.getObjectByHeapObjectId", params);
    }
    getSamplingProfile() {
        return this._client.send("HeapProfiler.getSamplingProfile");
    }
    startSampling(params) {
        return this._client.send("HeapProfiler.startSampling", params);
    }
    startTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.startTrackingHeapObjects", params);
    }
    stopSampling() {
        return this._client.send("HeapProfiler.stopSampling");
    }
    stopTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.stopTrackingHeapObjects", params);
    }
    takeHeapSnapshot(params) {
        return this._client.send("HeapProfiler.takeHeapSnapshot", params);
    }
    get addHeapSnapshotChunk() {
        return this._addHeapSnapshotChunk;
    }
    set addHeapSnapshotChunk(handler) {
        if (this._addHeapSnapshotChunk) {
            this._client.removeListener("HeapProfiler.addHeapSnapshotChunk", this._addHeapSnapshotChunk);
        }
        this._addHeapSnapshotChunk = handler;
        if (handler) {
            this._client.on("HeapProfiler.addHeapSnapshotChunk", handler);
        }
    }
    /** If heap objects tracking has been started then backend may send update for one or more fragments */
    get heapStatsUpdate() {
        return this._heapStatsUpdate;
    }
    set heapStatsUpdate(handler) {
        if (this._heapStatsUpdate) {
            this._client.removeListener("HeapProfiler.heapStatsUpdate", this._heapStatsUpdate);
        }
        this._heapStatsUpdate = handler;
        if (handler) {
            this._client.on("HeapProfiler.heapStatsUpdate", handler);
        }
    }
    /** If heap objects tracking has been started then backend regularly sends a current value for last
  seen object id and corresponding timestamp. If the were changes in the heap since last event
  then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. */
    get lastSeenObjectId() {
        return this._lastSeenObjectId;
    }
    set lastSeenObjectId(handler) {
        if (this._lastSeenObjectId) {
            this._client.removeListener("HeapProfiler.lastSeenObjectId", this._lastSeenObjectId);
        }
        this._lastSeenObjectId = handler;
        if (handler) {
            this._client.on("HeapProfiler.lastSeenObjectId", handler);
        }
    }
    get reportHeapSnapshotProgress() {
        return this._reportHeapSnapshotProgress;
    }
    set reportHeapSnapshotProgress(handler) {
        if (this._reportHeapSnapshotProgress) {
            this._client.removeListener("HeapProfiler.reportHeapSnapshotProgress", this._reportHeapSnapshotProgress);
        }
        this._reportHeapSnapshotProgress = handler;
        if (handler) {
            this._client.on("HeapProfiler.reportHeapSnapshotProgress", handler);
        }
    }
    get resetProfiles() {
        return this._resetProfiles;
    }
    set resetProfiles(handler) {
        if (this._resetProfiles) {
            this._client.removeListener("HeapProfiler.resetProfiles", this._resetProfiles);
        }
        this._resetProfiles = handler;
        if (handler) {
            this._client.on("HeapProfiler.resetProfiles", handler);
        }
    }
}
exports.HeapProfiler = HeapProfiler;
class Profiler {
    constructor(client) {
        this._consoleProfileFinished = null;
        this._consoleProfileStarted = null;
        this._client = client;
    }
    disable() {
        return this._client.send("Profiler.disable");
    }
    enable() {
        return this._client.send("Profiler.enable");
    }
    /** Collect coverage data for the current isolate. The coverage data may be incomplete due to
  garbage collection. */
    getBestEffortCoverage() {
        return this._client.send("Profiler.getBestEffortCoverage");
    }
    /** Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. */
    setSamplingInterval(params) {
        return this._client.send("Profiler.setSamplingInterval", params);
    }
    start() {
        return this._client.send("Profiler.start");
    }
    /** Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
  coverage may be incomplete. Enabling prevents running optimized code and resets execution
  counters. */
    startPreciseCoverage(params) {
        return this._client.send("Profiler.startPreciseCoverage", params);
    }
    /** Enable type profile. */
    startTypeProfile() {
        return this._client.send("Profiler.startTypeProfile");
    }
    stop() {
        return this._client.send("Profiler.stop");
    }
    /** Disable precise code coverage. Disabling releases unnecessary execution count records and allows
  executing optimized code. */
    stopPreciseCoverage() {
        return this._client.send("Profiler.stopPreciseCoverage");
    }
    /** Disable type profile. Disabling releases type profile data collected so far. */
    stopTypeProfile() {
        return this._client.send("Profiler.stopTypeProfile");
    }
    /** Collect coverage data for the current isolate, and resets execution counters. Precise code
  coverage needs to have started. */
    takePreciseCoverage() {
        return this._client.send("Profiler.takePreciseCoverage");
    }
    /** Collect type profile. */
    takeTypeProfile() {
        return this._client.send("Profiler.takeTypeProfile");
    }
    get consoleProfileFinished() {
        return this._consoleProfileFinished;
    }
    set consoleProfileFinished(handler) {
        if (this._consoleProfileFinished) {
            this._client.removeListener("Profiler.consoleProfileFinished", this._consoleProfileFinished);
        }
        this._consoleProfileFinished = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileFinished", handler);
        }
    }
    /** Sent when new profile recording is started using console.profile() call. */
    get consoleProfileStarted() {
        return this._consoleProfileStarted;
    }
    set consoleProfileStarted(handler) {
        if (this._consoleProfileStarted) {
            this._client.removeListener("Profiler.consoleProfileStarted", this._consoleProfileStarted);
        }
        this._consoleProfileStarted = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileStarted", handler);
        }
    }
}
exports.Profiler = Profiler;
/** Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
Evaluation results are returned as mirror object that expose object type, string representation
and unique identifier that can be used for further object reference. Original objects are
maintained in memory unless they are either explicitly released or are released along with the
other objects in their object group. */
class Runtime {
    constructor(client) {
        this._bindingCalled = null;
        this._consoleAPICalled = null;
        this._exceptionRevoked = null;
        this._exceptionThrown = null;
        this._executionContextCreated = null;
        this._executionContextDestroyed = null;
        this._executionContextsCleared = null;
        this._inspectRequested = null;
        this._client = client;
    }
    /** Add handler to promise with given promise object id. */
    awaitPromise(params) {
        return this._client.send("Runtime.awaitPromise", params);
    }
    /** Calls function with given declaration on the given object. Object group of the result is
  inherited from the target object. */
    callFunctionOn(params) {
        return this._client.send("Runtime.callFunctionOn", params);
    }
    /** Compiles expression. */
    compileScript(params) {
        return this._client.send("Runtime.compileScript", params);
    }
    /** Disables reporting of execution contexts creation. */
    disable() {
        return this._client.send("Runtime.disable");
    }
    /** Discards collected exceptions and console API calls. */
    discardConsoleEntries() {
        return this._client.send("Runtime.discardConsoleEntries");
    }
    /** Enables reporting of execution contexts creation by means of `executionContextCreated` event.
  When the reporting gets enabled the event will be sent immediately for each existing execution
  context. */
    enable() {
        return this._client.send("Runtime.enable");
    }
    /** Evaluates expression on global object. */
    evaluate(params) {
        return this._client.send("Runtime.evaluate", params);
    }
    /** Returns the isolate id. */
    getIsolateId() {
        return this._client.send("Runtime.getIsolateId");
    }
    /** Returns the JavaScript heap usage.
  It is the total usage of the corresponding isolate not scoped to a particular Runtime. */
    getHeapUsage() {
        return this._client.send("Runtime.getHeapUsage");
    }
    /** Returns properties of a given object. Object group of the result is inherited from the target
  object. */
    getProperties(params) {
        return this._client.send("Runtime.getProperties", params);
    }
    /** Returns all let, const and class variables from global scope. */
    globalLexicalScopeNames(params) {
        return this._client.send("Runtime.globalLexicalScopeNames", params);
    }
    queryObjects(params) {
        return this._client.send("Runtime.queryObjects", params);
    }
    /** Releases remote object with given id. */
    releaseObject(params) {
        return this._client.send("Runtime.releaseObject", params);
    }
    /** Releases all remote objects that belong to a given group. */
    releaseObjectGroup(params) {
        return this._client.send("Runtime.releaseObjectGroup", params);
    }
    /** Tells inspected instance to run if it was waiting for debugger to attach. */
    runIfWaitingForDebugger() {
        return this._client.send("Runtime.runIfWaitingForDebugger");
    }
    /** Runs script with given id in a given context. */
    runScript(params) {
        return this._client.send("Runtime.runScript", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Runtime.setAsyncCallStackDepth", params);
    }
    setCustomObjectFormatterEnabled(params) {
        return this._client.send("Runtime.setCustomObjectFormatterEnabled", params);
    }
    setMaxCallStackSizeToCapture(params) {
        return this._client.send("Runtime.setMaxCallStackSizeToCapture", params);
    }
    /** Terminate current or next JavaScript execution.
  Will cancel the termination when the outer-most script execution ends. */
    terminateExecution() {
        return this._client.send("Runtime.terminateExecution");
    }
    /** If executionContextId is empty, adds binding with the given name on the
  global objects of all inspected contexts, including those created later,
  bindings survive reloads.
  If executionContextId is specified, adds binding only on global object of
  given execution context.
  Binding function takes exactly one argument, this argument should be string,
  in case of any other input, function throws an exception.
  Each binding function call produces Runtime.bindingCalled notification. */
    addBinding(params) {
        return this._client.send("Runtime.addBinding", params);
    }
    /** This method does not remove binding function from global object but
  unsubscribes current runtime agent from Runtime.bindingCalled notifications. */
    removeBinding(params) {
        return this._client.send("Runtime.removeBinding", params);
    }
    /** Notification is issued every time when binding is called. */
    get bindingCalled() {
        return this._bindingCalled;
    }
    set bindingCalled(handler) {
        if (this._bindingCalled) {
            this._client.removeListener("Runtime.bindingCalled", this._bindingCalled);
        }
        this._bindingCalled = handler;
        if (handler) {
            this._client.on("Runtime.bindingCalled", handler);
        }
    }
    /** Issued when console API was called. */
    get consoleAPICalled() {
        return this._consoleAPICalled;
    }
    set consoleAPICalled(handler) {
        if (this._consoleAPICalled) {
            this._client.removeListener("Runtime.consoleAPICalled", this._consoleAPICalled);
        }
        this._consoleAPICalled = handler;
        if (handler) {
            this._client.on("Runtime.consoleAPICalled", handler);
        }
    }
    /** Issued when unhandled exception was revoked. */
    get exceptionRevoked() {
        return this._exceptionRevoked;
    }
    set exceptionRevoked(handler) {
        if (this._exceptionRevoked) {
            this._client.removeListener("Runtime.exceptionRevoked", this._exceptionRevoked);
        }
        this._exceptionRevoked = handler;
        if (handler) {
            this._client.on("Runtime.exceptionRevoked", handler);
        }
    }
    /** Issued when exception was thrown and unhandled. */
    get exceptionThrown() {
        return this._exceptionThrown;
    }
    set exceptionThrown(handler) {
        if (this._exceptionThrown) {
            this._client.removeListener("Runtime.exceptionThrown", this._exceptionThrown);
        }
        this._exceptionThrown = handler;
        if (handler) {
            this._client.on("Runtime.exceptionThrown", handler);
        }
    }
    /** Issued when new execution context is created. */
    get executionContextCreated() {
        return this._executionContextCreated;
    }
    set executionContextCreated(handler) {
        if (this._executionContextCreated) {
            this._client.removeListener("Runtime.executionContextCreated", this._executionContextCreated);
        }
        this._executionContextCreated = handler;
        if (handler) {
            this._client.on("Runtime.executionContextCreated", handler);
        }
    }
    /** Issued when execution context is destroyed. */
    get executionContextDestroyed() {
        return this._executionContextDestroyed;
    }
    set executionContextDestroyed(handler) {
        if (this._executionContextDestroyed) {
            this._client.removeListener("Runtime.executionContextDestroyed", this._executionContextDestroyed);
        }
        this._executionContextDestroyed = handler;
        if (handler) {
            this._client.on("Runtime.executionContextDestroyed", handler);
        }
    }
    /** Issued when all executionContexts were cleared in browser */
    get executionContextsCleared() {
        return this._executionContextsCleared;
    }
    set executionContextsCleared(handler) {
        if (this._executionContextsCleared) {
            this._client.removeListener("Runtime.executionContextsCleared", this._executionContextsCleared);
        }
        this._executionContextsCleared = handler;
        if (handler) {
            this._client.on("Runtime.executionContextsCleared", handler);
        }
    }
    /** Issued when object should be inspected (for example, as a result of inspect() command line API
  call). */
    get inspectRequested() {
        return this._inspectRequested;
    }
    set inspectRequested(handler) {
        if (this._inspectRequested) {
            this._client.removeListener("Runtime.inspectRequested", this._inspectRequested);
        }
        this._inspectRequested = handler;
        if (handler) {
            this._client.on("Runtime.inspectRequested", handler);
        }
    }
}
exports.Runtime = Runtime;
/** This domain is deprecated. */
class Schema {
    constructor(client) {
        this._client = client;
    }
    /** Returns supported domains. */
    getDomains() {
        return this._client.send("Schema.getDomains");
    }
}
exports.Schema = Schema;
//# sourceMappingURL=tot.js.map