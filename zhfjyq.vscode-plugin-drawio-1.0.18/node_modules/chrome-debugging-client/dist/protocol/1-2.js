"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Actions and events related to the inspected page belong to the page domain. */
class Page {
    constructor(client) {
        this._domContentEventFired = null;
        this._loadEventFired = null;
        this._frameAttached = null;
        this._frameNavigated = null;
        this._frameDetached = null;
        this._javascriptDialogOpening = null;
        this._javascriptDialogClosed = null;
        this._interstitialShown = null;
        this._interstitialHidden = null;
        this._navigationRequested = null;
        this._client = client;
    }
    /** Enables page domain notifications. */
    enable() {
        return this._client.send("Page.enable");
    }
    /** Disables page domain notifications. */
    disable() {
        return this._client.send("Page.disable");
    }
    /** Reloads given page optionally ignoring the cache. */
    reload(params) {
        return this._client.send("Page.reload", params);
    }
    /** Navigates current page to the given URL. */
    navigate(params) {
        return this._client.send("Page.navigate", params);
    }
    /** Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable. */
    setGeolocationOverride(params) {
        return this._client.send("Page.setGeolocationOverride", params);
    }
    /** Clears the overriden Geolocation Position and Error. */
    clearGeolocationOverride() {
        return this._client.send("Page.clearGeolocationOverride");
    }
    /** Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). */
    handleJavaScriptDialog(params) {
        return this._client.send("Page.handleJavaScriptDialog", params);
    }
    get domContentEventFired() {
        return this._domContentEventFired;
    }
    set domContentEventFired(handler) {
        if (this._domContentEventFired) {
            this._client.removeListener("Page.domContentEventFired", this._domContentEventFired);
        }
        this._domContentEventFired = handler;
        if (handler) {
            this._client.on("Page.domContentEventFired", handler);
        }
    }
    get loadEventFired() {
        return this._loadEventFired;
    }
    set loadEventFired(handler) {
        if (this._loadEventFired) {
            this._client.removeListener("Page.loadEventFired", this._loadEventFired);
        }
        this._loadEventFired = handler;
        if (handler) {
            this._client.on("Page.loadEventFired", handler);
        }
    }
    /** Fired when frame has been attached to its parent. */
    get frameAttached() {
        return this._frameAttached;
    }
    set frameAttached(handler) {
        if (this._frameAttached) {
            this._client.removeListener("Page.frameAttached", this._frameAttached);
        }
        this._frameAttached = handler;
        if (handler) {
            this._client.on("Page.frameAttached", handler);
        }
    }
    /** Fired once navigation of the frame has completed. Frame is now associated with the new loader. */
    get frameNavigated() {
        return this._frameNavigated;
    }
    set frameNavigated(handler) {
        if (this._frameNavigated) {
            this._client.removeListener("Page.frameNavigated", this._frameNavigated);
        }
        this._frameNavigated = handler;
        if (handler) {
            this._client.on("Page.frameNavigated", handler);
        }
    }
    /** Fired when frame has been detached from its parent. */
    get frameDetached() {
        return this._frameDetached;
    }
    set frameDetached(handler) {
        if (this._frameDetached) {
            this._client.removeListener("Page.frameDetached", this._frameDetached);
        }
        this._frameDetached = handler;
        if (handler) {
            this._client.on("Page.frameDetached", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open. */
    get javascriptDialogOpening() {
        return this._javascriptDialogOpening;
    }
    set javascriptDialogOpening(handler) {
        if (this._javascriptDialogOpening) {
            this._client.removeListener("Page.javascriptDialogOpening", this._javascriptDialogOpening);
        }
        this._javascriptDialogOpening = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogOpening", handler);
        }
    }
    /** Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed. */
    get javascriptDialogClosed() {
        return this._javascriptDialogClosed;
    }
    set javascriptDialogClosed(handler) {
        if (this._javascriptDialogClosed) {
            this._client.removeListener("Page.javascriptDialogClosed", this._javascriptDialogClosed);
        }
        this._javascriptDialogClosed = handler;
        if (handler) {
            this._client.on("Page.javascriptDialogClosed", handler);
        }
    }
    /** Fired when interstitial page was shown */
    get interstitialShown() {
        return this._interstitialShown;
    }
    set interstitialShown(handler) {
        if (this._interstitialShown) {
            this._client.removeListener("Page.interstitialShown", this._interstitialShown);
        }
        this._interstitialShown = handler;
        if (handler) {
            this._client.on("Page.interstitialShown", handler);
        }
    }
    /** Fired when interstitial page was hidden */
    get interstitialHidden() {
        return this._interstitialHidden;
    }
    set interstitialHidden(handler) {
        if (this._interstitialHidden) {
            this._client.removeListener("Page.interstitialHidden", this._interstitialHidden);
        }
        this._interstitialHidden = handler;
        if (handler) {
            this._client.on("Page.interstitialHidden", handler);
        }
    }
    /** Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called. */
    get navigationRequested() {
        return this._navigationRequested;
    }
    set navigationRequested(handler) {
        if (this._navigationRequested) {
            this._client.removeListener("Page.navigationRequested", this._navigationRequested);
        }
        this._navigationRequested = handler;
        if (handler) {
            this._client.on("Page.navigationRequested", handler);
        }
    }
}
exports.Page = Page;
/** This domain emulates different environments for the page. */
class Emulation {
    constructor(client) {
        this._client = client;
    }
    /** Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results). */
    setDeviceMetricsOverride(params) {
        return this._client.send("Emulation.setDeviceMetricsOverride", params);
    }
    /** Clears the overriden device metrics. */
    clearDeviceMetricsOverride() {
        return this._client.send("Emulation.clearDeviceMetricsOverride");
    }
    /** Toggles mouse event-based touch event emulation. */
    setTouchEmulationEnabled(params) {
        return this._client.send("Emulation.setTouchEmulationEnabled", params);
    }
    /** Emulates the given media for CSS media queries. */
    setEmulatedMedia(params) {
        return this._client.send("Emulation.setEmulatedMedia", params);
    }
}
exports.Emulation = Emulation;
/** Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc. */
class Network {
    constructor(client) {
        this._requestWillBeSent = null;
        this._requestServedFromCache = null;
        this._responseReceived = null;
        this._dataReceived = null;
        this._loadingFinished = null;
        this._loadingFailed = null;
        this._client = client;
    }
    /** Enables network tracking, network events will now be delivered to the client. */
    enable(params) {
        return this._client.send("Network.enable", params);
    }
    /** Disables network tracking, prevents network events from being sent to the client. */
    disable() {
        return this._client.send("Network.disable");
    }
    /** Allows overriding user agent with the given string. */
    setUserAgentOverride(params) {
        return this._client.send("Network.setUserAgentOverride", params);
    }
    /** Specifies whether to always send extra HTTP headers with the requests from this page. */
    setExtraHTTPHeaders(params) {
        return this._client.send("Network.setExtraHTTPHeaders", params);
    }
    /** Returns content served for the given request. */
    getResponseBody(params) {
        return this._client.send("Network.getResponseBody", params);
    }
    /** Tells whether clearing browser cache is supported. */
    canClearBrowserCache() {
        return this._client.send("Network.canClearBrowserCache");
    }
    /** Clears browser cache. */
    clearBrowserCache() {
        return this._client.send("Network.clearBrowserCache");
    }
    /** Tells whether clearing browser cookies is supported. */
    canClearBrowserCookies() {
        return this._client.send("Network.canClearBrowserCookies");
    }
    /** Clears browser cookies. */
    clearBrowserCookies() {
        return this._client.send("Network.clearBrowserCookies");
    }
    /** Activates emulation of network conditions. */
    emulateNetworkConditions(params) {
        return this._client.send("Network.emulateNetworkConditions", params);
    }
    /** Toggles ignoring cache for each request. If <code>true</code>, cache will not be used. */
    setCacheDisabled(params) {
        return this._client.send("Network.setCacheDisabled", params);
    }
    /** Fired when page is about to send HTTP request. */
    get requestWillBeSent() {
        return this._requestWillBeSent;
    }
    set requestWillBeSent(handler) {
        if (this._requestWillBeSent) {
            this._client.removeListener("Network.requestWillBeSent", this._requestWillBeSent);
        }
        this._requestWillBeSent = handler;
        if (handler) {
            this._client.on("Network.requestWillBeSent", handler);
        }
    }
    /** Fired if request ended up loading from cache. */
    get requestServedFromCache() {
        return this._requestServedFromCache;
    }
    set requestServedFromCache(handler) {
        if (this._requestServedFromCache) {
            this._client.removeListener("Network.requestServedFromCache", this._requestServedFromCache);
        }
        this._requestServedFromCache = handler;
        if (handler) {
            this._client.on("Network.requestServedFromCache", handler);
        }
    }
    /** Fired when HTTP response is available. */
    get responseReceived() {
        return this._responseReceived;
    }
    set responseReceived(handler) {
        if (this._responseReceived) {
            this._client.removeListener("Network.responseReceived", this._responseReceived);
        }
        this._responseReceived = handler;
        if (handler) {
            this._client.on("Network.responseReceived", handler);
        }
    }
    /** Fired when data chunk was received over the network. */
    get dataReceived() {
        return this._dataReceived;
    }
    set dataReceived(handler) {
        if (this._dataReceived) {
            this._client.removeListener("Network.dataReceived", this._dataReceived);
        }
        this._dataReceived = handler;
        if (handler) {
            this._client.on("Network.dataReceived", handler);
        }
    }
    /** Fired when HTTP request has finished loading. */
    get loadingFinished() {
        return this._loadingFinished;
    }
    set loadingFinished(handler) {
        if (this._loadingFinished) {
            this._client.removeListener("Network.loadingFinished", this._loadingFinished);
        }
        this._loadingFinished = handler;
        if (handler) {
            this._client.on("Network.loadingFinished", handler);
        }
    }
    /** Fired when HTTP request has failed to load. */
    get loadingFailed() {
        return this._loadingFailed;
    }
    set loadingFailed(handler) {
        if (this._loadingFailed) {
            this._client.removeListener("Network.loadingFailed", this._loadingFailed);
        }
        this._loadingFailed = handler;
        if (handler) {
            this._client.on("Network.loadingFailed", handler);
        }
    }
}
exports.Network = Network;
/** This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p> */
class DOM {
    constructor(client) {
        this._documentUpdated = null;
        this._setChildNodes = null;
        this._attributeModified = null;
        this._attributeRemoved = null;
        this._characterDataModified = null;
        this._childNodeCountUpdated = null;
        this._childNodeInserted = null;
        this._childNodeRemoved = null;
        this._client = client;
    }
    /** Enables DOM agent for the given page. */
    enable() {
        return this._client.send("DOM.enable");
    }
    /** Disables DOM agent for the given page. */
    disable() {
        return this._client.send("DOM.disable");
    }
    /** Returns the root DOM node to the caller. */
    getDocument() {
        return this._client.send("DOM.getDocument");
    }
    /** Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth. */
    requestChildNodes(params) {
        return this._client.send("DOM.requestChildNodes", params);
    }
    /** Executes <code>querySelector</code> on a given node. */
    querySelector(params) {
        return this._client.send("DOM.querySelector", params);
    }
    /** Executes <code>querySelectorAll</code> on a given node. */
    querySelectorAll(params) {
        return this._client.send("DOM.querySelectorAll", params);
    }
    /** Sets node name for a node with given id. */
    setNodeName(params) {
        return this._client.send("DOM.setNodeName", params);
    }
    /** Sets node value for a node with given id. */
    setNodeValue(params) {
        return this._client.send("DOM.setNodeValue", params);
    }
    /** Removes node with given id. */
    removeNode(params) {
        return this._client.send("DOM.removeNode", params);
    }
    /** Sets attribute for an element with given id. */
    setAttributeValue(params) {
        return this._client.send("DOM.setAttributeValue", params);
    }
    /** Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs. */
    setAttributesAsText(params) {
        return this._client.send("DOM.setAttributesAsText", params);
    }
    /** Removes attribute with given name from an element with given id. */
    removeAttribute(params) {
        return this._client.send("DOM.removeAttribute", params);
    }
    /** Returns node's HTML markup. */
    getOuterHTML(params) {
        return this._client.send("DOM.getOuterHTML", params);
    }
    /** Sets node HTML markup, returns new node id. */
    setOuterHTML(params) {
        return this._client.send("DOM.setOuterHTML", params);
    }
    /** Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications. */
    requestNode(params) {
        return this._client.send("DOM.requestNode", params);
    }
    /** Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. */
    highlightRect(params) {
        return this._client.send("DOM.highlightRect", params);
    }
    /** Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified. */
    highlightNode(params) {
        return this._client.send("DOM.highlightNode", params);
    }
    /** Hides DOM node highlight. */
    hideHighlight() {
        return this._client.send("DOM.hideHighlight");
    }
    /** Resolves JavaScript node object for given node id. */
    resolveNode(params) {
        return this._client.send("DOM.resolveNode", params);
    }
    /** Returns attributes for the specified node. */
    getAttributes(params) {
        return this._client.send("DOM.getAttributes", params);
    }
    /** Moves node into the new container, places it before the given anchor. */
    moveTo(params) {
        return this._client.send("DOM.moveTo", params);
    }
    /** Fired when <code>Document</code> has been totally updated. Node ids are no longer valid. */
    get documentUpdated() {
        return this._documentUpdated;
    }
    set documentUpdated(handler) {
        if (this._documentUpdated) {
            this._client.removeListener("DOM.documentUpdated", this._documentUpdated);
        }
        this._documentUpdated = handler;
        if (handler) {
            this._client.on("DOM.documentUpdated", handler);
        }
    }
    /** Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids. */
    get setChildNodes() {
        return this._setChildNodes;
    }
    set setChildNodes(handler) {
        if (this._setChildNodes) {
            this._client.removeListener("DOM.setChildNodes", this._setChildNodes);
        }
        this._setChildNodes = handler;
        if (handler) {
            this._client.on("DOM.setChildNodes", handler);
        }
    }
    /** Fired when <code>Element</code>'s attribute is modified. */
    get attributeModified() {
        return this._attributeModified;
    }
    set attributeModified(handler) {
        if (this._attributeModified) {
            this._client.removeListener("DOM.attributeModified", this._attributeModified);
        }
        this._attributeModified = handler;
        if (handler) {
            this._client.on("DOM.attributeModified", handler);
        }
    }
    /** Fired when <code>Element</code>'s attribute is removed. */
    get attributeRemoved() {
        return this._attributeRemoved;
    }
    set attributeRemoved(handler) {
        if (this._attributeRemoved) {
            this._client.removeListener("DOM.attributeRemoved", this._attributeRemoved);
        }
        this._attributeRemoved = handler;
        if (handler) {
            this._client.on("DOM.attributeRemoved", handler);
        }
    }
    /** Mirrors <code>DOMCharacterDataModified</code> event. */
    get characterDataModified() {
        return this._characterDataModified;
    }
    set characterDataModified(handler) {
        if (this._characterDataModified) {
            this._client.removeListener("DOM.characterDataModified", this._characterDataModified);
        }
        this._characterDataModified = handler;
        if (handler) {
            this._client.on("DOM.characterDataModified", handler);
        }
    }
    /** Fired when <code>Container</code>'s child node count has changed. */
    get childNodeCountUpdated() {
        return this._childNodeCountUpdated;
    }
    set childNodeCountUpdated(handler) {
        if (this._childNodeCountUpdated) {
            this._client.removeListener("DOM.childNodeCountUpdated", this._childNodeCountUpdated);
        }
        this._childNodeCountUpdated = handler;
        if (handler) {
            this._client.on("DOM.childNodeCountUpdated", handler);
        }
    }
    /** Mirrors <code>DOMNodeInserted</code> event. */
    get childNodeInserted() {
        return this._childNodeInserted;
    }
    set childNodeInserted(handler) {
        if (this._childNodeInserted) {
            this._client.removeListener("DOM.childNodeInserted", this._childNodeInserted);
        }
        this._childNodeInserted = handler;
        if (handler) {
            this._client.on("DOM.childNodeInserted", handler);
        }
    }
    /** Mirrors <code>DOMNodeRemoved</code> event. */
    get childNodeRemoved() {
        return this._childNodeRemoved;
    }
    set childNodeRemoved(handler) {
        if (this._childNodeRemoved) {
            this._client.removeListener("DOM.childNodeRemoved", this._childNodeRemoved);
        }
        this._childNodeRemoved = handler;
        if (handler) {
            this._client.on("DOM.childNodeRemoved", handler);
        }
    }
}
exports.DOM = DOM;
/** DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set. */
class DOMDebugger {
    constructor(client) {
        this._client = client;
    }
    /** Sets breakpoint on particular operation with DOM. */
    setDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.setDOMBreakpoint", params);
    }
    /** Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>. */
    removeDOMBreakpoint(params) {
        return this._client.send("DOMDebugger.removeDOMBreakpoint", params);
    }
    /** Sets breakpoint on particular DOM event. */
    setEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.setEventListenerBreakpoint", params);
    }
    /** Removes breakpoint on particular DOM event. */
    removeEventListenerBreakpoint(params) {
        return this._client.send("DOMDebugger.removeEventListenerBreakpoint", params);
    }
    /** Sets breakpoint on XMLHttpRequest. */
    setXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.setXHRBreakpoint", params);
    }
    /** Removes breakpoint from XMLHttpRequest. */
    removeXHRBreakpoint(params) {
        return this._client.send("DOMDebugger.removeXHRBreakpoint", params);
    }
}
exports.DOMDebugger = DOMDebugger;
class Input {
    constructor(client) {
        this._client = client;
    }
    /** Dispatches a key event to the page. */
    dispatchKeyEvent(params) {
        return this._client.send("Input.dispatchKeyEvent", params);
    }
    /** Dispatches a mouse event to the page. */
    dispatchMouseEvent(params) {
        return this._client.send("Input.dispatchMouseEvent", params);
    }
}
exports.Input = Input;
/** Provides information about the protocol schema. */
class Schema {
    constructor(client) {
        this._client = client;
    }
    /** Returns supported domains. */
    getDomains() {
        return this._client.send("Schema.getDomains");
    }
}
exports.Schema = Schema;
/** Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group. */
class Runtime {
    constructor(client) {
        this._executionContextCreated = null;
        this._executionContextDestroyed = null;
        this._executionContextsCleared = null;
        this._exceptionThrown = null;
        this._exceptionRevoked = null;
        this._consoleAPICalled = null;
        this._inspectRequested = null;
        this._client = client;
    }
    /** Evaluates expression on global object. */
    evaluate(params) {
        return this._client.send("Runtime.evaluate", params);
    }
    /** Add handler to promise with given promise object id. */
    awaitPromise(params) {
        return this._client.send("Runtime.awaitPromise", params);
    }
    /** Calls function with given declaration on the given object. Object group of the result is inherited from the target object. */
    callFunctionOn(params) {
        return this._client.send("Runtime.callFunctionOn", params);
    }
    /** Returns properties of a given object. Object group of the result is inherited from the target object. */
    getProperties(params) {
        return this._client.send("Runtime.getProperties", params);
    }
    /** Releases remote object with given id. */
    releaseObject(params) {
        return this._client.send("Runtime.releaseObject", params);
    }
    /** Releases all remote objects that belong to a given group. */
    releaseObjectGroup(params) {
        return this._client.send("Runtime.releaseObjectGroup", params);
    }
    /** Tells inspected instance to run if it was waiting for debugger to attach. */
    runIfWaitingForDebugger() {
        return this._client.send("Runtime.runIfWaitingForDebugger");
    }
    /** Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context. */
    enable() {
        return this._client.send("Runtime.enable");
    }
    /** Disables reporting of execution contexts creation. */
    disable() {
        return this._client.send("Runtime.disable");
    }
    /** Discards collected exceptions and console API calls. */
    discardConsoleEntries() {
        return this._client.send("Runtime.discardConsoleEntries");
    }
    /** Compiles expression. */
    compileScript(params) {
        return this._client.send("Runtime.compileScript", params);
    }
    /** Runs script with given id in a given context. */
    runScript(params) {
        return this._client.send("Runtime.runScript", params);
    }
    /** Issued when new execution context is created. */
    get executionContextCreated() {
        return this._executionContextCreated;
    }
    set executionContextCreated(handler) {
        if (this._executionContextCreated) {
            this._client.removeListener("Runtime.executionContextCreated", this._executionContextCreated);
        }
        this._executionContextCreated = handler;
        if (handler) {
            this._client.on("Runtime.executionContextCreated", handler);
        }
    }
    /** Issued when execution context is destroyed. */
    get executionContextDestroyed() {
        return this._executionContextDestroyed;
    }
    set executionContextDestroyed(handler) {
        if (this._executionContextDestroyed) {
            this._client.removeListener("Runtime.executionContextDestroyed", this._executionContextDestroyed);
        }
        this._executionContextDestroyed = handler;
        if (handler) {
            this._client.on("Runtime.executionContextDestroyed", handler);
        }
    }
    /** Issued when all executionContexts were cleared in browser */
    get executionContextsCleared() {
        return this._executionContextsCleared;
    }
    set executionContextsCleared(handler) {
        if (this._executionContextsCleared) {
            this._client.removeListener("Runtime.executionContextsCleared", this._executionContextsCleared);
        }
        this._executionContextsCleared = handler;
        if (handler) {
            this._client.on("Runtime.executionContextsCleared", handler);
        }
    }
    /** Issued when exception was thrown and unhandled. */
    get exceptionThrown() {
        return this._exceptionThrown;
    }
    set exceptionThrown(handler) {
        if (this._exceptionThrown) {
            this._client.removeListener("Runtime.exceptionThrown", this._exceptionThrown);
        }
        this._exceptionThrown = handler;
        if (handler) {
            this._client.on("Runtime.exceptionThrown", handler);
        }
    }
    /** Issued when unhandled exception was revoked. */
    get exceptionRevoked() {
        return this._exceptionRevoked;
    }
    set exceptionRevoked(handler) {
        if (this._exceptionRevoked) {
            this._client.removeListener("Runtime.exceptionRevoked", this._exceptionRevoked);
        }
        this._exceptionRevoked = handler;
        if (handler) {
            this._client.on("Runtime.exceptionRevoked", handler);
        }
    }
    /** Issued when console API was called. */
    get consoleAPICalled() {
        return this._consoleAPICalled;
    }
    set consoleAPICalled(handler) {
        if (this._consoleAPICalled) {
            this._client.removeListener("Runtime.consoleAPICalled", this._consoleAPICalled);
        }
        this._consoleAPICalled = handler;
        if (handler) {
            this._client.on("Runtime.consoleAPICalled", handler);
        }
    }
    /** Issued when object should be inspected (for example, as a result of inspect() command line API call). */
    get inspectRequested() {
        return this._inspectRequested;
    }
    set inspectRequested(handler) {
        if (this._inspectRequested) {
            this._client.removeListener("Runtime.inspectRequested", this._inspectRequested);
        }
        this._inspectRequested = handler;
        if (handler) {
            this._client.on("Runtime.inspectRequested", handler);
        }
    }
}
exports.Runtime = Runtime;
/** Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc. */
class Debugger {
    constructor(client) {
        this._scriptParsed = null;
        this._scriptFailedToParse = null;
        this._breakpointResolved = null;
        this._paused = null;
        this._resumed = null;
        this._client = client;
    }
    /** Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received. */
    enable() {
        return this._client.send("Debugger.enable");
    }
    /** Disables debugger for given page. */
    disable() {
        return this._client.send("Debugger.disable");
    }
    /** Activates / deactivates all breakpoints on the page. */
    setBreakpointsActive(params) {
        return this._client.send("Debugger.setBreakpointsActive", params);
    }
    /** Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). */
    setSkipAllPauses(params) {
        return this._client.send("Debugger.setSkipAllPauses", params);
    }
    /** Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads. */
    setBreakpointByUrl(params) {
        return this._client.send("Debugger.setBreakpointByUrl", params);
    }
    /** Sets JavaScript breakpoint at a given location. */
    setBreakpoint(params) {
        return this._client.send("Debugger.setBreakpoint", params);
    }
    /** Removes JavaScript breakpoint. */
    removeBreakpoint(params) {
        return this._client.send("Debugger.removeBreakpoint", params);
    }
    /** Continues execution until specific location is reached. */
    continueToLocation(params) {
        return this._client.send("Debugger.continueToLocation", params);
    }
    /** Steps over the statement. */
    stepOver() {
        return this._client.send("Debugger.stepOver");
    }
    /** Steps into the function call. */
    stepInto() {
        return this._client.send("Debugger.stepInto");
    }
    /** Steps out of the function call. */
    stepOut() {
        return this._client.send("Debugger.stepOut");
    }
    /** Stops on the next JavaScript statement. */
    pause() {
        return this._client.send("Debugger.pause");
    }
    /** Resumes JavaScript execution. */
    resume() {
        return this._client.send("Debugger.resume");
    }
    /** Edits JavaScript source live. */
    setScriptSource(params) {
        return this._client.send("Debugger.setScriptSource", params);
    }
    /** Restarts particular call frame from the beginning. */
    restartFrame(params) {
        return this._client.send("Debugger.restartFrame", params);
    }
    /** Returns source for the script with given id. */
    getScriptSource(params) {
        return this._client.send("Debugger.getScriptSource", params);
    }
    /** Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>. */
    setPauseOnExceptions(params) {
        return this._client.send("Debugger.setPauseOnExceptions", params);
    }
    /** Evaluates expression on a given call frame. */
    evaluateOnCallFrame(params) {
        return this._client.send("Debugger.evaluateOnCallFrame", params);
    }
    /** Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually. */
    setVariableValue(params) {
        return this._client.send("Debugger.setVariableValue", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Debugger.setAsyncCallStackDepth", params);
    }
    /** Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. */
    get scriptParsed() {
        return this._scriptParsed;
    }
    set scriptParsed(handler) {
        if (this._scriptParsed) {
            this._client.removeListener("Debugger.scriptParsed", this._scriptParsed);
        }
        this._scriptParsed = handler;
        if (handler) {
            this._client.on("Debugger.scriptParsed", handler);
        }
    }
    /** Fired when virtual machine fails to parse the script. */
    get scriptFailedToParse() {
        return this._scriptFailedToParse;
    }
    set scriptFailedToParse(handler) {
        if (this._scriptFailedToParse) {
            this._client.removeListener("Debugger.scriptFailedToParse", this._scriptFailedToParse);
        }
        this._scriptFailedToParse = handler;
        if (handler) {
            this._client.on("Debugger.scriptFailedToParse", handler);
        }
    }
    /** Fired when breakpoint is resolved to an actual script and location. */
    get breakpointResolved() {
        return this._breakpointResolved;
    }
    set breakpointResolved(handler) {
        if (this._breakpointResolved) {
            this._client.removeListener("Debugger.breakpointResolved", this._breakpointResolved);
        }
        this._breakpointResolved = handler;
        if (handler) {
            this._client.on("Debugger.breakpointResolved", handler);
        }
    }
    /** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. */
    get paused() {
        return this._paused;
    }
    set paused(handler) {
        if (this._paused) {
            this._client.removeListener("Debugger.paused", this._paused);
        }
        this._paused = handler;
        if (handler) {
            this._client.on("Debugger.paused", handler);
        }
    }
    /** Fired when the virtual machine resumed execution. */
    get resumed() {
        return this._resumed;
    }
    set resumed(handler) {
        if (this._resumed) {
            this._client.removeListener("Debugger.resumed", this._resumed);
        }
        this._resumed = handler;
        if (handler) {
            this._client.on("Debugger.resumed", handler);
        }
    }
}
exports.Debugger = Debugger;
class Profiler {
    constructor(client) {
        this._consoleProfileStarted = null;
        this._consoleProfileFinished = null;
        this._client = client;
    }
    enable() {
        return this._client.send("Profiler.enable");
    }
    disable() {
        return this._client.send("Profiler.disable");
    }
    /** Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. */
    setSamplingInterval(params) {
        return this._client.send("Profiler.setSamplingInterval", params);
    }
    start() {
        return this._client.send("Profiler.start");
    }
    stop() {
        return this._client.send("Profiler.stop");
    }
    /** Sent when new profile recodring is started using console.profile() call. */
    get consoleProfileStarted() {
        return this._consoleProfileStarted;
    }
    set consoleProfileStarted(handler) {
        if (this._consoleProfileStarted) {
            this._client.removeListener("Profiler.consoleProfileStarted", this._consoleProfileStarted);
        }
        this._consoleProfileStarted = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileStarted", handler);
        }
    }
    get consoleProfileFinished() {
        return this._consoleProfileFinished;
    }
    set consoleProfileFinished(handler) {
        if (this._consoleProfileFinished) {
            this._client.removeListener("Profiler.consoleProfileFinished", this._consoleProfileFinished);
        }
        this._consoleProfileFinished = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileFinished", handler);
        }
    }
}
exports.Profiler = Profiler;
//# sourceMappingURL=1-2.js.map