"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** This domain is deprecated - use Runtime or Log instead. */
class Console {
    constructor(client) {
        this._messageAdded = null;
        this._client = client;
    }
    /** Does nothing. */
    clearMessages() {
        return this._client.send("Console.clearMessages");
    }
    /** Disables console domain, prevents further console messages from being reported to the client. */
    disable() {
        return this._client.send("Console.disable");
    }
    /** Enables console domain, sends the messages collected so far to the client by means of the
  `messageAdded` notification. */
    enable() {
        return this._client.send("Console.enable");
    }
    /** Issued when new console message is added. */
    get messageAdded() {
        return this._messageAdded;
    }
    set messageAdded(handler) {
        if (this._messageAdded) {
            this._client.removeListener("Console.messageAdded", this._messageAdded);
        }
        this._messageAdded = handler;
        if (handler) {
            this._client.on("Console.messageAdded", handler);
        }
    }
}
exports.Console = Console;
/** Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
breakpoints, stepping through execution, exploring stack traces, etc. */
class Debugger {
    constructor(client) {
        this._breakpointResolved = null;
        this._paused = null;
        this._resumed = null;
        this._scriptFailedToParse = null;
        this._scriptParsed = null;
        this._client = client;
    }
    /** Continues execution until specific location is reached. */
    continueToLocation(params) {
        return this._client.send("Debugger.continueToLocation", params);
    }
    /** Disables debugger for given page. */
    disable() {
        return this._client.send("Debugger.disable");
    }
    /** Enables debugger for the given page. Clients should not assume that the debugging has been
  enabled until the result for this command is received. */
    enable() {
        return this._client.send("Debugger.enable");
    }
    /** Evaluates expression on a given call frame. */
    evaluateOnCallFrame(params) {
        return this._client.send("Debugger.evaluateOnCallFrame", params);
    }
    /** Returns possible locations for breakpoint. scriptId in start and end range locations should be
  the same. */
    getPossibleBreakpoints(params) {
        return this._client.send("Debugger.getPossibleBreakpoints", params);
    }
    /** Returns source for the script with given id. */
    getScriptSource(params) {
        return this._client.send("Debugger.getScriptSource", params);
    }
    /** Returns stack trace with given `stackTraceId`. */
    getStackTrace(params) {
        return this._client.send("Debugger.getStackTrace", params);
    }
    /** Stops on the next JavaScript statement. */
    pause() {
        return this._client.send("Debugger.pause");
    }
    pauseOnAsyncCall(params) {
        return this._client.send("Debugger.pauseOnAsyncCall", params);
    }
    /** Removes JavaScript breakpoint. */
    removeBreakpoint(params) {
        return this._client.send("Debugger.removeBreakpoint", params);
    }
    /** Restarts particular call frame from the beginning. */
    restartFrame(params) {
        return this._client.send("Debugger.restartFrame", params);
    }
    /** Resumes JavaScript execution. */
    resume() {
        return this._client.send("Debugger.resume");
    }
    /** This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and
  Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled
  before next pause. Returns success when async task is actually scheduled, returns error if no
  task were scheduled or another scheduleStepIntoAsync was called. */
    scheduleStepIntoAsync() {
        return this._client.send("Debugger.scheduleStepIntoAsync");
    }
    /** Searches for given string in script content. */
    searchInContent(params) {
        return this._client.send("Debugger.searchInContent", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Debugger.setAsyncCallStackDepth", params);
    }
    /** Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
  scripts with url matching one of the patterns. VM will try to leave blackboxed script by
  performing 'step in' several times, finally resorting to 'step out' if unsuccessful. */
    setBlackboxPatterns(params) {
        return this._client.send("Debugger.setBlackboxPatterns", params);
    }
    /** Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
  scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
  Positions array contains positions where blackbox state is changed. First interval isn't
  blackboxed. Array should be sorted. */
    setBlackboxedRanges(params) {
        return this._client.send("Debugger.setBlackboxedRanges", params);
    }
    /** Sets JavaScript breakpoint at a given location. */
    setBreakpoint(params) {
        return this._client.send("Debugger.setBreakpoint", params);
    }
    /** Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
  command is issued, all existing parsed scripts will have breakpoints resolved and returned in
  `locations` property. Further matching script parsing will result in subsequent
  `breakpointResolved` events issued. This logical breakpoint will survive page reloads. */
    setBreakpointByUrl(params) {
        return this._client.send("Debugger.setBreakpointByUrl", params);
    }
    /** Sets JavaScript breakpoint before each call to the given function.
  If another function was created from the same source as a given one,
  calling it will also trigger the breakpoint. */
    setBreakpointOnFunctionCall(params) {
        return this._client.send("Debugger.setBreakpointOnFunctionCall", params);
    }
    /** Activates / deactivates all breakpoints on the page. */
    setBreakpointsActive(params) {
        return this._client.send("Debugger.setBreakpointsActive", params);
    }
    /** Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
  no exceptions. Initial pause on exceptions state is `none`. */
    setPauseOnExceptions(params) {
        return this._client.send("Debugger.setPauseOnExceptions", params);
    }
    /** Changes return value in top frame. Available only at return break position. */
    setReturnValue(params) {
        return this._client.send("Debugger.setReturnValue", params);
    }
    /** Edits JavaScript source live. */
    setScriptSource(params) {
        return this._client.send("Debugger.setScriptSource", params);
    }
    /** Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). */
    setSkipAllPauses(params) {
        return this._client.send("Debugger.setSkipAllPauses", params);
    }
    /** Changes value of variable in a callframe. Object-based scopes are not supported and must be
  mutated manually. */
    setVariableValue(params) {
        return this._client.send("Debugger.setVariableValue", params);
    }
    /** Steps into the function call. */
    stepInto(params) {
        return this._client.send("Debugger.stepInto", params);
    }
    /** Steps out of the function call. */
    stepOut() {
        return this._client.send("Debugger.stepOut");
    }
    /** Steps over the statement. */
    stepOver() {
        return this._client.send("Debugger.stepOver");
    }
    /** Fired when breakpoint is resolved to an actual script and location. */
    get breakpointResolved() {
        return this._breakpointResolved;
    }
    set breakpointResolved(handler) {
        if (this._breakpointResolved) {
            this._client.removeListener("Debugger.breakpointResolved", this._breakpointResolved);
        }
        this._breakpointResolved = handler;
        if (handler) {
            this._client.on("Debugger.breakpointResolved", handler);
        }
    }
    /** Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. */
    get paused() {
        return this._paused;
    }
    set paused(handler) {
        if (this._paused) {
            this._client.removeListener("Debugger.paused", this._paused);
        }
        this._paused = handler;
        if (handler) {
            this._client.on("Debugger.paused", handler);
        }
    }
    /** Fired when the virtual machine resumed execution. */
    get resumed() {
        return this._resumed;
    }
    set resumed(handler) {
        if (this._resumed) {
            this._client.removeListener("Debugger.resumed", this._resumed);
        }
        this._resumed = handler;
        if (handler) {
            this._client.on("Debugger.resumed", handler);
        }
    }
    /** Fired when virtual machine fails to parse the script. */
    get scriptFailedToParse() {
        return this._scriptFailedToParse;
    }
    set scriptFailedToParse(handler) {
        if (this._scriptFailedToParse) {
            this._client.removeListener("Debugger.scriptFailedToParse", this._scriptFailedToParse);
        }
        this._scriptFailedToParse = handler;
        if (handler) {
            this._client.on("Debugger.scriptFailedToParse", handler);
        }
    }
    /** Fired when virtual machine parses script. This event is also fired for all known and uncollected
  scripts upon enabling debugger. */
    get scriptParsed() {
        return this._scriptParsed;
    }
    set scriptParsed(handler) {
        if (this._scriptParsed) {
            this._client.removeListener("Debugger.scriptParsed", this._scriptParsed);
        }
        this._scriptParsed = handler;
        if (handler) {
            this._client.on("Debugger.scriptParsed", handler);
        }
    }
}
exports.Debugger = Debugger;
class HeapProfiler {
    constructor(client) {
        this._addHeapSnapshotChunk = null;
        this._heapStatsUpdate = null;
        this._lastSeenObjectId = null;
        this._reportHeapSnapshotProgress = null;
        this._resetProfiles = null;
        this._client = client;
    }
    /** Enables console to refer to the node with given id via $x (see Command Line API for more details
  $x functions). */
    addInspectedHeapObject(params) {
        return this._client.send("HeapProfiler.addInspectedHeapObject", params);
    }
    collectGarbage() {
        return this._client.send("HeapProfiler.collectGarbage");
    }
    disable() {
        return this._client.send("HeapProfiler.disable");
    }
    enable() {
        return this._client.send("HeapProfiler.enable");
    }
    getHeapObjectId(params) {
        return this._client.send("HeapProfiler.getHeapObjectId", params);
    }
    getObjectByHeapObjectId(params) {
        return this._client.send("HeapProfiler.getObjectByHeapObjectId", params);
    }
    getSamplingProfile() {
        return this._client.send("HeapProfiler.getSamplingProfile");
    }
    startSampling(params) {
        return this._client.send("HeapProfiler.startSampling", params);
    }
    startTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.startTrackingHeapObjects", params);
    }
    stopSampling() {
        return this._client.send("HeapProfiler.stopSampling");
    }
    stopTrackingHeapObjects(params) {
        return this._client.send("HeapProfiler.stopTrackingHeapObjects", params);
    }
    takeHeapSnapshot(params) {
        return this._client.send("HeapProfiler.takeHeapSnapshot", params);
    }
    get addHeapSnapshotChunk() {
        return this._addHeapSnapshotChunk;
    }
    set addHeapSnapshotChunk(handler) {
        if (this._addHeapSnapshotChunk) {
            this._client.removeListener("HeapProfiler.addHeapSnapshotChunk", this._addHeapSnapshotChunk);
        }
        this._addHeapSnapshotChunk = handler;
        if (handler) {
            this._client.on("HeapProfiler.addHeapSnapshotChunk", handler);
        }
    }
    /** If heap objects tracking has been started then backend may send update for one or more fragments */
    get heapStatsUpdate() {
        return this._heapStatsUpdate;
    }
    set heapStatsUpdate(handler) {
        if (this._heapStatsUpdate) {
            this._client.removeListener("HeapProfiler.heapStatsUpdate", this._heapStatsUpdate);
        }
        this._heapStatsUpdate = handler;
        if (handler) {
            this._client.on("HeapProfiler.heapStatsUpdate", handler);
        }
    }
    /** If heap objects tracking has been started then backend regularly sends a current value for last
  seen object id and corresponding timestamp. If the were changes in the heap since last event
  then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. */
    get lastSeenObjectId() {
        return this._lastSeenObjectId;
    }
    set lastSeenObjectId(handler) {
        if (this._lastSeenObjectId) {
            this._client.removeListener("HeapProfiler.lastSeenObjectId", this._lastSeenObjectId);
        }
        this._lastSeenObjectId = handler;
        if (handler) {
            this._client.on("HeapProfiler.lastSeenObjectId", handler);
        }
    }
    get reportHeapSnapshotProgress() {
        return this._reportHeapSnapshotProgress;
    }
    set reportHeapSnapshotProgress(handler) {
        if (this._reportHeapSnapshotProgress) {
            this._client.removeListener("HeapProfiler.reportHeapSnapshotProgress", this._reportHeapSnapshotProgress);
        }
        this._reportHeapSnapshotProgress = handler;
        if (handler) {
            this._client.on("HeapProfiler.reportHeapSnapshotProgress", handler);
        }
    }
    get resetProfiles() {
        return this._resetProfiles;
    }
    set resetProfiles(handler) {
        if (this._resetProfiles) {
            this._client.removeListener("HeapProfiler.resetProfiles", this._resetProfiles);
        }
        this._resetProfiles = handler;
        if (handler) {
            this._client.on("HeapProfiler.resetProfiles", handler);
        }
    }
}
exports.HeapProfiler = HeapProfiler;
class Profiler {
    constructor(client) {
        this._consoleProfileFinished = null;
        this._consoleProfileStarted = null;
        this._client = client;
    }
    disable() {
        return this._client.send("Profiler.disable");
    }
    enable() {
        return this._client.send("Profiler.enable");
    }
    /** Collect coverage data for the current isolate. The coverage data may be incomplete due to
  garbage collection. */
    getBestEffortCoverage() {
        return this._client.send("Profiler.getBestEffortCoverage");
    }
    /** Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. */
    setSamplingInterval(params) {
        return this._client.send("Profiler.setSamplingInterval", params);
    }
    start() {
        return this._client.send("Profiler.start");
    }
    /** Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
  coverage may be incomplete. Enabling prevents running optimized code and resets execution
  counters. */
    startPreciseCoverage(params) {
        return this._client.send("Profiler.startPreciseCoverage", params);
    }
    /** Enable type profile. */
    startTypeProfile() {
        return this._client.send("Profiler.startTypeProfile");
    }
    stop() {
        return this._client.send("Profiler.stop");
    }
    /** Disable precise code coverage. Disabling releases unnecessary execution count records and allows
  executing optimized code. */
    stopPreciseCoverage() {
        return this._client.send("Profiler.stopPreciseCoverage");
    }
    /** Disable type profile. Disabling releases type profile data collected so far. */
    stopTypeProfile() {
        return this._client.send("Profiler.stopTypeProfile");
    }
    /** Collect coverage data for the current isolate, and resets execution counters. Precise code
  coverage needs to have started. */
    takePreciseCoverage() {
        return this._client.send("Profiler.takePreciseCoverage");
    }
    /** Collect type profile. */
    takeTypeProfile() {
        return this._client.send("Profiler.takeTypeProfile");
    }
    get consoleProfileFinished() {
        return this._consoleProfileFinished;
    }
    set consoleProfileFinished(handler) {
        if (this._consoleProfileFinished) {
            this._client.removeListener("Profiler.consoleProfileFinished", this._consoleProfileFinished);
        }
        this._consoleProfileFinished = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileFinished", handler);
        }
    }
    /** Sent when new profile recording is started using console.profile() call. */
    get consoleProfileStarted() {
        return this._consoleProfileStarted;
    }
    set consoleProfileStarted(handler) {
        if (this._consoleProfileStarted) {
            this._client.removeListener("Profiler.consoleProfileStarted", this._consoleProfileStarted);
        }
        this._consoleProfileStarted = handler;
        if (handler) {
            this._client.on("Profiler.consoleProfileStarted", handler);
        }
    }
}
exports.Profiler = Profiler;
/** Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
Evaluation results are returned as mirror object that expose object type, string representation
and unique identifier that can be used for further object reference. Original objects are
maintained in memory unless they are either explicitly released or are released along with the
other objects in their object group. */
class Runtime {
    constructor(client) {
        this._bindingCalled = null;
        this._consoleAPICalled = null;
        this._exceptionRevoked = null;
        this._exceptionThrown = null;
        this._executionContextCreated = null;
        this._executionContextDestroyed = null;
        this._executionContextsCleared = null;
        this._inspectRequested = null;
        this._client = client;
    }
    /** Add handler to promise with given promise object id. */
    awaitPromise(params) {
        return this._client.send("Runtime.awaitPromise", params);
    }
    /** Calls function with given declaration on the given object. Object group of the result is
  inherited from the target object. */
    callFunctionOn(params) {
        return this._client.send("Runtime.callFunctionOn", params);
    }
    /** Compiles expression. */
    compileScript(params) {
        return this._client.send("Runtime.compileScript", params);
    }
    /** Disables reporting of execution contexts creation. */
    disable() {
        return this._client.send("Runtime.disable");
    }
    /** Discards collected exceptions and console API calls. */
    discardConsoleEntries() {
        return this._client.send("Runtime.discardConsoleEntries");
    }
    /** Enables reporting of execution contexts creation by means of `executionContextCreated` event.
  When the reporting gets enabled the event will be sent immediately for each existing execution
  context. */
    enable() {
        return this._client.send("Runtime.enable");
    }
    /** Evaluates expression on global object. */
    evaluate(params) {
        return this._client.send("Runtime.evaluate", params);
    }
    /** Returns the isolate id. */
    getIsolateId() {
        return this._client.send("Runtime.getIsolateId");
    }
    /** Returns the JavaScript heap usage.
  It is the total usage of the corresponding isolate not scoped to a particular Runtime. */
    getHeapUsage() {
        return this._client.send("Runtime.getHeapUsage");
    }
    /** Returns properties of a given object. Object group of the result is inherited from the target
  object. */
    getProperties(params) {
        return this._client.send("Runtime.getProperties", params);
    }
    /** Returns all let, const and class variables from global scope. */
    globalLexicalScopeNames(params) {
        return this._client.send("Runtime.globalLexicalScopeNames", params);
    }
    queryObjects(params) {
        return this._client.send("Runtime.queryObjects", params);
    }
    /** Releases remote object with given id. */
    releaseObject(params) {
        return this._client.send("Runtime.releaseObject", params);
    }
    /** Releases all remote objects that belong to a given group. */
    releaseObjectGroup(params) {
        return this._client.send("Runtime.releaseObjectGroup", params);
    }
    /** Tells inspected instance to run if it was waiting for debugger to attach. */
    runIfWaitingForDebugger() {
        return this._client.send("Runtime.runIfWaitingForDebugger");
    }
    /** Runs script with given id in a given context. */
    runScript(params) {
        return this._client.send("Runtime.runScript", params);
    }
    /** Enables or disables async call stacks tracking. */
    setAsyncCallStackDepth(params) {
        return this._client.send("Runtime.setAsyncCallStackDepth", params);
    }
    setCustomObjectFormatterEnabled(params) {
        return this._client.send("Runtime.setCustomObjectFormatterEnabled", params);
    }
    setMaxCallStackSizeToCapture(params) {
        return this._client.send("Runtime.setMaxCallStackSizeToCapture", params);
    }
    /** Terminate current or next JavaScript execution.
  Will cancel the termination when the outer-most script execution ends. */
    terminateExecution() {
        return this._client.send("Runtime.terminateExecution");
    }
    /** If executionContextId is empty, adds binding with the given name on the
  global objects of all inspected contexts, including those created later,
  bindings survive reloads.
  If executionContextId is specified, adds binding only on global object of
  given execution context.
  Binding function takes exactly one argument, this argument should be string,
  in case of any other input, function throws an exception.
  Each binding function call produces Runtime.bindingCalled notification. */
    addBinding(params) {
        return this._client.send("Runtime.addBinding", params);
    }
    /** This method does not remove binding function from global object but
  unsubscribes current runtime agent from Runtime.bindingCalled notifications. */
    removeBinding(params) {
        return this._client.send("Runtime.removeBinding", params);
    }
    /** Notification is issued every time when binding is called. */
    get bindingCalled() {
        return this._bindingCalled;
    }
    set bindingCalled(handler) {
        if (this._bindingCalled) {
            this._client.removeListener("Runtime.bindingCalled", this._bindingCalled);
        }
        this._bindingCalled = handler;
        if (handler) {
            this._client.on("Runtime.bindingCalled", handler);
        }
    }
    /** Issued when console API was called. */
    get consoleAPICalled() {
        return this._consoleAPICalled;
    }
    set consoleAPICalled(handler) {
        if (this._consoleAPICalled) {
            this._client.removeListener("Runtime.consoleAPICalled", this._consoleAPICalled);
        }
        this._consoleAPICalled = handler;
        if (handler) {
            this._client.on("Runtime.consoleAPICalled", handler);
        }
    }
    /** Issued when unhandled exception was revoked. */
    get exceptionRevoked() {
        return this._exceptionRevoked;
    }
    set exceptionRevoked(handler) {
        if (this._exceptionRevoked) {
            this._client.removeListener("Runtime.exceptionRevoked", this._exceptionRevoked);
        }
        this._exceptionRevoked = handler;
        if (handler) {
            this._client.on("Runtime.exceptionRevoked", handler);
        }
    }
    /** Issued when exception was thrown and unhandled. */
    get exceptionThrown() {
        return this._exceptionThrown;
    }
    set exceptionThrown(handler) {
        if (this._exceptionThrown) {
            this._client.removeListener("Runtime.exceptionThrown", this._exceptionThrown);
        }
        this._exceptionThrown = handler;
        if (handler) {
            this._client.on("Runtime.exceptionThrown", handler);
        }
    }
    /** Issued when new execution context is created. */
    get executionContextCreated() {
        return this._executionContextCreated;
    }
    set executionContextCreated(handler) {
        if (this._executionContextCreated) {
            this._client.removeListener("Runtime.executionContextCreated", this._executionContextCreated);
        }
        this._executionContextCreated = handler;
        if (handler) {
            this._client.on("Runtime.executionContextCreated", handler);
        }
    }
    /** Issued when execution context is destroyed. */
    get executionContextDestroyed() {
        return this._executionContextDestroyed;
    }
    set executionContextDestroyed(handler) {
        if (this._executionContextDestroyed) {
            this._client.removeListener("Runtime.executionContextDestroyed", this._executionContextDestroyed);
        }
        this._executionContextDestroyed = handler;
        if (handler) {
            this._client.on("Runtime.executionContextDestroyed", handler);
        }
    }
    /** Issued when all executionContexts were cleared in browser */
    get executionContextsCleared() {
        return this._executionContextsCleared;
    }
    set executionContextsCleared(handler) {
        if (this._executionContextsCleared) {
            this._client.removeListener("Runtime.executionContextsCleared", this._executionContextsCleared);
        }
        this._executionContextsCleared = handler;
        if (handler) {
            this._client.on("Runtime.executionContextsCleared", handler);
        }
    }
    /** Issued when object should be inspected (for example, as a result of inspect() command line API
  call). */
    get inspectRequested() {
        return this._inspectRequested;
    }
    set inspectRequested(handler) {
        if (this._inspectRequested) {
            this._client.removeListener("Runtime.inspectRequested", this._inspectRequested);
        }
        this._inspectRequested = handler;
        if (handler) {
            this._client.on("Runtime.inspectRequested", handler);
        }
    }
}
exports.Runtime = Runtime;
/** This domain is deprecated. */
class Schema {
    constructor(client) {
        this._client = client;
    }
    /** Returns supported domains. */
    getDomains() {
        return this._client.send("Schema.getDomains");
    }
}
exports.Schema = Schema;
//# sourceMappingURL=v8.js.map