"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Protocol = require("./protocol");
/**
 * Generate Typescript interface to use with the DebuggingProtocol#domains(protocol) method.
 */
class ProtocolCodegen {
    constructor(options) {
        this.code = undefined;
        this.indentStack = [""];
        this.refs = new Map();
        const opts = options || {};
        this.clientModuleName = opts.clientModuleName || "chrome-debugging-client";
        this.indent = opts.indent || "  ";
    }
    get currentIndent() {
        return this.indentStack[this.indentStack.length - 1];
    }
    generate(protocol) {
        this.code = "";
        this.indentStack.length = 1;
        this.appendProtocolVersionComment(protocol.version);
        this.appendClientImport();
        const domains = new Set();
        each(protocol.domains, domain => {
            this.gatherRefs(domain);
            domains.add(domain.domain);
        });
        each(protocol.domains, domain => {
            const { domain: domainName, events, commands, types } = domain;
            this.appendComment(domain);
            this.appendDomainClass(domainName, () => {
                each(events, event => {
                    this.appendEventMember(event, domainName);
                });
                this.appendClientMember();
                this.appendDomainConstructor();
                each(commands, command => {
                    this.appendComment(command);
                    this.appendCommandMethod(command, domainName);
                });
                each(events, event => {
                    this.appendComment(event);
                    this.appendEventAccessors(event, domainName);
                });
            });
            this.generateDomainTypeNamespace(domainName, () => {
                const refs = this.getRefs(domainName);
                each(types, type => {
                    refs.set(type.id, true);
                    this.appendComment(type);
                    this.appendType(type);
                });
                this.generatorMissingRefs(domainName, refs);
                each(events, event => {
                    this.appendEventParametersType(event);
                    this.appendEventHandlerType(event);
                });
                each(commands, command => {
                    this.appendCommandTypes(command);
                });
            });
        });
        this.refs.forEach((refs, domainName) => {
            if (!domains.has(domainName)) {
                this.generateDomainTypeNamespace(domainName, () => {
                    this.generatorMissingRefs(domainName, refs);
                });
            }
        });
        const code = this.code;
        this.code = undefined;
        this.refs.clear();
        return code;
    }
    generatorMissingRefs(domainName, refs) {
        refs.forEach((value, key) => {
            if (!value) {
                /* tslint:disable:no-console */
                console.warn(`missing $ref ${domainName}.${key}`);
                /* tslint:enable:no-console */
                this.generateObjectTypeAlias(key, []);
            }
        });
    }
    getRefs(domainName) {
        let refs = this.refs.get(domainName);
        if (!refs) {
            refs = new Map();
            this.refs.set(domainName, refs);
        }
        return refs;
    }
    gatherRefs(domain) {
        const refs = this.getRefs(domain.domain);
        each(domain.types, type => {
            this.gatherRefsFromDesc(type, refs);
        });
        each(domain.commands, command => {
            if (command.parameters) {
                this.gatherRefsFromDescs(command.parameters, refs);
            }
            if (command.returns) {
                this.gatherRefsFromDescs(command.returns, refs);
            }
        });
        each(domain.events, event => {
            if (event.parameters) {
                this.gatherRefsFromDescs(event.parameters, refs);
            }
        });
        this.refs.set(domain.domain, refs);
    }
    gatherRefsFromDescs(descs, refs) {
        for (const desc of descs) {
            this.gatherRefsFromDesc(desc, refs);
        }
    }
    gatherRefsFromDesc(desc, refs) {
        if (Protocol.isTypeRef(desc)) {
            const ref = desc.$ref;
            const period = ref.indexOf(".");
            if (period !== -1) {
                this.getRefs(ref.substring(0, period)).set(ref.substring(period + 1), false);
            }
            else {
                refs.set(ref, false);
            }
        }
        else if (Protocol.isArrayDescriptor(desc)) {
            this.gatherRefsFromDesc(desc.items, refs);
        }
        else if (Protocol.isObjectDescriptor(desc)) {
            if (desc.properties) {
                this.gatherRefsFromDescs(desc.properties, refs);
            }
        }
    }
    appendProtocolVersionComment(version) {
        let versionString = "";
        if (version) {
            versionString = `${version.major}.${version.minor} `;
        }
        this.append("/**");
        this.append(` * Debugging Protocol ${versionString}Domains`);
        this.append(` * Generated on ${new Date()}`);
        this.append(" */");
        this.append("/* tslint:disable */");
    }
    appendClientImport() {
        this.append(`import { IDebuggingProtocolClient } from "${this.clientModuleName}";`);
    }
    appendDomainClass(domainName, cb) {
        this.append(`export class ${domainName} {`);
        this.block(cb);
        this.append("}");
    }
    generateDomainTypeNamespace(domainName, cb) {
        this.append(`export namespace ${domainName} {`);
        this.block(cb);
        this.append("}");
    }
    appendEventMember(event, domainName) {
        const name = event.name;
        this.append(`private _${name}: ${this.handlerTypeName(name, domainName)} | null = null;`);
    }
    appendClientMember() {
        this.append("private _client: IDebuggingProtocolClient;");
    }
    appendDomainConstructor() {
        this.append(`constructor(client: IDebuggingProtocolClient) {`);
        this.block(() => {
            this.append("this._client = client;");
        });
        this.append("}");
    }
    appendCommandMethod(command, domainName) {
        const name = command.name;
        const params = command.parameters
            ? `params: ${this.parametersTypeName(name, domainName)}`
            : "";
        const paramsArg = command.parameters ? ", params" : "";
        const returnType = command.returns
            ? this.returnTypeName(name, domainName)
            : "void";
        this.append(`public ${name}(${params}) {`);
        this.block(() => {
            this.append(`return this._client.send<${returnType}>("${domainName}.${name}"${paramsArg});`);
        });
        this.append("}");
    }
    appendEventAccessors(event, domainName) {
        const name = event.name;
        this.append(`get ${name}() {`);
        this.block(() => {
            this.append(`return this._${name};`);
        });
        this.append("}");
        this.append(`set ${name}(handler) {`);
        this.block(() => {
            this.append(`if (this._${name}) {`);
            this.block(() => {
                this.append(`this._client.removeListener("${domainName}.${name}", this._${name});`);
            });
            this.append("}");
            this.append(`this._${name} = handler;`);
            this.append("if (handler) {");
            this.block(() => {
                this.append(`this._client.on("${domainName}.${name}", handler);`);
            });
            this.append(`}`);
        });
        this.append("}");
    }
    appendType(type) {
        if (Protocol.isTypeRef(type)) {
            this.append(`export type ${type.id} = ${type.$ref};`);
        }
        else if (Protocol.isObjectDescriptor(type)) {
            const { properties } = type;
            if (properties && properties.length > 0) {
                this.append(`export interface ${type.id} {`);
                this.block(() => {
                    each(properties, prop => this.generateProperty(prop));
                });
                this.append("}");
            }
            else {
                this.append(`export type ${type.id} = any;`);
            }
        }
        else {
            this.append(`export type ${type.id} = ${this.typeString(type)};`);
        }
    }
    appendEventParametersType(event) {
        if (event.parameters) {
            this.generateObjectTypeAlias(`${this.parametersTypeName(event.name)}`, event.parameters);
        }
    }
    appendEventHandlerType(event) {
        const params = event.parameters
            ? `params: ${this.parametersTypeName(event.name)}`
            : "";
        this.append(`export type ${this.handlerTypeName(event.name)} = (${params}) => void;`);
    }
    block(cb) {
        this.indentStack.push(this.currentIndent + this.indent);
        cb();
        this.indentStack.pop();
    }
    append(line) {
        this.code += this.currentIndent + line + "\n";
    }
    generateProperty(desc) {
        this.appendComment(desc);
        this.append(this.namedTypeString(desc));
    }
    appendComment(obj) {
        if (!obj.description) {
            return;
        }
        this.append(`/** ${obj.description} */`);
    }
    appendCommandTypes(command) {
        const name = command.name;
        if (command.parameters) {
            this.generateObjectTypeAlias(this.parametersTypeName(name), command.parameters);
        }
        if (command.returns) {
            this.generateObjectTypeAlias(this.returnTypeName(name), command.returns);
        }
    }
    returnTypeName(name, domainName) {
        return buildTypeName(name, "Return", domainName);
    }
    parametersTypeName(name, domainName) {
        return buildTypeName(name, "Parameters", domainName);
    }
    handlerTypeName(name, domainName) {
        return buildTypeName(name, "Handler", domainName);
    }
    generateObjectTypeAlias(name, props) {
        if (props && props.length) {
            this.append(`export type ${name} = {`);
            this.block(() => {
                props.forEach(prop => this.generateProperty(prop));
            });
            this.append("};");
        }
        else {
            this.append(`export type ${name} = any;`);
        }
    }
    namedTypeString(desc) {
        return `${desc.name}${desc.optional ? "?" : ""}: ${this.typeString(desc)};`;
    }
    typeString(desc, isArray) {
        let typeName;
        let simple = true;
        if (Protocol.isTypeRef(desc)) {
            typeName = desc.$ref;
        }
        else if (Protocol.isObjectDescriptor(desc)) {
            const { properties } = desc;
            if (properties && properties.length) {
                simple = false;
                typeName =
                    "{ " + properties.map(p => this.namedTypeString(p)).join(" ") + " }";
            }
            else {
                typeName = "any";
            }
        }
        else if (Protocol.isArrayDescriptor(desc)) {
            typeName = this.typeString(desc.items, true);
        }
        else if (Protocol.isStringDescriptor(desc)) {
            if (Protocol.isEnumDescriptor(desc)) {
                simple = false;
                typeName = desc.enum.map(str => JSON.stringify(str)).join(" | ");
            }
            else {
                typeName = "string";
            }
        }
        else if (Protocol.isNumberDescriptor(desc)) {
            typeName = "number";
        }
        else {
            typeName = desc.type;
        }
        return isArray
            ? simple ? `${typeName}[]` : `Array<${typeName}>`
            : typeName;
    }
}
exports.default = ProtocolCodegen;
function each(arr, cb) {
    if (arr) {
        for (const item of arr) {
            cb(item);
        }
    }
}
function buildTypeName(name, suffix, domainName) {
    let typeName = name.substring(0, 1).toUpperCase() + name.substring(1) + suffix;
    if (domainName) {
        typeName = `${domainName}.${typeName}`;
    }
    return typeName;
}
//# sourceMappingURL=protocol-codegen.js.map