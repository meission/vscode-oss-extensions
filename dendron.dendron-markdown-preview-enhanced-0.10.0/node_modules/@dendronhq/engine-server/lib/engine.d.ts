import { DEngine, DEngineMode, DEngineOpts, DEngineStore, DNodeData, DNodeDict, DNodeRawProps, EngineDeleteOpts, EngineGetResp, EngineQueryResp, IDNode, NodeWriteOpts, Note, NoteDict, QueryMode, QueryOneOpts, QueryOpts, Schema, SchemaDict, UpdateNodesOpts } from "@dendronhq/common-all";
import { DLogger, Logger } from "@dendronhq/common-server";
import Fuse from "fuse.js";
declare type DendronEngineOpts = {
    root: string;
    forceNew?: boolean;
    store?: DEngineStore;
    mode?: DEngineMode;
    logger?: DLogger;
};
declare type DendronEngineProps = Required<DendronEngineOpts>;
export declare class DendronEngine implements DEngine {
    fuse: Fuse<Note>;
    schemaFuse: Fuse<Schema>;
    notes: NoteDict;
    schemas: SchemaDict;
    fullNodes: Set<string>;
    initialized: boolean;
    props: DendronEngineProps;
    queries: Set<string>;
    store: DEngineStore;
    logger: Logger;
    static getOrCreateEngine(opts?: DendronEngineOpts): DEngine;
    constructor(store: DEngineStore, props: DendronEngineProps);
    _createRoot(mode: QueryMode): IDNode;
    init(): Promise<void>;
    /**
     * Does the following
     *  - remove from search index
     *  - remove from `notes` dict
     *  - remove from `fullNodes` dict
     * @param id
     * @param mode
     */
    deleteFromNodes(id: string, mode: QueryMode): void;
    /**
     * Updates local cache
     * - if node is new, add it to cache
     * - if not new, update existing node properties
     * - extra:
     *   - if full node, add id
     * @param nodes
     * @param opts
     */
    refreshNodes(nodes: IDNode[], opts?: {
        fullNode?: boolean;
    }): Promise<void>;
    /**
     * Turn parent|children ids to full nodes
     */
    resolveIds(node: DNodeRawProps<DNodeData>, dict: DNodeDict): Promise<Note>;
    updateLocalCollection(collection: IDNode[], mode: QueryMode): void;
    delete(idOrFname: string, mode: QueryMode, opts?: EngineDeleteOpts): Promise<void>;
    /**
     * Defaults
     * @param id
     * @param opts
     *  - fullNode: {default:true}
     */
    get(id: string, mode: QueryMode, opts?: QueryOpts): Promise<{
        data: Schema;
    } | {
        data: Note;
    }>;
    query(queryString: string, mode: QueryMode, opts?: QueryOpts): Promise<EngineQueryResp<DNodeData>>;
    queryOne(queryString: string, mode: QueryMode, opts?: QueryOneOpts): Promise<EngineGetResp<DNodeData>>;
    write(node: IDNode, opts?: NodeWriteOpts): Promise<void>;
    updateProps(opts: DEngineOpts): void;
    updateNodes(nodes: IDNode[], opts: UpdateNodesOpts): Promise<void>;
    _updateSchema(node: Schema): Promise<void>;
    /**
     * Indexes note into engine. This does a few things:
     *   - Add parent-child relationship to note.
     *   - If parent's don't exist, create parents as stubs.
     *   - Calls `refreshNodes` on notes
     * @param note
     * @param opts
     */
    _updateNote(note: Note, opts: UpdateNodesOpts): Promise<void>;
}
export {};
