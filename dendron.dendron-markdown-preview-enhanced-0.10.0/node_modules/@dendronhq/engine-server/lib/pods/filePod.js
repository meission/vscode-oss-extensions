"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilePod = void 0;
/* eslint-disable func-names */
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const klaw_1 = __importDefault(require("klaw"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const through2_1 = __importDefault(require("through2"));
const base_1 = require("./base");
const toMarkdownLink = (assetPath, opts) => {
    const name = (opts === null || opts === void 0 ? void 0 : opts.name) ? opts.name : path_1.default.parse(assetPath).name;
    return `- [${name}](${assetPath})`;
};
class FilePod extends base_1.BasePod {
    async fetch() { }
    /**
     * Return list of note props keyed by level of hierarchy
     * @param files
     */
    files2HierarichalDict(files, root) {
        const out = {};
        lodash_1.default.forEach(files, (item) => {
            const fname = common_server_1.cleanFileName(item.path, {
                isDir: item.stats.isDirectory(),
            });
            const lvl = fname.split(".").length;
            if (!lodash_1.default.has(out, lvl)) {
                out[lvl] = [];
            }
            const stub = item.stats.isDirectory() && lodash_1.default.isEmpty(item.entries);
            const noteProps = common_all_1.DNodeRaw.createProps({
                fname,
                stub,
            });
            if (item === null || item === void 0 ? void 0 : item.body) {
                noteProps.body = item.body;
            }
            if (item === null || item === void 0 ? void 0 : item.data) {
                noteProps.data = item.data;
            }
            // deal with non-md files
            if (!lodash_1.default.isEmpty(item.entries)) {
                // move entries over
                // TODO: don't hardcode assets
                const assetDirName = "assets";
                const assetDir = path_1.default.join(this.engine.props.root, assetDirName);
                fs_extra_1.default.ensureDirSync(assetDir);
                const mdLinks = [];
                item.entries.map((_item) => {
                    const uuid = common_all_1.genUUID();
                    const { ext, name } = path_1.default.parse(_item.path);
                    // const { ext, name } = path.parse(cleanFileName(_item.path));
                    const assetBaseNew = `${common_server_1.cleanFileName(name)}-${uuid}${ext}`;
                    const assetPathFull = path_1.default.join(assetDir, assetBaseNew);
                    const assetPathRel = path_1.default.join(assetDirName, assetBaseNew);
                    // TODO: make sure to append uuid
                    fs_extra_1.default.copyFileSync(path_1.default.join(root, _item.path), assetPathFull);
                    mdLinks.push(toMarkdownLink(assetPathRel, { name: `${name}${ext}` }));
                });
                // TODO
                noteProps.body = `# Imported Assets\n${mdLinks.join("\n")}`;
            }
            out[lvl].push(noteProps);
        });
        return out;
    }
    hDict2Notes(hdict) {
        const noteDict = {};
        // TODO: currently don't handle stuff attached to root
        hdict[1]
            .filter((n) => !lodash_1.default.isEmpty(n.fname))
            .forEach((props) => {
            const n = new common_all_1.Note({ ...props, parent: null, children: [] });
            noteDict[n.fname] = n;
        });
        let lvl = 2;
        let currRawNodes = hdict[lvl];
        while (!lodash_1.default.isEmpty(currRawNodes)) {
            currRawNodes.forEach((props) => {
                const parentPath = common_all_1.DNodeUtils.dirName(props.fname);
                if (lodash_1.default.has(noteDict, parentPath)) {
                    const n = new common_all_1.Note({
                        ...props,
                        parent: null,
                        children: [],
                    });
                    noteDict[parentPath].addChild(n);
                    noteDict[n.fname] = n;
                }
                else {
                    throw Error("missing notes not supported yet");
                }
            });
            lvl += 1;
            currRawNodes = hdict[lvl];
        }
        return lodash_1.default.values(noteDict);
    }
    async handleImport(opts) {
        const ctx = "FilePod.handleImport";
        const { root } = opts;
        const items = []; // files, directories, symlinks, etc
        const mask = root.endsWith("/") ? root.length : root.length + 1;
        this.L.info({ ctx, opts });
        const excludeFilter = through2_1.default.obj(function (item, _enc, next) {
            // check if hidden file
            if (!lodash_1.default.some(item.path.split("/"), (ent) => ent.startsWith("."))) {
                this.push(item);
            }
            next();
        });
        // collect all files
        // TODO: catch errors
        await new Promise((resolve, _reject) => {
            klaw_1.default(root)
                .pipe(excludeFilter)
                // eslint-disable-next-line prefer-arrow-callback
                .on("data", function (item) {
                const out = { ...item, entries: [] };
                if (item.path.endsWith(".md")) {
                    const { data, content } = gray_matter_1.default.read(item.path, {});
                    out.data = data;
                    out.body = content;
                }
                out.path = out.path.slice(mask);
                items.push(out);
            })
                .on("end", () => {
                resolve(items);
            });
        });
        const engineFileDict = {};
        const assetFileDict = {};
        // create map of files
        lodash_1.default.each(items, (v, _k) => {
            if (lodash_1.default.some([v.path.endsWith(".md"), v.stats.isDirectory()])) {
                engineFileDict[v.path] = v;
            }
            else {
                assetFileDict[v.path] = v;
            }
        });
        // add assets
        lodash_1.default.values(assetFileDict).forEach((ent) => {
            const dirname = path_1.default.dirname(ent.path);
            engineFileDict[dirname].entries.push(ent);
        });
        // convert to dot files
        const hDict = this.files2HierarichalDict(lodash_1.default.values(engineFileDict), root);
        const notes = this.hDict2Notes(hDict);
        // OPTIMIZE: parallilize
        //await this.engine.updateNodes(notes, {parentsAsStubs: false, newNode: true})
        await Promise.all(notes.map((n) => {
            return this.engine.write(n, {
                stub: n.stub,
                newNode: true,
                noAddParent: true,
            });
        }));
        // add domain nodes
        this.engine.updateNodes(lodash_1.default.filter(notes, { parent: null }), {
            newNode: false,
            parentsAsStubs: false,
        });
        return;
    }
}
exports.FilePod = FilePod;
FilePod.id = "FilePod";
FilePod.importOpts = [
    {
        name: "root",
        required: true,
        description: "Path to directory of holding notes",
        type: "string",
    },
];
//# sourceMappingURL=filePod.js.map