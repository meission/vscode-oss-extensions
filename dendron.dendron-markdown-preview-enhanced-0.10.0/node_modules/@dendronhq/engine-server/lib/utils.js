"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripLocalOnlyTags = exports.replaceRefWithMPEImport = exports.matchRefMarker = exports.parseFileLink = exports.parseDendronRef = exports.extractBlock = exports.refLink2String = void 0;
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const markdown_it_1 = __importDefault(require("markdown-it"));
// @ts-ignoreig
const markdown_it_ast_1 = __importDefault(require("markdown-it-ast"));
const path_1 = __importDefault(require("path"));
const markdownIt = markdown_it_1.default();
function normalize(text) {
    return lodash_1.default.toLower(lodash_1.default.trim(text, " #"));
}
function refLink2String(link, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, { includeParen: false });
    // [[foo]]#head1:#*"
    const linkParts = [`[[${link.name}]]`];
    if (link.anchorStart) {
        linkParts.push(`#${normalize(link.anchorStart)}`);
    }
    if (link.anchorStartOffset) {
        linkParts.push(`,${link.anchorStartOffset}`);
    }
    if (link.anchorEnd) {
        linkParts.push(`:#${normalize(link.anchorEnd)}`);
    }
    if (cleanOpts.includeParen) {
        linkParts.splice(0, 0, "((");
        linkParts.push("))");
    }
    return linkParts.join("");
}
exports.refLink2String = refLink2String;
// const testString = "<!--(([[class.mba.chapters.2]]))-->";
function genAST(txt) {
    const tokens = markdownIt.parse(txt, {});
    return markdown_it_ast_1.default.makeAST(tokens);
}
function extractBlock(txt, link
//opts?: { linesOnly?: boolean }
) {
    // const copts = _.defaults(opts, { linesOnly: false });
    const { anchorStart, anchorEnd } = link;
    if (link.type === "id") {
        throw Error(`id link not supported`);
    }
    else {
        //txt = _.trim(txt);
        if (!anchorStart) {
            return { block: txt };
        }
        const ast = genAST(txt);
        const clean = {
            anchorStart: lodash_1.default.trim(anchorStart),
            anchorEnd: lodash_1.default.trim(anchorEnd),
        };
        const out = {
            anchorStart: null,
            anchorEnd: null,
        };
        ast.forEach((ent) => {
            if (ent.nodeType === "heading") {
                const matchKey = lodash_1.default.isNull(out["anchorStart"])
                    ? "anchorStart"
                    : "anchorEnd";
                if (lodash_1.default.trim(ent.children[0].content) === clean[matchKey]) {
                    out[matchKey] = ent.openNode.map;
                }
            }
        });
        const txtAsLines = txt.split("\n");
        if (lodash_1.default.isNull(out.anchorStart)) {
            return { block: "invalid link" };
        }
        const start = out.anchorStart[0] - 1;
        const end = lodash_1.default.isNull(out["anchorEnd"])
            ? txtAsLines.length
            : out["anchorEnd"][0];
        const block = lodash_1.default.trim(txtAsLines.slice(start, end).join("\n"));
        return { block, lines: { start, end } };
    }
}
exports.extractBlock = extractBlock;
function parseDendronRef(ref) {
    const [idOrRef, ...rest] = lodash_1.default.trim(ref).split(":");
    const cleanArgs = lodash_1.default.trim(rest.join(":"));
    let link;
    let direction;
    if (idOrRef === "ref") {
        direction = "to";
        // eslint-disable-next-line no-use-before-define
        link = parseLink(cleanArgs);
    }
    else {
        throw Error("not implemented");
    }
    return { direction, link };
}
exports.parseDendronRef = parseDendronRef;
function parseFileLink(ref) {
    var _a;
    const wikiFileName = /([^\]:]+)/.source;
    const reLink = new RegExp("" +
        /\[\[/.source +
        `(?<name>${wikiFileName})` +
        /\]\]/.source +
        `(${new RegExp(
        // anchor start
        "" +
            /#?/.source +
            `(?<anchorStart>${wikiFileName})` +
            // anchor stop
            `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
    const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
    const clean = {
        type: "file",
    };
    lodash_1.default.each(groups, (v, k) => {
        if (k === "name") {
            // @ts-ignore
            clean[k] = path_1.default.basename(v, ".md");
        }
        else {
            // @ts-ignore
            clean[k] = v;
        }
    });
    if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
        const [anchorStart, offset] = clean.anchorStart.split(",");
        clean.anchorStart = anchorStart;
        clean.anchorStartOffset = parseInt(offset);
    }
    return clean;
}
exports.parseFileLink = parseFileLink;
// export function parseIdLink(ref: string): DendronRefLink {
//     const reLink = /(?<id>[^:]+)(:([^:]+))?/;
// };
function parseLink(ref) {
    if (ref.indexOf("]") >= 0) {
        return parseFileLink(ref);
    }
    else {
        throw Error("not implemented");
    }
}
// function testLineRef() {
//     const ref = "ref: b9f5caaa-288e-41e9-a2a2-21f1d8e49625";
//     return assert(parseDendronRef(ref), {
//         type: 'ref',
//         start: {id: 'b9f5caaa-288e-41e9-a2a2-21f1d8e49625'},
//     });
// };
// function testFileWithLineRef() {
//     const ref = "ref: [[foo]]#b9f5caaa-288e-41e9-a2a2-21f1d8e49625";
//     return assert(parseDendronRef(ref), {
//         type: 'ref',
//         start: {id: 'b9f5caaa-288e-41e9-a2a2-21f1d8e49625', name: 'foo'},
//     });
// };
// function testBlockRef() {
//     const ref = "ref: {[[foo.md]]#b9f5caaa-288e-41e9-a2a2-21f1d8e49625:8cf13bab-a231-40a7-9860-f52b24083873}";
//     return assert(parseDendronRef(ref), {
//         type: 'ref',
//         start: {id: 'b9f5caaa-288e-41e9-a2a2-21f1d8e49625', name: 'foo'},
//         stop: {id: '8cf13bab-a231-40a7-9860-f52b24083873'}
//     });
// };
// function runTests() {
//     console.log(testFileRef());
//     // console.log(testLineRef());
//     // console.log(testFileWithLineRef());
//     // console.log(testBlockRef());
// }
exports.matchRefMarker = (txt) => {
    return txt.match(/\(\((?<ref>[^)]+)\)\)/);
};
exports.replaceRefWithMPEImport = (line, opts) => {
    const match = exports.matchRefMarker(line);
    let prefix = `@import`;
    if (!match || !match.groups) {
        return line;
    }
    const ref = match.groups["ref"];
    if (!ref) {
        return line;
    }
    const { link } = parseDendronRef(ref);
    // unsupported
    if (!link || !link.name) {
        return line;
    }
    const fsPath = path_1.default.join(opts.root, link.name + ".md");
    prefix += ` "${link.name + ".md"}"`;
    if (!link.anchorStart) {
        return prefix;
    }
    // {line_begin=2 line_end=10}
    const offset = [];
    //TODO: will be more sophisticated when multi-vault
    // @ts-ignore
    const { content, matter } = common_server_1.readMD(fsPath);
    // the last --- isn't counted, shoud be +1
    // but since mpe is 0 delimited, it cancels each other out
    const fmOffset = matter.split("\n").length;
    // @ts-ignore
    const { lines } = extractBlock(content, link);
    // TODO: throw error
    if (!(lines === null || lines === void 0 ? void 0 : lines.start)) {
        return line;
    }
    // +1 because extract block does -1 for 0-indexing file
    // +1 because header block gets parsed form line before
    const pad = 2 + fmOffset;
    offset.push(`line_begin=${lines.start + pad}`);
    if (link.anchorEnd) {
        // everything up to header is counted here
        offset.push(`line_end=${lines.end + pad - 1}`);
    }
    prefix += ` {${offset.join(" ")}}`;
    return prefix;
};
function stripLocalOnlyTags(doc) {
    const re = new RegExp(/(?<raw>.+<!--LOCAL_ONLY_LINE-->)/);
    let matches;
    do {
        matches = doc.match(re);
        if (matches) {
            // @ts-ignore
            const { raw, body } = matches.groups;
            doc = doc.replace(raw, "");
        }
    } while (matches);
    return doc;
}
exports.stripLocalOnlyTags = stripLocalOnlyTags;
//# sourceMappingURL=utils.js.map