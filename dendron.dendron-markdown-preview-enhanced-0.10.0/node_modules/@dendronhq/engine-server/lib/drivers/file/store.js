"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = exports.FileStorageBase = exports.fileNameToTitle = void 0;
// @ts-ignore
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const parser_1 = require("./parser");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
function fileNameToTitle(name) {
    const ext = path_1.default.extname(name);
    return path_1.default.basename(name, ext);
}
exports.fileNameToTitle = fileNameToTitle;
// @ts-ignore
const CACHE_KEYS = {
    QUERY_ALL: "QUERY_ALL",
};
class FileStorageBase {
    constructor(opts) {
        this.opts = opts;
        this.idToPath = {};
        this.rootId = "";
        this.logger = opts.logger || common_server_1.createLogger("FileStore");
    }
    isRoot(id) {
        return id === "root";
    }
    async getRoot() {
        this.logger.debug({ ctx: "getRoot", rootId: this.rootId });
        return this.doGetFile(this.rootId);
    }
    async get(id, _opts) {
        let resp;
        this.logger.debug({ ctx: "get:presGetFile", id });
        if (this.isRoot(id)) {
            resp = await this.getRoot();
        }
        else {
            resp = this.doGetFile(id);
        }
        this.logger.debug({ ctx: "get:postGetFile" });
        return {
            data: resp,
        };
    }
}
exports.FileStorageBase = FileStorageBase;
class FileStorage extends FileStorageBase {
    files2Notes(fpaths) {
        const fp = new parser_1.FileParser(this, { errorOnEmpty: false });
        const data = fp.parse(fpaths);
        const errors = fp.errors;
        const badParseErrors = errors.filter((e) => e.status === "BAD_PARSE");
        if (!lodash_1.default.isEmpty(badParseErrors)) {
            throw Error(`bad yaml: ${badParseErrors}`);
        }
        return data.map((n) => n.toRawProps());
    }
    doGetFile(id) {
        const { root } = this.opts;
        const fpath = this.idToPath[id];
        common_all_1.assert(!lodash_1.default.isUndefined(fpath), `id ${id} should be in fpath`);
        const uri = path_1.default.join(root, `${fpath}.md`);
        return common_server_1.mdFile2NodeProps(uri);
    }
    async _getNoteAll() {
        const allFiles = common_server_1.getAllFiles({
            root: this.opts.root,
            include: ["*.md"],
        });
        return this.files2Notes(allFiles);
    }
    async _getSchemaAll() {
        const allFiles = common_server_1.getAllFiles({
            root: this.opts.root,
            include: ["*.schema.yml"],
        });
        const fp = new parser_1.FileParser(this, { errorOnEmpty: false });
        const data = fp.parseSchema(allFiles);
        return data;
    }
    _writeFile(node) {
        if (node.type === "schema") {
            return common_server_1.schema2YMLFile(node, { root: this.opts.root });
        }
        return common_server_1.node2MdFile(node, { root: this.opts.root });
    }
    isQueryAll(qs) {
        return qs === "**/*";
    }
    /**
     * Throws:
     *  - DendronError
     * @param id
     */
    // @CacheClear({ cacheKey: CACHE_KEYS.QUERY_ALL })
    async delete(id, opts) {
        if (id === this.rootId) {
            throw new common_all_1.IllegalOperationError("can't delete root");
        }
        const fpath = (opts === null || opts === void 0 ? void 0 : opts.fpath) ? opts.fpath : this.idToPath[id] + ".md";
        const uri = path_1.default.join(this.opts.root, fpath);
        common_server_1.deleteFile(uri);
        this.deleteFromIdToPath(id);
        return;
    }
    async query(queryString, mode, _opts) {
        if (mode === "schema") {
            if (this.isQueryAll(queryString)) {
                const schemaProps = await this._getSchemaAll();
                const data = new common_all_1.NodeBuilder().buildSchemaFromProps(schemaProps);
                // TODO
                // this.refreshIdToPath(data)
                this.logger.debug({ ctx: "query:exit:pre" });
                return common_all_1.makeResponse({ data, error: null });
            }
            throw Error(`unsupported ${queryString}`);
        }
        // mode === note
        if (this.isQueryAll(queryString)) {
            const schemas = (_opts === null || _opts === void 0 ? void 0 : _opts.schemas) || {};
            const noteProps = await this._getNoteAll();
            const data = new common_all_1.NodeBuilder().buildNoteFromProps(noteProps, {
                schemas: lodash_1.default.values(schemas),
            });
            this.refreshIdToPath(data);
            this.logger.debug({ ctx: "query:exit:pre" });
            return common_all_1.makeResponse({ data, error: null });
        }
        throw Error(`unsupported ${queryString}`);
    }
    deleteFromIdToPath(id) {
        delete this.idToPath[id];
    }
    refreshIdToPath(nodes) {
        if (nodes[0].type === "schema") {
            // null-op
            return;
        }
        nodes.forEach((n) => {
            this.idToPath[n.id] = n.path;
            if (n.title === "root") {
                this.rootId = n.id;
            }
        });
    }
    async write(node, opts) {
        opts = lodash_1.default.defaults(opts, {
            stub: false,
            recursive: false,
            writeStub: false,
        });
        if (opts.writeStub || (!opts.stub && !node.stub)) {
            await this._writeFile(node);
        }
        if (opts.writeStub || (!opts.stub && opts.recursive)) {
            await Promise.all(node.children.map((c) => this.write(c, opts)));
        }
        // FIXME:OPT: only do for new nodes
        this.updateNodes([node]);
        return;
    }
    /**
     * Add to storage cache
     * @param nodes
     */
    async updateNodes(nodes) {
        this.refreshIdToPath(nodes);
    }
}
exports.FileStorage = FileStorage;
exports.default = FileStorage;
//# sourceMappingURL=store.js.map