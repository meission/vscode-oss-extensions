"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileParser = exports.FileParserUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importStar(require("lodash"));
const path_1 = __importDefault(require("path"));
const yamljs_1 = __importDefault(require("yamljs"));
function getFileMeta(fpaths) {
    const metaDict = {};
    lodash_1.default.forEach(fpaths, (fpath) => {
        const { name } = path_1.default.parse(fpath);
        const lvl = name.split(".").length;
        if (!lodash_1.default.has(metaDict, lvl)) {
            metaDict[lvl] = [];
        }
        metaDict[lvl].push({ prefix: name, fpath });
    });
    return metaDict;
}
class FileParserUtils {
    static parseSchemaVersion1(schema, opts) {
        const { imports, schemas } = schema;
        const { fname, root } = opts;
        // const rawProps = [];
        let schemasFromImport = lodash_1.default.flatMap(imports, (ent) => {
            return FileParserUtils.parseSchemaFile(`${ent}.schema.yml`, { root });
        });
        schemasFromImport = schemasFromImport.map((ent) => {
            const domain = common_all_1.SchemaUtils.fname(ent.fname);
            // set pattern to old pattern or id
            ent.data.pattern = ent.data.pattern || ent.id;
            ent.id = `${domain}.${ent.id}`;
            ent.fname = fname;
            ent.parent = null;
            ent.children = ent.children.map((ent) => `${domain}.${ent}`);
            return ent;
        });
        const schemasFromFile = schemas.map((o) => common_all_1.Schema.createRawProps({ ...o, fname }));
        return schemasFromImport.concat(schemasFromFile);
    }
    static parseSchemaFile(fpath, opts) {
        const { root } = opts;
        const fname = path_1.default.parse(fpath).name;
        const schemaOpts = yamljs_1.default.parse(fs_extra_1.default.readFileSync(path_1.default.join(root, fpath), "utf8"));
        const version = lodash_1.default.isArray(schemaOpts) ? 0 : 1;
        if (version === 1) {
            return FileParserUtils.parseSchemaVersion1(schemaOpts, { fname, root });
        }
        const schemaProps = schemaOpts.map((o) => common_all_1.Schema.createRawProps({ ...o, fname }));
        return schemaProps;
    }
}
exports.FileParserUtils = FileParserUtils;
class FileParser {
    constructor(store, opts) {
        this.errors = [];
        this.missing = new Set();
        this.opts = lodash_1.default.defaults(opts, {
            errorOnEmpty: true,
            errorOnBadParse: true,
            logger: common_server_1.createLogger("FileParser"),
        });
        this.logger = this.opts.logger;
        this.store = store;
    }
    toNode(ent, parents, store, opts) {
        opts = lodash_1.default.defaults(opts, {
            errorOnEmpty: true,
            isRoot: false,
            errorOnBadParse: true,
        });
        // DEBUG: noteProps: {noteProps}
        // TODO: handle errors
        let noteProps;
        try {
            noteProps = common_server_1.mdFile2NodeProps(path_1.default.join(store.opts.root, ent.fpath));
        }
        catch (err) {
            this.logger.error({ ctx: "toNode", ent, opts, err });
            if (opts.errorOnBadParse) {
                throw err;
            }
            else {
                const errorMsg = {
                    status: "BAD_PARSE",
                    ent,
                    err,
                };
                this.errors.push(errorMsg);
                return { node: null, missing: null };
            }
        }
        // OPT
        //logger.debug({ ctx: "toNode:mdFile2NodeProps:post", noteProps })
        // let parent: Note | null;
        let parentPath = null;
        let missing = null;
        // if (_.isNull(noteProps.parent)) {
        parentPath = common_all_1.DNodeUtils.dirName(ent.prefix);
        const parent = lodash_1.default.find(parents, (p) => p.path === parentPath) || null;
        // } else {
        //   parent = _.find(parents, p => p.id === noteProps.parent) || null;
        // }
        // error checking
        if (!parent && !opts.isRoot) {
            const errorMsg = {
                status: "NO_PARENT_PATH",
                ent,
                parentPath,
            };
            this.errors.push(errorMsg);
            // should not be the case
            // if (!parentPath) {
            //   throw Error(`no parent path found for ${JSON.stringify(errorMsg)}`);
            // }
            missing = parentPath;
            if (opts.errorOnEmpty) {
                throw new Error(JSON.stringify(errorMsg));
            }
        }
        // children not looked at when parsing since we build iteratively based on parent
        const note = new common_all_1.Note({ ...noteProps, parent, children: [] });
        if (parent) {
            parent.addChild(note);
        }
        // OPT
        //logger.debug({ ctx: "toNode:exit", note: note.toRawProps(), missing })
        return { node: note, missing };
    }
    parseSchema(data) {
        if (lodash_1.default.isEmpty(data)) {
            return [];
        }
        return data
            .map((fpath) => FileParserUtils.parseSchemaFile(fpath, { root: this.store.opts.root }))
            .flat();
    }
    /**
     * Returns list of notes withou parent/child information
     * @param data
     */
    parse(data) {
        if (lodash_1.default.isEmpty(data)) {
            return [];
        }
        // used to reconstruct missing notes
        const nodesStoreByFname = {};
        const store = this.store;
        const fileMetaDict = getFileMeta(data);
        const maxLvl = lodash_1.default.max(lodash_1.default.keys(fileMetaDict).map((e) => lodash_1.toInteger(e))) || 2;
        const root = fileMetaDict[1].find((n) => n.fpath === "root.md");
        if (!root) {
            return [];
        }
        const { node: rootNode } = this.toNode(root, [], store, {
            isRoot: true,
            errorOnBadParse: this.opts.errorOnBadParse,
        });
        nodesStoreByFname["root"] = rootNode;
        // domain root
        let lvl = 2;
        let prevNodes = fileMetaDict[1]
            // don't count root node, handle separately
            .filter((n) => n.fpath !== "root.md")
            .map((ent) => {
            const { node } = this.toNode(ent, [], store, {
                isRoot: true,
            });
            return node;
        });
        prevNodes.forEach((n) => {
            rootNode.addChild(n);
            nodesStoreByFname[n.fname] = n;
        });
        // domain root children
        while (lvl <= maxLvl) {
            const currNodes = (fileMetaDict[lvl] || [])
                // eslint-disable-next-line no-loop-func
                .map((ent) => {
                // ignore root.schema and other such files
                if (common_server_1.globMatch(["root.*"], ent.fpath)) {
                    return null;
                }
                const { node, missing } = this.toNode(ent, prevNodes, store, {
                    errorOnEmpty: this.opts.errorOnEmpty,
                    errorOnBadParse: this.opts.errorOnBadParse,
                });
                if (missing) {
                    const closetParent = common_all_1.DNodeUtils.findClosestParent(node.logicalPath, nodesStoreByFname);
                    const stubNodes = common_all_1.NoteUtils.createStubNotes(closetParent, node);
                    stubNodes.forEach((ent2) => {
                        nodesStoreByFname[ent2.fname] = ent2;
                    });
                    // TODO: add stub nodes to dict and return dict
                    this.missing.add(missing);
                }
                return node;
            })
                .filter(Boolean);
            lvl += 1;
            currNodes.forEach((n) => {
                nodesStoreByFname[n.fname] = n;
            });
            // TODO: remove
            prevNodes = currNodes;
        }
        return lodash_1.default.values(nodesStoreByFname);
    }
    report() {
        const { errors, missing } = this;
        return {
            numErrors: errors.length,
            errors,
            missing: Array.from(missing),
        };
    }
}
exports.FileParser = FileParser;
//# sourceMappingURL=parser.js.map