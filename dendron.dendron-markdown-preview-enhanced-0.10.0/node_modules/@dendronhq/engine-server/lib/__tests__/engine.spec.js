"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const engine_1 = require("../engine");
function expectNoteProps(expect, note, expectedProps) {
    const propsToCheck = ["fname"].concat(lodash_1.default.keys(expectedProps));
    expect(lodash_1.default.pick(note, propsToCheck)).toEqual(expectedProps);
}
function stripEntropicData(ent) {
    return lodash_1.default.omit(ent, ["created", "updated"]);
}
describe("engine:exact", () => {
    let root;
    const queryMode = "note";
    let actualFiles;
    let expectedFiles;
    let engine;
    describe("schema", () => {
        describe("basic", () => {
            beforeEach(() => {
                root = common_server_1.EngineTestUtils.setupStoreDir();
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
            });
            afterEach(() => {
                expect(actualFiles).toEqual(expectedFiles);
                fs_extra_1.default.removeSync(root);
            });
            test("init", async () => {
                await engine.init();
                const schemas = lodash_1.default.values(engine.schemas);
                common_all_1.testUtils.expectSnapshot(expect, "main", schemas);
                expect(schemas.length).toEqual(4);
                const note = engine.notes["foo"];
                const schema = engine.schemas["foo"];
                const barSchema = engine.schemas["bar"];
                const schemaMatch = common_all_1.SchemaUtils.matchNote(note, engine.schemas);
                expect(schemaMatch.toRawProps()).toEqual(schema.toRawProps());
                const schemaNamespace = engine.schemas["bar"];
                expect(schemaNamespace.namespace).toBeTruthy();
                // check that children with same id are still unique
                const fooOneChild = lodash_1.default.find(schema.children, { id: "one" });
                expect(fooOneChild.fname).toEqual("foo.schema");
                const barOneChild = lodash_1.default.find(barSchema.children, { id: "one" });
                expect(barOneChild.fname).toEqual("bar.schema");
                expect(common_all_1.testUtils.omitEntropicProps(fooOneChild.toRawProps(), true)).toMatchSnapshot("bond");
                // // case3
                // schema = engine.schemas["test1"];
                // expect(schema.children[0].id).toEqual("test1-1-1");
            });
            test("add node with schema", async () => {
                await engine.init();
                await engine.write(new common_all_1.Note({ id: "bar.ns.one.alpha", fname: "bar.ns.one.alpha" }), { newNode: true, parentsAsStubs: true });
                const note = engine.notes["bar.ns.one.alpha"];
                const schemaDomain = engine.schemas["bar"];
                const schema = lodash_1.default.find(schemaDomain.nodes, { id: "alpha" });
                const schemaMatch = common_all_1.SchemaUtils.matchNote(note, engine.schemas);
                expect(schemaMatch).toEqual(schema);
            });
            test("write schema", async () => {
                await engine.init();
                const schema = new common_all_1.Schema({ fname: "bond" });
                await engine.write(schema, {
                    newNode: true,
                    parentsAsStubs: true,
                });
                const schemaInEngine = engine.schemas["bond"];
                common_all_1.testUtils.expectSnapshot(expect, "schema", schemaInEngine);
                expect(fs_extra_1.default.readFileSync(path_1.default.join(root, "bond.schema.yml"), "utf8")).toMatchSnapshot("bond.schema");
                expect(lodash_1.default.pick(schemaInEngine.toRawProps(), [
                    "id",
                    "title",
                    "fname",
                    "parent",
                    "children",
                ])).toEqual({
                    id: "bond",
                    title: "bond",
                    fname: "bond.schema",
                    parent: "root",
                    children: [],
                });
            });
            test("delete schema", async () => {
                await engine.init();
                const numNodesPre = lodash_1.default.values(engine.schemas).length;
                const fooNode = await engine.queryOne("foo", "schema");
                await engine.delete(fooNode.data.id, "schema");
                expect(lodash_1.default.values(engine.schemas).length).toEqual(numNodesPre - 1);
                // TODO: check for files
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    remove: ["foo.schema.yml"],
                });
            });
        });
        describe("import", () => {
            beforeEach(() => {
                root = common_server_1.EngineTestUtils.setupStoreDir({
                    storeDirSrc: "engine-server.parser",
                });
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
            });
            afterEach(() => {
                expect(actualFiles).toEqual(expectedFiles);
                fs_extra_1.default.removeSync(root);
            });
            test("basic", async () => {
                await engine.init();
                await engine.write(new common_all_1.Note({ id: "foo.bar.id", fname: "foo.bar" }), {
                    newNode: true,
                    parentsAsStubs: true,
                });
                // expect(_.map(engine.schemas, s => s.toRawPropsRecursive())).toMatchSnapshot("bond");
                const note = engine.notes["foo.bar.id"];
                const schemaDomain = engine.schemas["foo"];
                const schemaMatch = common_all_1.SchemaUtils.matchNote(note, engine.schemas);
                const schema = lodash_1.default.find(schemaDomain.nodes, { id: "bar.bar" });
                expect(schemaMatch).toEqual(schema);
            });
            test("double import", async () => {
                await engine.init();
                await engine.write(new common_all_1.Note({ id: "foo.baz.bar.id", fname: "foo.baz.bar" }), { newNode: true, parentsAsStubs: true });
                const note = engine.notes["foo.baz.bar.id"];
                const schemaDomain = engine.schemas["foo"];
                const schemaMatch = common_all_1.SchemaUtils.matchNote(note, engine.schemas);
                const schema = lodash_1.default.find(schemaDomain.nodes, {
                    id: "baz.bar.bar",
                });
                expect(schemaMatch).toEqual(schema);
            });
            test("import and namespace", async () => {
                await engine.init();
                await engine.write(new common_all_1.Note({ id: "foo.baz.ns.one.id", fname: "foo.baz.ns.one" }), { newNode: true, parentsAsStubs: true });
                const note = engine.notes["foo.baz.ns.one.id"];
                const schemaDomain = engine.schemas["foo"];
                const schemaMatch = common_all_1.SchemaUtils.matchNote(note, engine.schemas);
                const schema = lodash_1.default.find(schemaDomain.nodes, {
                    id: "baz.ns",
                });
                expect(schemaMatch.toRawProps()).toEqual(schema.toRawProps());
            });
        });
    });
    describe("note", () => {
        beforeEach(() => {
            root = common_server_1.EngineTestUtils.setupStoreDir();
            engine = engine_1.DendronEngine.getOrCreateEngine({
                root,
                forceNew: true,
                mode: "exact",
            });
        });
        afterEach(() => {
            // expect(actualFiles).toEqual(expectedFiles);
            fs_extra_1.default.removeSync(root);
        });
        describe("basic", () => {
            test("create when empty", async () => {
                var _a, _b, _c;
                fs_extra_1.default.removeSync(root);
                root = common_server_1.EngineTestUtils.setupStoreDir({ copyFixtures: true });
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                let schema = engine.schemas["foo"];
                let note = engine.notes["foo"];
                common_all_1.testUtils.expectSnapshot(expect, "foo", note);
                expect(schema.toRawProps()).toEqual((_a = note.schema) === null || _a === void 0 ? void 0 : _a.toRawProps());
                schema = lodash_1.default.find(schema.children, { id: "one" });
                note = engine.notes["foo.one"];
                expect(schema.toRawProps()).toEqual((_b = note.schema) === null || _b === void 0 ? void 0 : _b.toRawProps());
                schema = common_all_1.Schema.createUnkownSchema();
                note = engine.notes["foo.three.alpha"];
                expect(schema.toRawProps()).toEqual((_c = note.schema) === null || _c === void 0 ? void 0 : _c.toRawProps());
                // testUtilsCommonAll.expectSnapshot(
                //   expect,
                //   "notes",
                //   _.values(engine.notes)
                // );
                // testUtilsCommonAll.expectSnapshot(
                //   expect,
                //   "schemas",
                //   _.values(engine.schemas)
                // );
                // const { content, data } = FileTestUtils.readMDFile(root, "root.md");
                // expect(content).toMatchSnapshot("notes-root-content");
                // expect(
                //   testUtilsCommonAll.omitEntropicProps(data as DNodeRawProps)
                // ).toMatchSnapshot("notes-root-data");
                // [expectedFiles, actualFiles] = FileTestUtils.cmpFiles(
                //   root,
                //   ["root.md"],
                //   {}
                // );
            });
            test("create node", async () => {
                await engine.init();
                const bazNote = new common_all_1.Note({ id: "baz", fname: "baz" });
                bazNote.body = "baz.body";
                await engine.write(bazNote, { newNode: true });
                const baz = await engine.queryOne("baz", "note");
                // FIXME: the ids change, need a better way to test
                let bazMd = common_server_1.FileTestUtils.readMDFile(root, "baz.md");
                bazMd.data = stripEntropicData(bazMd.data);
                // @ts-ignore
                bazMd = lodash_1.default.omit(bazMd, ["path"]);
                expect(bazMd).toMatchSnapshot("bazMd");
                expect(stripEntropicData(baz.data.toRawProps())).toMatchSnapshot("bazNode");
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), { add: ["baz.md"] });
            });
            test("fetch node", async () => {
                await engine.init();
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                // foo should be fully specified
                const resp = await engine.query("foo", queryMode);
                expect(resp.data[0].title).toEqual("foo");
                expect(resp.data[0].created).toEqual(123);
                expect(resp.data[0].updated).toEqual(456);
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
            test("fetch node with custom att", async () => {
                await engine.init();
                const resp = await engine.query("foo.one", queryMode);
                expect(resp.data[0].title).toEqual("foo.one");
                expect(resp.data[0].custom).toEqual({ bond: 42 });
                expect(resp.data[0].toRawProps()).toMatchSnapshot();
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
            test("write node with custom att", async () => {
                await engine.init();
                const note = (await engine.query("foo.one", queryMode))
                    .data[0];
                note.body = "foo.one.body";
                await engine.write(note);
                // check written note is still equal
                const noteUpdated = (await engine.query("foo.one", queryMode))
                    .data[0];
                expect(lodash_1.default.omit(note.toRawProps(), "body")).toEqual(lodash_1.default.omit(noteUpdated.toRawProps(), "body"));
                expect(lodash_1.default.trim(noteUpdated.body)).toEqual("foo.one.body");
                // check custom att is in file
                const { data } = common_server_1.FileTestUtils.readMDFile(root, "foo.one.md");
                expect(stripEntropicData(data)).toEqual({
                    bond: 42,
                    desc: "",
                    id: "foo.one",
                    title: "foo.one",
                    stub: false,
                });
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
            test("add custom att to node", async () => {
                await engine.init();
                const note = (await engine.query("foo", queryMode))
                    .data[0];
                // add custom att
                note.custom.bond = true;
                await engine.write(note);
                const noteUpdated = (await engine.query("foo", queryMode))
                    .data[0];
                // check note has custom att
                expect(lodash_1.default.omit(note.toRawProps(), "body")).toEqual(lodash_1.default.omit(noteUpdated.toRawProps(), "body"));
                // check custom att in file
                const { data } = common_server_1.FileTestUtils.readMDFile(root, "foo.md");
                expect(stripEntropicData(data)).toEqual({
                    bond: true,
                    desc: "",
                    id: "foo",
                    title: "foo",
                    stub: false,
                });
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
            test("node has same attributes when re-initializing engine", async () => {
                await engine.init();
                const root1 = engine.notes.foo;
                const engine2 = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine2.init();
                const root2 = engine2.notes.foo;
                // TODO: don't omit when we fix stub nodes
                const [root1Raw, root2Raw] = lodash_1.default.map([root1.toRawProps(), root2.toRawProps()], (ent) => lodash_1.default.omit(ent, "children"));
                expect(root1Raw).toEqual(root2Raw);
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
            test("updateNode", async () => {
                await engine.init();
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                const bazNote = new common_all_1.Note({ fname: "baz" });
                // foo should be fully specified
                await engine.updateNodes([bazNote], {
                    newNode: true,
                    parentsAsStubs: true,
                });
                const baz = await engine.queryOne("baz", "note");
                expect(common_all_1.testUtils.omitEntropicProps(baz.data.toRawProps())).toMatchSnapshot("bazNote");
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore());
            });
        });
        describe("main", () => {
            test("open stub node", async () => {
                common_server_1.FileTestUtils.writeMDFile(root, "bar.two.md", {}, "bar.two.body");
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDir");
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                const resp = engine.query("bar.two", queryMode);
                expect((await resp).data[0].fname).toEqual("bar.two");
                const resp2 = engine.query("bar", queryMode);
                expect((await resp2).data[0].fname).toEqual("bar");
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDir2");
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    add: ["bar.two.md"],
                });
            });
            test("delete node with no children", async () => {
                await engine.init();
                const numNodesPre = lodash_1.default.values(engine.notes).length;
                const fooNode = await engine.queryOne("foo.one", "note");
                await engine.delete(fooNode.data.id, "note");
                // should be less nodes
                expect(numNodesPre - 1).toEqual(lodash_1.default.values(engine.notes).length);
                const resp = await engine.query("foo", "note");
                // start of with three foo nodes, end up with two
                expect(resp.data.length).toEqual(4);
                // file should not be there
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    remove: ["foo.one.md"],
                });
            });
            test("delete node with children", async () => {
                await engine.init();
                const fooNode = await engine.queryOne("foo", "note");
                // delete foo
                await engine.delete(fooNode.data.id, "note");
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDi2");
                const numNodesPre = lodash_1.default.values(engine.notes).length;
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                // because foo has children, exepect it to still exist as a stub
                const deletedNode = engine.notes[fooNode.data.id];
                expectNoteProps(expect, deletedNode, { fname: "foo", stub: true });
                // size should be the same
                expect(numNodesPre).toEqual(lodash_1.default.values(engine.notes).length);
                common_all_1.testUtils.expectSnapshot(expect, "main2", lodash_1.default.values(engine.notes));
                // foo file should be deleted
                [expectedFiles, actualFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    remove: ["foo.md"],
                });
            });
        });
        describe("edge", () => {
            test("md exist, no schema file", async () => {
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "foo.schema.yml"));
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDir");
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                const resp = engine.query("root", "schema");
                expect((await resp).data[0].fname).toEqual("root.schema");
                [actualFiles, expectedFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    add: [],
                    remove: ["foo.schema.yml"],
                });
            });
            test("no md file, schema exist", async () => {
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "root.md"));
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDir");
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                const fooNote = (await engine.query("foo", "note")).data[0];
                expect(fooNote.fname).toEqual("foo");
                common_all_1.testUtils.expectSnapshot(expect, "fooNote", fooNote);
                [actualFiles, expectedFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {});
            });
            test("no md file, no schema ", async () => {
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "foo.schema.yml"));
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "root.md"));
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                expect(fs_extra_1.default.readdirSync(root)).toMatchSnapshot("listDir");
                common_all_1.testUtils.expectSnapshot(expect, "main", lodash_1.default.values(engine.notes));
                const resp = engine.query("root", "note");
                expect((await resp).data[0].fname).toEqual("root");
                [actualFiles, expectedFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {
                    add: [],
                    remove: ["foo.schema.yml"],
                });
            });
            test("note without id", async () => {
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "foo.md"));
                common_server_1.FileTestUtils.writeMDFile(root, "foo.md", {}, "this is foo");
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                [actualFiles, expectedFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {});
                const fooNote = (await engine.query("foo", "note")).data[0];
                expect(fooNote.fname).toEqual("foo");
                common_all_1.testUtils.expectSnapshot(expect, "fooNote", fooNote);
            });
            test("note without fm", async () => {
                fs_extra_1.default.unlinkSync(path_1.default.join(root, "foo.md"));
                fs_extra_1.default.writeFileSync(path_1.default.join(root, "foo.md"), "this is foo");
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                const fooNote = (await engine.query("foo", "note")).data[0];
                expect(fooNote.fname).toEqual("foo");
                common_all_1.testUtils.expectSnapshot(expect, "fooNote", fooNote);
                [actualFiles, expectedFiles] = common_server_1.FileTestUtils.cmpFiles(root, common_server_1.LernaTestUtils.fixtureFilesForStore(), {});
            });
            test("one note without domain", async () => {
                root = common_server_1.EngineTestUtils.setupStoreDir({ copyFixtures: false });
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                common_server_1.FileTestUtils.writeMDFile(root, "root.md", { id: "root" }, "root");
                const fname = "backlog.journal.2020";
                common_server_1.FileTestUtils.writeMDFile(root, fname + ".md", { id: "backlog" }, "backlog");
                await engine.init();
                const note = new common_all_1.Note({ id: "backlog", fname });
                const [t1, t2] = lodash_1.default.map([engine.notes["backlog"], note], (n) => {
                    return common_all_1.testUtils.omitEntropicProps(n.toRawProps(true, { ignoreNullParent: true }));
                });
                expect(t1).toEqual(t2);
            });
            test("queryOne on existing stub node", async () => {
                root = common_server_1.EngineTestUtils.setupStoreDir({ copyFixtures: false });
                common_server_1.node2MdFile(new common_all_1.Note({ fname: "foo" }), { root });
                common_server_1.node2MdFile(new common_all_1.Note({ fname: "foo.one.alpha" }), { root });
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                const stubNode = common_all_1.DNodeUtils.getNoteByFname("foo.one", engine);
                expect(stubNode.stub).toBeTruthy();
                const resp = await engine.queryOne("foo.one", "note", {
                    createIfNew: true,
                });
                const createdNode = resp.data;
                // expect(stubNode.toRawProps()).toMatchSnapshot("stub");
                // expect(createdNode.toRawProps()).toMatchSnapshot("created");
                expect(stubNode.id).toEqual(createdNode.id);
                expect(createdNode.stub).toBeFalsy();
            });
            test("note with time stamp as title", async () => {
                root = common_server_1.EngineTestUtils.setupStoreDir({ copyFixtures: false });
                fs_extra_1.default.writeFileSync(path_1.default.join(root, "root.md"), "---\nid: root\ntitle: root\n---", { encoding: "utf8" });
                fs_extra_1.default.writeFileSync(path_1.default.join(root, "foo.md"), "---\ntitle: 2020-08-01\n---", { encoding: "utf8" });
                engine = engine_1.DendronEngine.getOrCreateEngine({
                    root,
                    forceNew: true,
                    mode: "exact",
                });
                await engine.init();
                const node = common_all_1.DNodeUtils.getNoteByFname("foo", engine);
                expect(node.title).toEqual("2020-08-01");
            });
        });
    });
});
//# sourceMappingURL=engine.spec.js.map