"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const lodash_1 = __importDefault(require("lodash"));
const src_1 = require("@dendronhq/common-server/src");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
function createFileLink(opts) {
    return {
        name: "foo",
        type: "file",
        ...opts,
    };
}
describe("matchEmbedMarker", () => {
    test("basic", () => {
        // @ts-ignore
        expect(utils_1.matchRefMarker("<!--(([[class.mba.chapters.2]]))-->")[1]).toEqual("[[class.mba.chapters.2]]");
    });
});
describe("parseFileLink", () => {
    it("just file", () => {
        expect(utils_1.parseFileLink("[[foo]]")).toEqual({
            name: "foo",
            type: "file",
        });
    });
    it("one anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1")).toEqual({
            name: "foo",
            anchorStart: "head1",
            type: "file",
        });
    });
    it("all parts", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#head2")).toEqual({
            anchorEnd: "head2",
            anchorStart: "head1",
            name: "foo",
            type: "file",
        });
    });
    it("next anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#*")).toEqual({
            anchorEnd: "*",
            anchorStart: "head1",
            name: "foo",
            type: "file",
        });
    });
});
describe("link2String", () => {
    test("file", () => {
        expect(utils_1.refLink2String({
            name: "foo",
            type: "file",
        })).toEqual("[[foo]]");
    });
    it("one anchor", () => {
        expect(utils_1.refLink2String({
            name: "foo",
            anchorStart: "head1",
            type: "file",
        })).toEqual("[[foo]]#head1");
    });
    it("all parts", () => {
        expect(utils_1.refLink2String({
            anchorEnd: "head2",
            anchorStart: "head1",
            name: "foo",
            type: "file",
        })).toEqual("[[foo]]#head1:#head2");
    });
    it("next anchor", () => {
        expect(utils_1.refLink2String({
            anchorEnd: "*",
            anchorStart: "head1",
            name: "foo",
            type: "file",
        })).toEqual("[[foo]]#head1:#*");
    });
});
describe("parseRef", () => {
    it("describe file ref without extension", () => {
        expect(utils_1.parseDendronRef("ref: [[foo]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref with anchor", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1" }),
        });
    });
    it("describe file ref with anchor start and end", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1", anchorEnd: "head2" }),
        });
    });
    it("describe file ref with anchor start and end, start offset", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1,1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({
                anchorStart: "head1",
                anchorEnd: "head2",
                anchorStartOffset: 1,
            }),
        });
    });
});
const FILE_TEXT = `
# Head 1

Head 1 Text

## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text

## Head 2.2

Head 2.2 Text`;
describe("extractBlock", () => {
    it("no anchor", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink()).block).toEqual(FILE_TEXT);
    });
    it("anchor start", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink({
            anchorStart: "Head 2.1",
        })).block).toEqual(lodash_1.default.trim(`
## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text

## Head 2.2

Head 2.2 Text`));
    });
    it("anchor start alt", () => {
        const txt = ["", `# Tasks`, "task1", "task2"];
        expect(utils_1.extractBlock(txt.join("\n"), createFileLink({
            anchorStart: "Tasks",
        })).block).toEqual(lodash_1.default.trim(txt.join("\n")));
    });
    it("anchor stard and end", () => {
        expect(utils_1.extractBlock(FILE_TEXT, createFileLink({
            anchorStart: "Head 2.1",
            anchorEnd: "Head 2.2",
        })).block).toEqual(lodash_1.default.trim(`
## Head 2.1

Head 2.1 Text

### Head 2.1.1

Head 2.1.1 Text`));
    });
});
describe("replaceRefWithMPEImport", () => {
    let root;
    beforeEach(async () => {
        root = await src_1.EngineTestUtils.setupStoreDir({ copyFixtures: true });
    });
    it("basic", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[foo]]))", {
            root,
        })).toEqual('@import "foo.md"');
    });
    it("anchor start", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[ref]]#head2.1))", {
            root,
        })).toEqual('@import "ref.md" {line_begin=10}');
    });
    it.skip("anchor start alt", async () => {
        const txt = ["", `# Tasks`, "task1", "task2"];
        root = src_1.EngineTestUtils.setupStoreDir({
            initDirCb: (dirPath) => {
                fs_extra_1.default.writeFileSync(path_1.default.join(dirPath, "daily.tasks.md"), txt.join("\n"), {
                    encoding: "utf8",
                });
            },
        });
        expect(utils_1.replaceRefWithMPEImport("((ref:[[daily.tasks]]#Tasks))", {
            root,
        })).toEqual('@import "daily.task.md" {line_begin=1}');
    });
    it("anchor start and end", () => {
        expect(utils_1.replaceRefWithMPEImport("((ref:[[ref]]#head2.1:#head2.3))", {
            root,
        })).toEqual('@import "ref.md" {line_begin=10 line_end=18}');
    });
});
describe("stripLocalOnlyTags", () => {
    it("basic", () => {
        const txt = `
- this is a bullet
    - this is a secret <!--LOCAL_ONLY_LINE-->
`;
        expect(lodash_1.default.trim(utils_1.stripLocalOnlyTags(txt))).toEqual("- this is a bullet");
    });
});
//# sourceMappingURL=utils.spec.js.map