"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DendronEngine = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const fuse_js_1 = __importDefault(require("fuse.js"));
const lodash_1 = __importDefault(require("lodash"));
const store_1 = __importDefault(require("./drivers/file/store"));
let _DENDRON_ENGINE;
function isAllQuery(qs) {
    return qs === "**/*";
}
function createFuse(initList, opts) {
    const options = {
        shouldSort: true,
        threshold: opts.exactMatch ? 0.0 : 0.6,
        location: 0,
        distance: 100,
        maxPatternLength: 32,
        minMatchCharLength: 1,
        keys: ["title", "logicalPath", "basename"],
        useExtendedSearch: true,
    };
    if (opts.preset === "schema") {
        options.keys = ["title", "id"];
    }
    const fuse = new fuse_js_1.default(initList, options);
    return fuse;
}
class DendronEngine {
    constructor(store, props) {
        // eslint-disable-next-line spaced-comment
        //this.nodes = store.fetchInitial();
        this.notes = {};
        this.initialized = false;
        this.props = props;
        this.store = store;
        this.fuse = createFuse([], {
            exactMatch: this.props.mode === "exact",
            preset: "note",
        });
        this.fullNodes = new Set();
        this.queries = new Set();
        // @ts-ignore
        this.logger = props.logger;
        // setup schemas
        this.schemas = {};
        this.schemaFuse = createFuse([], {
            exactMatch: this.props.mode === "exact",
            preset: "schema",
        });
        [props.root].forEach((fpath) => {
            if (!fs_extra_1.default.existsSync(fpath)) {
                throw Error(`${fpath} doesn't exist`);
            }
        });
    }
    static getOrCreateEngine(opts) {
        const ctx = "getOrCreateEngine";
        if (opts) {
            const root = opts.root;
            const optsClean = lodash_1.default.defaults(opts || {}, {
                forceNew: false,
                store: new store_1.default({ root, logger: opts === null || opts === void 0 ? void 0 : opts.logger }),
                root,
                mode: "fuzzy",
                logger: common_server_1.createLogger("DEngine"),
            });
            if (!_DENDRON_ENGINE || optsClean.forceNew) {
                if (lodash_1.default.isUndefined(optsClean.root)) {
                    throw Error(`root must be defined`);
                }
                optsClean.logger.info({ ctx, msg: "create new engine" });
                // TODO
                _DENDRON_ENGINE = new DendronEngine(optsClean.store, optsClean);
            }
        }
        if (!_DENDRON_ENGINE) {
            throw Error("dendron engine not initialized");
        }
        return _DENDRON_ENGINE;
    }
    _createRoot(mode) {
        if (mode === "schema") {
            const schema = common_all_1.Schema.createRoot();
            return schema;
        }
        else {
            const note = common_all_1.Note.createRoot();
            return note;
        }
    }
    async init() {
        await this.query("**/*", "schema", {
            fullNode: false,
            initialQuery: true,
        });
        await this.query("**/*", "note", {
            fullNode: false,
            initialQuery: true,
        });
        this.initialized = true;
        return;
    }
    /**
     * Does the following
     *  - remove from search index
     *  - remove from `notes` dict
     *  - remove from `fullNodes` dict
     * @param id
     * @param mode
     */
    deleteFromNodes(id, mode) {
        if (mode === "note") {
            this.fuse.remove((doc) => {
                // FIXME: can be undefined, dunno why
                if (!doc) {
                    return false;
                }
                return doc.id === id;
            });
            delete this.notes[id];
            this.fullNodes.delete(id);
        }
        else {
            this.schemaFuse.remove((doc) => {
                if (!doc) {
                    return false;
                }
                // FIXME: should be deleting all children as well
                return doc.id === id;
            });
            // FIXME: should be deleting all children as well
            delete this.schemas[id];
        }
    }
    /**
     * Updates local cache
     * - if node is new, add it to cache
     * - if not new, update existing node properties
     * - extra:
     *   - if full node, add id
     * @param nodes
     * @param opts
     */
    async refreshNodes(nodes, opts) {
        if (lodash_1.default.isEmpty(nodes)) {
            return;
        }
        const mode = nodes[0].type;
        if (mode === "schema") {
            const schemas = nodes;
            schemas.forEach((node) => {
                this.schemas[node.id] = node;
            });
            this.updateLocalCollection(lodash_1.default.values(this.schemas), "schema");
            return;
        }
        else {
            nodes.forEach((node) => {
                const { id } = node;
                if (!lodash_1.default.has(this.notes, id)) {
                    // add if not exist
                    // TODO: nodes has both raw and full nodes
                    // @ts-ignore
                    this.notes[id] = node;
                }
                else {
                    // exists, merge it
                    this.logger.debug({
                        ctx: "refreshNodes:existingNode",
                        node: node.toRawProps(true),
                    });
                    lodash_1.default.merge(this.notes[id], node);
                }
                // if a full node, make sure to add
                if (opts === null || opts === void 0 ? void 0 : opts.fullNode) {
                    this.fullNodes.add(id);
                }
            });
            this.updateLocalCollection(lodash_1.default.values(this.notes), "note");
            await this.store.updateNodes(nodes);
            return;
        }
    }
    /**
     * Turn parent|children ids to full nodes
     */
    async resolveIds(node, dict) {
        const nodeResolved = dict[node.id];
        common_all_1.assert(!lodash_1.default.isUndefined(nodeResolved), `node ${JSON.stringify(node)} not in dict\nkeys: ${lodash_1.default.keys(dict)}`);
        nodeResolved.body = node.body;
        return new common_all_1.Note({ ...nodeResolved });
    }
    updateLocalCollection(collection, mode) {
        if (mode === "schema") {
            return this.schemaFuse.setCollection(collection);
        }
        else {
            return this.fuse.setCollection(collection);
        }
    }
    async delete(idOrFname, mode, opts) {
        const ctx = "delete";
        const cleanOpts = lodash_1.default.defaults(opts, { metaOnly: false });
        let noteToDelete;
        this.logger.info({ ctx, idOrFname });
        if (mode === "note") {
            noteToDelete = this.notes[idOrFname];
            if (lodash_1.default.isUndefined(noteToDelete)) {
                const fname = common_all_1.DNodeUtils.basename(idOrFname, false);
                // NOTE: get around ts issues
                const tmp = lodash_1.default.find(this.notes, { fname });
                if (lodash_1.default.isUndefined(tmp)) {
                    const msg = `node ${idOrFname} not found`;
                    this.logger.error({ ctx, msg });
                    throw Error(msg);
                }
                noteToDelete = tmp;
            }
        }
        else {
            // TODO: only support fname
            noteToDelete = this.schemas[idOrFname];
        }
        const { id } = noteToDelete;
        if (!cleanOpts.metaOnly) {
            const storeOpts = mode === "schema" ? { fpath: noteToDelete.fname + ".yml" } : {};
            await this.store.delete(id, storeOpts);
        }
        this.deleteFromNodes(id, mode);
        if (mode === "note") {
            // if have children, keep this note as a stub
            if (!lodash_1.default.isEmpty(noteToDelete.children)) {
                this.logger.info({ ctx, idOrFname, msg: "keep as stub" });
                noteToDelete.stub = true;
                this.refreshNodes([noteToDelete]);
            }
            else {
                this.logger.info({ ctx, idOrFname, msg: "delete from parent" });
                // no more children, delete from parent
                if (noteToDelete.parent) {
                    noteToDelete.parent.children = lodash_1.default.reject(noteToDelete.parent.children, { id: noteToDelete.id });
                }
            }
        }
        this.logger.info({ ctx, idOrFname, msg: "exit" });
        return;
    }
    /**
     * Defaults
     * @param id
     * @param opts
     *  - fullNode: {default:true}
     */
    async get(id, mode, opts) {
        opts = lodash_1.default.defaults(opts || {}, { fullNode: true, createIfNew: true });
        let nodeDict;
        this.logger.debug({ ctx: "get", id, opts });
        if (mode === "schema") {
            nodeDict = this.schemas;
            const node = nodeDict[id];
            return { data: node };
        }
        //FIXME: check if exist
        // we are assuming all nodes are fetched
        const node = this.notes[id];
        // a full node has a body and is fully resolved
        if ((opts === null || opts === void 0 ? void 0 : opts.fullNode) && !this.fullNodes.has(id)) {
            this.logger.debug({ ctx: "get:fetchFromStore:pre", id });
            const fnResp = await this.store.get(id, {
                ...opts,
                webClient: true,
            });
            const fullNode = await this.resolveIds(fnResp.data, this.notes);
            // TODO:
            this.refreshNodes([fullNode], opts);
            return { data: fullNode };
        }
        return { data: node };
    }
    async query(queryString, mode, opts) {
        var _a, _b, _c, _d, _e, _f;
        opts = lodash_1.default.defaults(opts || {}, {
            fullNode: false,
            createIfNew: false,
            initialQuery: false,
            stub: false,
        });
        const ctx = "query";
        let data;
        // handle all query case
        if (isAllQuery(queryString)) {
            this.logger.debug({ ctx: "query:queryAll:pre", mode });
            try {
                data = await this.store.query("**/*", mode, {
                    ...opts,
                    schemas: this.schemas,
                });
            }
            catch (err) {
                if (err instanceof common_all_1.DendronError) {
                    this.logger.info({ ctx, msg: "no root found", mode });
                    const root = this._createRoot(mode);
                    await this.store.write(root);
                    this.logger.info({ ctx, msg: "post:store.write", mode });
                    return this.query(queryString, mode, opts);
                }
                else {
                    const { message, stack } = err;
                    this.logger.error({ ctx, err: JSON.stringify({ message, stack }) });
                    throw err;
                }
            }
            if (opts.initialQuery) {
                this.refreshNodes(data.data);
            }
            // @ts-ignore
            return data;
        }
        // handle schema query
        if (mode === "schema") {
            const results = this.schemaFuse.search(queryString);
            let items;
            const nodes = this.schemas;
            if (opts.queryOne) {
                items = [(_a = results[0]) === null || _a === void 0 ? void 0 : _a.item];
            }
            else {
                items = lodash_1.default.map(results, (resp) => resp.item);
            }
            this.logger.debug({ ctx: "query:exit:schema", items });
            return common_all_1.makeResponse({
                data: lodash_1.default.map(items, (item) => nodes[item.id]),
                error: null,
            });
        }
        else {
            let items;
            // shortcut for root query
            if (queryString === "") {
                items = [this.notes.root];
            }
            else {
                // handle note query
                const results = this.fuse.search(queryString);
                if (opts.queryOne) {
                    items = [(_b = results[0]) === null || _b === void 0 ? void 0 : _b.item];
                }
                else {
                    items = lodash_1.default.map(results, (resp) => resp.item);
                }
                // check if we need to create a new node
                if (opts.queryOne &&
                    opts.createIfNew &&
                    // did not find a good match or found a match but it was a stub
                    (((_c = items[0]) === null || _c === void 0 ? void 0 : _c.path) !== queryString || ((_d = items[0]) === null || _d === void 0 ? void 0 : _d.stub))) {
                    this.logger.debug({
                        ctx: "query:write:pre",
                        queryString,
                    });
                    let nodeBlank;
                    if (((_e = items[0]) === null || _e === void 0 ? void 0 : _e.path) === queryString && ((_f = items[0]) === null || _f === void 0 ? void 0 : _f.stub)) {
                        nodeBlank = items[0];
                        nodeBlank.stub = false;
                    }
                    else {
                        nodeBlank = new common_all_1.Note({ fname: queryString, stub: opts.stub });
                    }
                    await this.write(nodeBlank, {
                        newNode: true,
                        stub: opts.stub,
                    });
                    const { data: nodeFull } = await this.get(nodeBlank.id, mode);
                    this.refreshNodes([nodeFull], { fullNode: true });
                    return common_all_1.makeResponse({
                        data: [nodeFull],
                        error: null,
                    });
                }
            }
            // found result but want full node
            if (opts.fullNode) {
                const fetchedFullNodes = await Promise.all(lodash_1.default.map(items, async (ent) => {
                    if (!this.fullNodes.has(ent.id)) {
                        this.logger.debug({
                            ctx: "query:fuse.search:post",
                            status: "fetch full node from store",
                        });
                        // FIXME: ratelimit
                        const fn = await this.get(ent.id, mode);
                        return fn.data;
                    }
                    this.logger.debug({
                        ctx: "query:fuse.search:post",
                        status: "fetch full node from cache",
                    });
                    return null;
                }));
                this.refreshNodes(lodash_1.default.filter(fetchedFullNodes, (ent) => !lodash_1.default.isNull(ent)), { fullNode: true });
                this.logger.debug({
                    ctx: "query:fetchedFullNodes:exit",
                });
            }
            this.logger.debug({ ctx: "query:exit:note" });
            return common_all_1.makeResponse({
                data: lodash_1.default.map(items, (item) => this.notes[item.id]),
                error: null,
            });
        }
    }
    async queryOne(queryString, mode, opts) {
        const resp = await this.query(queryString, mode, {
            ...opts,
            queryOne: true,
        });
        return common_all_1.makeResponse({ data: resp.data[0], error: null });
    }
    async write(node, opts) {
        const props = lodash_1.default.defaults(opts, {
            newNode: false,
            body: "",
            stub: false,
            parentsAsStubs: false,
            recursive: false,
            noAddParent: false,
            writeStub: false,
        });
        await this.store.write(node, {
            stub: props.stub,
            recursive: props.recursive,
        });
        return this.updateNodes([node], lodash_1.default.pick(props, ["parentsAsStubs", "newNode", "noAddParent"]));
    }
    updateProps(opts) {
        if (opts.mode) {
            this.props.mode = opts.mode;
            // @ts-ignore
            const config = fuse_js_1.default.config;
        }
    }
    async updateNodes(nodes, opts) {
        const ntype = nodes[0].type;
        if (ntype === "schema") {
            await Promise.all(lodash_1.default.map(nodes, (node) => {
                return this._updateSchema(node);
            }));
        }
        else {
            await Promise.all(lodash_1.default.map(nodes, (node) => {
                return this._updateNote(node, opts);
            }));
            return;
        }
    }
    async _updateSchema(node) {
        const root = this.schemas.root;
        root.addChild(node);
        return this.refreshNodes([node]);
    }
    // OPTIMIZE: do in bulk
    /**
     * Indexes note into engine. This does a few things:
     *   - Add parent-child relationship to note.
     *   - If parent's don't exist, create parents as stubs.
     *   - Calls `refreshNodes` on notes
     * @param note
     * @param opts
     */
    async _updateNote(note, opts) {
        const addParent = (note, opts) => {
            let parentPath = common_all_1.DNodeUtils.dirName(note.fname);
            if (lodash_1.default.isEmpty(parentPath)) {
                parentPath = "root";
            }
            let parentNode = lodash_1.default.find(this.notes, (n) => n.path === parentPath);
            if (!parentNode) {
                if (opts.parentsAsStubs) {
                    const closestParent = common_all_1.DNodeUtils.findClosestParent(note.logicalPath, this.notes);
                    const stubNodes = common_all_1.NoteUtils.createStubNotes(closestParent, note);
                    stubNodes.forEach((ent2) => {
                        refreshList.push(ent2);
                    });
                    // last element is parent
                    parentNode = stubNodes.slice(-1)[0];
                }
                else {
                    throw Error("no parent found");
                }
            }
            parentNode.addChild(note);
        };
        const refreshList = [note];
        if (!opts.noAddParent) {
            addParent(note, opts);
        }
        return this.refreshNodes(refreshList, { fullNode: opts.newNode });
    }
}
exports.DendronEngine = DendronEngine;
//# sourceMappingURL=engine.js.map