"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronRefsPlugin = exports.parsePageTitle = void 0;
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../../utils");
const utils_2 = require("../utils");
const inject_1 = require("./inject");
// const LINK_REGEX = /^\[\[(.+?)\]\]/;
const LINK_REGEX = /^\(\((?<ref>[^)]+)\)\)/;
function locator(value, fromIndex) {
    return value.indexOf("((", fromIndex);
}
const aliasDivider = "|";
function isAlias(pageTitle) {
    return pageTitle.indexOf(aliasDivider) !== -1;
}
function parseAliasLink(pageTitle) {
    const [displayName, name] = pageTitle.split(aliasDivider);
    return { name, displayName };
}
function parsePageTitle(pageTitle) {
    if (isAlias(pageTitle)) {
        return parseAliasLink(pageTitle);
    }
    return {
        name: pageTitle,
        displayName: pageTitle,
    };
}
exports.parsePageTitle = parsePageTitle;
function dendronRefsPlugin(opts = {}) {
    const permalinks = opts.permalinks || [];
    const defaultPageResolver = (name) => [
        name.replace(/ /g, "").toLowerCase(),
    ];
    const pageResolver = opts.pageResolver || defaultPageResolver;
    const newClassName = opts.newClassName || "new";
    const renderWithOutline = opts.renderWithOutline || false;
    const wikiLinkClassName = opts.wikiLinkClassName || "internal";
    const defaultHrefTemplate = (permalink) => `#/page/${permalink}`;
    const hrefTemplate = opts.hrefTemplate || defaultHrefTemplate;
    const root = opts.root;
    function inlineTokenizer(eat, value) {
        const match = LINK_REGEX.exec(value);
        if (match) {
            const pageName = match[1].trim();
            const { link } = utils_1.parseDendronRef(pageName);
            const { name, displayName } = parsePageTitle(pageName);
            const pagePermalinks = pageResolver(name);
            let permalink = pagePermalinks.find((p) => permalinks.indexOf(p) !== -1);
            const exists = permalink !== undefined;
            if (!exists) {
                permalink = pagePermalinks[0];
            }
            let classNames = wikiLinkClassName;
            if (!exists) {
                classNames += " " + newClassName;
            }
            // normalize
            if (permalink) {
                permalink = common_server_1.removeMDExtension(permalink);
            }
            return eat(match[0])({
                type: "refLink",
                value: name,
                data: {
                    alias: displayName,
                    link,
                    permalink,
                    exists,
                    hName: "a",
                    hProperties: {
                        className: classNames,
                        href: hrefTemplate(permalink),
                    },
                    hChildren: [
                        {
                            type: "text",
                            value: displayName,
                        },
                    ],
                },
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    // @ts-ignore
    const Parser = this.Parser;
    // @ts-ignore
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    // @ts-ignore
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.refLink = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "refLink");
    // Stringify for wiki link
    // @ts-ignore
    const Compiler = this.Compiler;
    if (Compiler != null) {
        const visitors = Compiler.prototype.visitors;
        // const headingVisitor = _.bind(visitors.heading, Compiler);
        // let lastHeading: Heading;
        if (visitors) {
            //   visitors.heading = function(node: Heading) {
            //       lastHeading = node;
            //       return headingVisitor(node);
            //   }
            // eslint-disable-next-line func-names
            visitors.refLink = function (node) {
                var _a;
                const data = node.data;
                if (!root) {
                    throw Error("root not defined");
                }
                if (!((_a = data === null || data === void 0 ? void 0 : data.link) === null || _a === void 0 ? void 0 : _a.name)) {
                    throw Error("no link name foundjj");
                }
                const body = fs_extra_1.default.readFileSync(path_1.default.join(root, data.link.name + ".md"), {
                    encoding: "utf8",
                });
                const bodyAST = utils_2.getProcessor().parse(body);
                // bumpHeadings(bodyAST, 2);
                const { anchorStart, anchorEnd, anchorStartOffset } = data.link;
                let anchorStartIndex = bodyAST.children[0].type === "yaml" ? 1 : 0;
                let anchorEndIndex = bodyAST.children.length;
                if (anchorStart) {
                    anchorStartIndex = inject_1.findIndex(bodyAST.children, function (node) {
                        return inject_1.isHeading(node, anchorStart);
                    });
                }
                if (anchorEnd) {
                    anchorEndIndex = inject_1.findIndex(bodyAST.children.slice(anchorStartIndex + 1), function (node) {
                        return inject_1.isHeading(node, anchorEnd);
                    });
                    if (anchorEndIndex < 0) {
                        // TODO: raise error
                    }
                    anchorEndIndex += anchorStartIndex + 1;
                }
                bodyAST.children = bodyAST.children.slice(anchorStartIndex, anchorEndIndex);
                let out = utils_2.getProcessor().stringify(bodyAST);
                if (anchorStartOffset) {
                    out = out.split("\n").slice(anchorStartOffset).join("\n");
                }
                if (renderWithOutline) {
                    return doRenderWithOutline({
                        content: out,
                        title: data.link.label || data.link.name || "no title",
                        link: data.link.name + ".md",
                    });
                }
                return out;
            };
        }
    }
}
exports.dendronRefsPlugin = dendronRefsPlugin;
function doRenderWithOutline(opts) {
    const { content, title, link } = opts;
    return `
<div class="portal-container">
<div class="portal-head">
    <div class="portal-backlink" >
        <div class="portal-title">From <span class="portal-text-title">${title}</span></div>
        <a href="${link}" class="portal-arrow">Go to text <span class="right-arrow">â†’</span></a>
    </div>
</div>
<div id="portal-parent-{{include.anchor}}" class="portal-parent">
    <div class="portal-parent-fader-top"></div>
    <div class="portal-parent-fader-bottom"></div>        

${content}
</div>    
</div>
`;
}
//# sourceMappingURL=dendronRefsPlugin.js.map