"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProcessor = exports.applyTextEdit = exports.createNoteFromMarkdown = exports.parse = exports.md2Tokens = exports.tokens2MD = exports.md = void 0;
/* eslint-disable camelcase */
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const markdown_it_1 = __importDefault(require("markdown-it"));
const markdown_it_regex_1 = __importDefault(require("markdown-it-regex"));
const os_1 = __importDefault(require("os"));
const remark_1 = __importDefault(require("remark"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const remark_parse_1 = __importDefault(require("remark-parse"));
// import wikiLinkPlugin from "remark-wiki-link";
const unified_1 = __importDefault(require("unified"));
const unist_util_visit_1 = __importStar(require("unist-util-visit"));
const yamljs_1 = __importDefault(require("yamljs"));
const dendronLinksPlugin_1 = require("./plugins/dendronLinksPlugin");
const dendronRefsPlugin_1 = require("./plugins/dendronRefsPlugin");
const renderer_1 = require("./renderer");
var NodeType;
(function (NodeType) {
    NodeType["code_inline"] = "code_inline";
    NodeType["code_block"] = "code_block";
    NodeType["fence"] = "fence";
    NodeType["image"] = "image";
    NodeType["hardbreak"] = "hardbreak";
    NodeType["softbreak"] = "softbreak";
    NodeType["text"] = "text";
    NodeType["html_block"] = "html_block";
    NodeType["html_inline"] = "html_inline";
})(NodeType || (NodeType = {}));
let processor = null;
function md() {
    return markdown_it_1.default();
}
exports.md = md;
function tokens2MD(tokens) {
    return lodash_1.default.trim(new renderer_1.MDRenderer().render(tokens, {}, {}));
}
exports.tokens2MD = tokens2MD;
function md2Tokens(txt) {
    const markdownIt = markdown_it_1.default();
    const tokens = markdownIt
        .use(markdown_it_regex_1.default, {
        name: "ref-document",
        // eslint-disable-next-line no-useless-escape
        regex: /\[\[([^\[\]]+?)\]\]/,
    })
        .parse(txt, {});
    return tokens;
}
exports.md2Tokens = md2Tokens;
// export function replaceMDRefs(opts: ReplaceMDRefsOpts): Token[] {
//   const { tokens, imageLinkPrefix } = opts;
//   const reImg = new RegExp("((?<link>.*))");
//   tokens.map((t) => {
//     if (t.type === "inline") {
//       const children: Token[] = t.children ? t.children : [];
//       if (children[0]?.type === "image" && imageLinkPrefix) {
//         const attrs = children[0].attrs;
//         const oldSrcAtt = _.find(attrs, (u) => u[0] === "src");
//         const [_skip, oldSrc] = oldSrcAtt;
//         const newSrc = imageLinkPrefix + oldSrc;
//         // const match = reImg.exec(t.content);
//         // if (!match || !match.groups) {
//         //   throw Error(`no image found for token ${t}`);
//         // }
//         // const newLink = imageLinkPrefix + match.groups["link"];
//         t.content = t.content.replace(`(${oldSrc})`, `(${newSrc})`);
//       }
//     }
//     //   (!_.isEmpty(t.children)) &&
//     //   (t.children[0].type === "image") &&
//     //   imageLinkPrefix
//     // ) {
//     // }
//   });
//   return tokens;
// }
function parse(markdown) {
    processor =
        processor ||
            unified_1.default()
                .use(remark_parse_1.default, { gfm: true })
                .use(remark_frontmatter_1.default, ["yaml"])
                .use(dendronLinksPlugin_1.dendronLinksPlugin);
    return processor.parse(markdown);
}
exports.parse = parse;
// export async function process(node: Node) {
//   const streamIn = new PassThrough();
//   streamIn.write("# foo bar");
//   return new Promise((resolve) => {
//     engine(
//       {
//         processor: remark(),
//         streamIn,
//         pluginPrefix: "remark",
//         rcName: ".remarkrc",
//         packageField: "remarkConfig",
//         ignoreName: ".remarkignore",
//         color: true,
//       },
//       // eslint-disable-next-line no-use-before-define
//       done
//     );
//     function done(error: any) {
//       if (error) throw error;
//       resolve();
//     }
//   });
// }
// TODO: stub
function uriToSlug(uri) {
    return uri;
}
function createNoteFromMarkdown(uri, eol) {
    // eslint-disable-next-line prefer-const
    const markdown = fs_extra_1.default.readFileSync(uri, { encoding: "utf8" });
    eol = eol || os_1.default.EOL;
    const tree = parse(markdown);
    let title = null;
    let frontmatter = {};
    unist_util_visit_1.default(tree, (node) => {
        if (node.type === "heading" && node.depth === 1) {
            if (lodash_1.default.isNull(title)) {
                title = node.children[0].value || title;
            }
        }
        return title === null ? unist_util_visit_1.CONTINUE : unist_util_visit_1.EXIT;
    });
    const links = [];
    let start = { line: 1, column: 1, offset: 0 }; // start position of the note
    unist_util_visit_1.default(tree, (node) => {
        var _a;
        if (node.type === "yaml") {
            frontmatter = (_a = yamljs_1.default.parse(node.value)) !== null && _a !== void 0 ? _a : {}; // parseYAML returns null if the frontmatter is empty
            if (frontmatter.tite) {
                title = frontmatter.title;
            }
            // Update the start position of the note by exluding the metadata
            start = {
                line: node.position.end.line + 1,
                column: 1,
                offset: node.position.end.offset + 1,
            };
        }
        if (node.type === "image") {
            links.push({
                type: common_all_1.LinkType.IMAGE_LINK,
                url: node.url,
                alt: node.alt,
                position: node.position,
            });
        }
        if (node.type === "wikiLink") {
            let maybeLbl;
            let maybeUrl;
            [maybeLbl, maybeUrl] = node.value.split("|");
            if (lodash_1.default.isUndefined(maybeUrl)) {
                maybeUrl = maybeLbl;
                maybeLbl = undefined;
            }
            links.push({
                type: common_all_1.LinkType.WIKI_LINK,
                position: node.position,
                url: maybeUrl,
            });
        }
        // if (node.type === "definition") {
        //   linkDefinitions.push({
        //     label: node.label as string,
        //     url: node.url as string,
        //     title: node.title as string,
        //     position: node.position,
        //   });
        // }
    });
    // Give precendence to the title from the frontmatter if it exists
    // title = frontmatter.title ?? title;
    const end = tree.position.end;
    // const definitions = getFoamDefinitions(linkDefinitions, end);
    const props = {
        properties: frontmatter,
        slug: uriToSlug(uri),
        title,
        links,
        source: {
            tree,
            uri,
            text: markdown,
            contentStart: start,
            end,
            eol,
        },
    };
    const fname = common_all_1.DNodeUtils.basename(props.source.uri, true);
    const note = new common_all_1.Note({ fname });
    note.custom.props = props;
    return note;
}
exports.createNoteFromMarkdown = createNoteFromMarkdown;
exports.applyTextEdit = (text, textEdit) => {
    const characters = text.split("");
    const startOffset = textEdit.range.start.offset || 0;
    const endOffset = textEdit.range.end.offset || 0;
    const deleteCount = endOffset - startOffset;
    const textToAppend = `${textEdit.newText}`;
    characters.splice(startOffset, deleteCount, textToAppend);
    return characters.join("");
};
function getProcessor(opts) {
    const { root, renderWithOutline } = opts || {};
    return remark_1.default()
        .use(remark_parse_1.default, { gfm: true })
        .use(remark_frontmatter_1.default, ["yaml"])
        .use(dendronLinksPlugin_1.dendronLinksPlugin)
        .use(dendronRefsPlugin_1.dendronRefsPlugin, { root, renderWithOutline })
        .use({ settings: { listItemIndent: "1", fences: true } });
}
exports.getProcessor = getProcessor;
//# sourceMappingURL=utils.js.map