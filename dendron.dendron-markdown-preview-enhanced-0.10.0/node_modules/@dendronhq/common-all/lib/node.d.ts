import { URI } from "vscode-uri";
import { DNodeData, DNodeDict, DNodeRawOpts, DNodeRawProps, IDNode, IDNodeOpts, IDNodeType, INote, INoteOpts, ISchema, ISchemaOpts, NoteData, NoteRawProps, SchemaData, SchemaDict, SchemaRawProps, RawPropsOpts, SchemaRawOptsFlat, SchemaTemplate, DEngine, NoteProps, ProtoLink } from "./types";
import { Point, Node } from "unist";
export declare const UNKNOWN_SCHEMA_ID = "_UNKNOWN_SCHEMA";
export declare class DNodeUtils {
    /**
     * Last element of path
     *
     * // don't remove extension
     * basename(foo.bar.md) // foo.bar
     *
     * @param nodePath
     * @param rmExtension
     */
    static basename(nodePath: string, rmExtension?: boolean): string;
    /**
     * Second last element
     * @param nodePath
     */
    static dirName(nodePath: string): string;
    /**
     * First element
     * eg. domainName(foo.bar.baz) // foo
     * @param nodePath
     */
    static domainName(nodePath: string): string;
    static findClosestParent(fpath: string, nodes: DNodeDict, opts?: {
        noStubs: boolean;
    }): IDNode;
    /**
     *
     * @param note
     * - pullCustomUp: roll custom attributes to top level, default: false
     * @param opts
     */
    static getMeta(note: Note, opts?: {
        pullCustomUp?: boolean;
        ignoreNullParent?: boolean;
    }): {
        parent: string | null;
        children: string[];
        schemaId?: string | undefined;
        schema?: Schema | undefined;
        schemaStub?: boolean | undefined;
        detail?: string | undefined;
        description?: string | undefined;
        domain?: Note | undefined;
        url?: string | undefined;
        id?: string | undefined;
        title?: string | undefined;
        desc?: string | undefined;
        fname?: string | undefined;
        type?: "note" | "schema" | undefined;
        updated?: string | undefined;
        created?: string | undefined;
        body?: string | undefined;
        data?: NoteData | undefined;
        stub?: boolean | undefined;
        custom?: any;
        uri?: URI | undefined;
        basename?: string | undefined;
        label?: string | undefined;
        nodes?: DNode<NoteData>[] | undefined;
        logicalPath?: string | undefined;
        path?: string | undefined;
        addChild?: ((node: IDNode<NoteData>) => void) | undefined;
        equal?: ((node: IDNode<NoteData>) => boolean) | undefined;
        render?: (() => string) | undefined;
        renderBody?: (() => string) | undefined;
        toDocument?: (() => {
            document: {
                nodes: {
                    object: string;
                    type: string;
                    nodes: {
                        object: string;
                        text: string;
                    }[];
                }[];
            };
        }) | undefined;
        toNoteProps?: (() => NoteProps) | undefined;
        toRawProps?: ((hideBody?: boolean | undefined, opts?: RawPropsOpts | undefined) => Required<DNodeRawOpts<NoteData>>) | undefined;
        toRawPropsRecursive?: ((opts?: RawPropsOpts | undefined) => Required<DNodeRawOpts<NoteData>>[]) | undefined;
        validate?: (() => boolean) | undefined;
    };
    static getNoteByFname(fname: string, engine: DEngine, opts?: {
        throwIfEmpty: boolean;
    }): Note | undefined;
    static getPathUpTo(hpath: string, numCompoenents: number): string;
    static isRoot(node: DNode): boolean;
    static uri2Fname(uri: URI): string;
    static node2Uri(node: Note, engine: DEngine): URI;
}
export declare type CreatePropsOpts = {
    returnExtra: boolean;
};
export declare class DNodeRaw {
    /**
     *
     * @param nodeOpts
     * @param opts
     *   - returnExtra: if true, return extra properties, default: false
     */
    static createProps<T>(nodeOpts: DNodeRawOpts<T>): DNodeRawProps<T> & {
        extra?: any;
    };
}
declare type QuickPickItem = {
    label: string;
    /**
     * A human-readable string which is rendered less prominent in the same line. Supports rendering of
     * [theme icons](#ThemeIcon) via the `$(<name>)`-syntax.
     */
    description?: string;
    /**
     * A human-readable string which is rendered less prominent in a separate line. Supports rendering of
     * [theme icons](#ThemeIcon) via the `$(<name>)`-syntax.
     */
    detail?: string;
    /**
     * Optional flag indicating if this item is picked initially.
     * (Only honored when the picker allows multiple selections.)
     *
     * @see [QuickPickOptions.canPickMany](#QuickPickOptions.canPickMany)
     */
    picked?: boolean;
    /**
     * Always show this item.
     */
    alwaysShow?: boolean;
};
export declare abstract class DNode<T = DNodeData> implements IDNode<T>, QuickPickItem {
    id: string;
    title: string;
    desc: string;
    fname: string;
    type: IDNodeType;
    updated: string;
    created: string;
    parent: IDNode<T> | null;
    children: IDNode<T>[];
    body: string;
    data: T;
    stub: boolean;
    custom: any;
    uri: URI;
    static defaultTitle(fname: string): string;
    constructor(opts: IDNodeOpts<T>);
    get domain(): DNode<T>;
    get basename(): string;
    get detail(): string;
    get label(): string;
    /**
     * Self and all children
     */
    get nodes(): DNode<T>[];
    /**
     * dot delimited path
     *  - for root node, its ""
     *  - for everything else, its the dot delimited name
     *  - used when showing query
     */
    get logicalPath(): string;
    get path(): string;
    addChild(node: IDNode<T>): void;
    equal(node: IDNode<T>): boolean;
    render(): string;
    renderBody(): string;
    toDocument(): {
        document: {
            nodes: {
                object: string;
                type: string;
                nodes: {
                    object: string;
                    text: string;
                }[];
            }[];
        };
    };
    toNoteProps(): NoteProps;
    toRawProps(hideBody?: boolean, opts?: RawPropsOpts): DNodeRawProps<T>;
    toRawPropsRecursive(opts?: RawPropsOpts): DNodeRawProps<T>[];
    validate(): boolean;
}
export declare class Note extends DNode<NoteData> implements INote {
    schemaId: string;
    schema?: Schema;
    schemaStub: boolean;
    static createStub(fname: string, opts?: Partial<INoteOpts>): Note;
    static createRoot(): Note;
    static fromSchema(dirpath: string, schema: Schema): Note;
    constructor(props: INoteOpts);
    get detail(): string;
    get description(): string | undefined;
    get domain(): Note;
    get url(): string;
}
export declare class Schema extends DNode<SchemaData> implements ISchema {
    static createRawProps(opts: SchemaRawOptsFlat): SchemaRawProps;
    static createRoot(): Schema;
    static _UNKNOWN_SCHEMA: undefined | Schema;
    /**
     * This is attached to notes that are part of a domain with schema but
     * don't match any schema in it
     */
    static createUnkownSchema(): Schema;
    static defaultTitle(fname: string): string;
    constructor(props: ISchemaOpts);
    get namespace(): boolean;
    get label(): string;
    get logicalPath(): string;
    get patternMatch(): string;
    get pattern(): string;
    get url(): string;
    match(note: Note): boolean;
    renderBody(): string;
    render(): string;
}
/**
 * From nodes, return a connected note tree
 */
export declare class NodeBuilder {
    getDomainsRoot<T extends DNodeData>(nodes: DNodeRawProps<T>[]): DNodeRawProps<T>[];
    toNote(item: NoteRawProps, parents: Note[], opts: {
        schemas: Schema[];
    }): {
        node: Note;
        parent: Note;
        children: string[];
        schemas: Schema[];
    };
    toSchema(item: SchemaRawProps, parent: Schema, props: SchemaRawProps[]): Schema;
    buildNoteFromProps(props: NoteRawProps[], opts: {
        schemas: Schema[];
    }): Note[];
    buildSchemaFromProps(props: SchemaRawProps[]): Schema[];
}
export declare type ProtoNoteSource = {
    uri: URI;
    text: string;
    contentStart: Point;
    end: Point;
    eol: string;
    tree: Node;
};
export declare class NoteUtils {
    static addBackLink(from: Note, to: Note): void;
    /**
     * @param from
     * @param to
     */
    static createStubNotes(from: Note, to: Note): Note[];
    static protoGetLinks(note: Note, opts: {
        filter?: string;
    }): ProtoLink[];
    static protoGetSource(note: Note): ProtoNoteSource;
}
export declare class SchemaUtils {
    static fname(nodePath: string, rmExtension?: boolean): string;
    static isUnkown(schema: Schema): boolean;
    static applyTemplate(opts: {
        template: SchemaTemplate;
        note: Note;
        engine: DEngine;
    }): boolean;
    /**
     * Return true if template was applied, false otherwise
     * @param opts
     */
    static matchAndApplyTemplate(opts: {
        note: Note;
        engine: DEngine;
    }): boolean;
    /**
     *
     * @param noteOrPath
     * @param schemas
     * @param opts
     *   - matchNamespace: should match exact namespace note (in addition to wildcard), default: false
     *   - matchPrefix: allow prefix match, default: false
     */
    static matchNote(noteOrPath: Note | string, schemas: SchemaDict | Schema[], opts?: {
        matchNamespace?: boolean;
        matchPrefix?: boolean;
    }): Schema;
}
export {};
