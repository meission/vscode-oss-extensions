import { Note, Schema } from "./node";
import { URI } from "vscode-uri";
import { Position } from "unist";
export declare type Stage = "dev" | "prod" | "test";
export declare enum LinkType {
    WIKI_LINK = "WIKI_LINK",
    IMAGE_LINK = "IMAGE_LINK"
}
export interface Link {
    type: LinkType;
    url: string;
    position: Position;
    label?: string;
}
export interface WikiLink extends Link {
    type: LinkType.WIKI_LINK;
}
export interface ImageLink extends Link {
    type: LinkType.IMAGE_LINK;
    alt?: string;
}
export declare type ProtoLink = WikiLink | ImageLink;
export declare type NoteLink = {
    type: "note";
    id: string;
};
export declare type NoteData = {
    schemaId?: string;
    links?: NoteLink[];
};
export declare type SchemaTemplate = {
    id: string;
    type: "snippet" | "note";
};
export declare type SchemaData = {
    namespace?: boolean;
    pattern?: string;
    template?: SchemaTemplate;
};
export declare type DNodeData = SchemaData | NoteData;
export declare type IDNodeType = "note" | "schema";
export declare type QueryMode = IDNodeType;
export declare type RawPropsOpts = {
    ignoreNullParent?: boolean;
};
export declare type DNodeRawOpts<T extends DNodeData> = {
    id?: string;
    title?: string;
    desc?: string;
    stub?: boolean;
    updated?: string;
    created?: string;
    /**
     * Same as uri
     */
    fname: string;
    parent?: string | null | "root";
    children?: string[];
    body?: string;
    data?: T;
    /**
     * Custom attributes
     */
    custom?: any;
};
export declare type DNodeRawProps<T extends DNodeData = DNodeData> = Required<DNodeRawOpts<T>>;
export declare type NoteProps = {
    body: string;
    meta: any;
};
export declare type IDNodeOpts<T = DNodeData> = Omit<DNodeRawOpts<T>, "parent" | "children"> & {
    type: IDNodeType;
    parent?: IDNode<T> | null;
    children?: IDNode<T>[];
};
export declare type IDNodeProps<T = DNodeData> = Required<IDNodeOpts<T>>;
export declare type IDNode<T = DNodeData> = IDNodeProps<T> & {
    nodes: IDNode<T>[];
    /**
     * The raw path
     */
    path: string;
    basename: string;
    uri: URI;
    /**
     * Path dependent on type of node
     *   - for notes, this is same as `path` except for `root` node, in which case this is ""
     *   - for schemas, this is minimatch pattern of schema ids
     */
    logicalPath: string;
    /**
     * Child of the root (this.parent == root)
     */
    domain: IDNode<T>;
    label: string;
    detail: string;
    bar?: string;
    equal(node: IDNode<T>): boolean;
    addChild(node: IDNode<T>): void;
    /**
     * plain text based representation of node
     */
    render(): string;
    /**
     * Render body for rich-markdown-editor
     */
    renderBody(): string;
    toDocument(): any;
    toNoteProps(): NoteProps;
    toRawProps(hideBody?: boolean, opts?: RawPropsOpts): DNodeRawProps<T>;
    toRawPropsRecursive(opts?: RawPropsOpts): DNodeRawProps<T>[];
    validate(): boolean;
};
export declare type DNodeRawDict<T = DNodeData> = {
    [id: string]: DNodeRawProps<T>;
};
export declare type DNodeDict<T = DNodeData> = {
    [id: string]: IDNode<T>;
};
export declare type NoteRawProps = DNodeRawProps<NoteData>;
export declare type INoteOpts = Omit<IDNodeOpts<NoteData>, "type"> & {
    schemaStub?: boolean;
};
export declare type INoteProps = Required<INoteOpts>;
export declare type INote = INoteProps & {
    domain: INote;
};
export declare type NoteDict = {
    [id: string]: Note;
};
export declare type SchemaRawV1 = {
    version: string;
    imports?: SchemaRawImport;
    schemas: SchemaRawOpts[];
};
export declare type SchemaRawImport = string[];
export declare type SchemaRawEntry = SchemaRawOptsFlat | SchemaRawImport;
export declare type SchemaRawOptsFlat = Omit<DNodeRawOpts<any>, "data"> & SchemaData & {
    id: string;
    fname: string;
};
export declare type SchemaRawOpts = DNodeRawOpts<SchemaData> & Required<Pick<DNodeRawOpts<SchemaData>, "id" | "fname">>;
export declare type SchemaRawProps = DNodeRawProps<SchemaData>;
export declare type ISchemaOpts = Omit<IDNodeOpts<SchemaData>, "type">;
export declare type ISchemaProps = Required<ISchemaOpts>;
export declare type ISchema = ISchemaProps;
export declare type SchemaDict = {
    [id: string]: Schema;
};
export interface Resp<T> {
    data: T;
    error?: Error | null;
}
export declare type EngineGetResp<T = DNodeData> = Resp<IDNode<T>>;
export declare type EngineQueryResp<T = DNodeData> = Resp<IDNode<T>[]>;
export declare type StoreGetResp<T = DNodeData> = Resp<DNodeRawProps<T>>;
export declare type StoreQueryResp<T = DNodeData> = Resp<DNodeRawProps<T>[]>;
export declare type NodeWriteOpts = {
    /**
     * See QueryOpts.stub
     */
    stub?: boolean;
    /**
     * Write all children?
     * default: false
     */
    recursive?: boolean;
    /**
     * Write stubs
     * default: false
     */
    writeStub?: boolean;
} & Partial<UpdateNodesOpts>;
export declare type EngineDeleteOpts = {
    /**
     * Only delete from meta
     */
    metaOnly?: boolean;
};
export interface QueryOpts {
    /**
     * Should add to full nodes
     */
    fullNode?: boolean;
    /**
     * Just get one result
     */
    queryOne?: boolean;
    /**
     * Use with `createIfNew`
     * If true, create a stub node.
     * A stub node is not written to disk
     */
    stub?: boolean;
    /**
     * If node does not exist, create it?
     */
    createIfNew?: boolean;
    webClient?: boolean;
    initialQuery?: boolean;
    mode?: QueryMode;
}
export declare type QueryOneOpts = Omit<QueryOpts, "queryOne">;
export declare type UpdateNodesOpts = {
    /**
     * If parents don't exist, create them
     */
    parentsAsStubs: boolean;
    /**
     * New Node, should add to `fullNode` cache
     */
    newNode: boolean;
    /**
     * Should skip adding parents, default: false
     */
    noAddParent?: boolean;
};
export declare type StoreQueryOpts = QueryOpts & {
    schemas?: SchemaDict;
};
export declare type StoreDeleteOpts = {
    fpath?: string;
};
export interface DEngineParser<TOpts = any> {
    parseSchema(data: any, opts: TOpts): SchemaRawProps[];
    parseNote(data: any, opts: TOpts): NoteRawProps[];
}
export declare type DEngineStoreWriteOpts = {
    /**
     * If set, don't write to file
     */
    stub?: boolean;
    /**
     * See DEngineStoreWriteOpts.recursive
     */
    recursive?: boolean;
    /**
     * See DEngineStoreWriteOpts.writeStub
     */
    writeStub?: boolean;
};
export interface DEngineStore<T = DNodeData, O = any> {
    opts: O;
    delete: (id: string, opts?: StoreDeleteOpts) => Promise<void>;
    get: (id: string, opts?: QueryOpts) => Promise<StoreGetResp<T>>;
    query: (queryString: string, mode: QueryMode, opts?: StoreQueryOpts) => Promise<EngineQueryResp<T>>;
    write: <T>(node: IDNode<T>, opts?: DEngineStoreWriteOpts) => Promise<void>;
    updateNodes(nodes: IDNode[]): Promise<void>;
}
export declare type DEngineMode = "exact" | "fuzzy";
export declare type DEngineOpts = {
    /**
     * TODO: this is currently not supported
     */
    root: string;
    mode?: DEngineMode;
};
/**
 * Query: path based
 * Get: id based
 */
export interface DEngine {
    notes: NoteDict;
    schemas: SchemaDict;
    props: Required<DEngineOpts>;
    initialized: boolean;
    store: DEngineStore;
    /**
     * Load all nodes
     */
    init: () => Promise<void>;
    delete: (id: string, mode: QueryMode, opts?: EngineDeleteOpts) => Promise<void>;
    /**
     * Get node based on id
     * get(id: ...)
     */
    get: (id: string, mode: QueryMode, opts?: QueryOpts) => Promise<EngineGetResp<DNodeData>>;
    /**
     * Get node based on query
     * query(scope: {username: lukesernau}, queryString: "project", nodeType: note)
     * - []
     * - [Node(id: ..., title: project, children: [])]
     */
    query: (queryString: string, mode: QueryMode, opts?: QueryOpts) => Promise<EngineQueryResp<DNodeData>>;
    /**
     * Shortcut Function
     */
    queryOne: (queryString: string, mode: QueryMode, opts?: QueryOneOpts) => Promise<EngineGetResp<DNodeData>>;
    write: (node: IDNode<DNodeData>, opts?: NodeWriteOpts) => Promise<void>;
    /**
     * Update engine properties
     * @param opts
     */
    updateProps(opts: Partial<DEngineOpts>): void;
    /**
     * Update node metadata
     * @param node
     */
    updateNodes(nodes: IDNode[], opts: UpdateNodesOpts): Promise<void>;
}
export declare type DendronConfig = {
    site: DendronSiteConfig;
};
export declare type HierarchyConfig = {
    publishByDefault: boolean;
};
export declare type LegacyDendronSiteConfig = {
    noteRoot?: string;
    noteRoots?: string[];
    /**
     * // TODO: rename `siteRootDir`
     * Where is site going to be published
     */
    siteRoot?: string;
};
export declare type DendronSiteConfig = {
    /**
     * If set, instead of copying assets, load assets from the assigned prefix
     */
    assetsPrefix?: string;
    /**
     * By default, the domain of your siteHiearchies page
     */
    siteIndex?: string;
    /**
     * Hiearchies to publish
     */
    siteHierarchies: string[];
    /**
     * Where your site will be published.
     * Relative to Dendron workspace
     */
    siteRootDir: string;
    /**
     * Control publication on a per hierarchy basis
     */
    config?: {
        [key: string]: HierarchyConfig;
    };
};
