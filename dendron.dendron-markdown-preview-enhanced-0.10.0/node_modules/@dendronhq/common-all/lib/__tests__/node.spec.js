"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("../node");
const testUtils_1 = require("../testUtils");
const lodash_1 = __importDefault(require("lodash"));
function setupNotes() {
    const baz = new node_1.Note({
        fname: "baz",
    });
    const foo = new node_1.Note({
        fname: "foo",
    });
    const fooChild = new node_1.Note({
        fname: "foo.one",
    });
    const fooGrandChild = new node_1.Note({
        fname: "foo.one.alpha",
    });
    const fooTwoBeta = new node_1.Note({
        fname: "foo.two.beta",
    });
    const bar = new node_1.Note({ fname: "bar" });
    const barChild = new node_1.Note({ fname: "bar.one" });
    const barChildNamespaceExact = new node_1.Note({ fname: "bar.one.alpha-namespace" });
    const barChildNamespaceChild = new node_1.Note({
        fname: "bar.one.alpha-namespace.alpha",
    });
    const barGrandChild = new node_1.Note({ fname: "bar.one.alpha" });
    const root = new node_1.Note({ id: "root", fname: "root" });
    fooChild.addChild(fooGrandChild);
    foo.addChild(fooChild);
    root.addChild(foo);
    root.addChild(baz);
    bar.addChild(barChild);
    barChild.addChild(barGrandChild);
    bar.addChild(barChildNamespaceExact);
    barChildNamespaceExact.addChild(barChildNamespaceChild);
    return {
        foo,
        fooChild,
        fooGrandChild,
        bar,
        barChild,
        barChildNamespaceExact,
        barChildNamespaceChild,
        barGrandChild,
        root,
        fooTwoBeta,
        baz,
    };
}
function setupSchema() {
    const bar = new node_1.Schema({
        id: "bar",
        fname: "bar.schema.yml",
        parent: null,
        data: { namespace: true },
    });
    const barChildNamespace = new node_1.Schema({
        id: "alpha-namespace",
        fname: "bar.schema.yml",
        parent: null,
        data: { namespace: true },
    });
    const foo = new node_1.Schema({
        id: "foo",
        desc: "foo desc",
        fname: "foo.schema.yml",
        parent: null,
    });
    const fooChild = new node_1.Schema({
        id: "one",
        fname: "foo.schema.yml",
        parent: null,
    });
    const fooGrandChild = new node_1.Schema({
        id: "alpha",
        fname: "foo.schema.yml",
        parent: null,
    });
    const baz = new node_1.Schema({
        id: "baz",
        fname: "baz.schema.yml",
        parent: null,
        data: {
            pattern: "baaaz",
        },
    });
    const root = node_1.Schema.createRoot();
    root.addChild(foo);
    root.addChild(bar);
    root.addChild(baz);
    foo.addChild(fooChild);
    fooChild.addChild(fooGrandChild);
    bar.addChild(barChildNamespace);
    return { foo, fooChild, fooGrandChild, bar, barChildNamespace, baz };
}
describe("DNoteUtils", () => {
    let notes;
    describe("basename", () => {
        test("simple", () => {
            expect(node_1.DNodeUtils.basename("foo.bar.md")).toEqual("md");
        });
        test("simple, rm extension", () => {
            expect(node_1.DNodeUtils.basename("foo.bar.md", true)).toEqual("bar");
        });
        test("simple, rm extension, no extension", () => {
            expect(node_1.DNodeUtils.basename("foo.bar", true)).toEqual("bar");
        });
    });
    describe("findClosestParent, parent", () => {
        beforeEach(() => {
            notes = setupNotes();
        });
        const createNotesWithStub = () => {
            const root = new node_1.Note({ id: "root", fname: "root" });
            const foo = new node_1.Note({
                fname: "foo",
            });
            const fooChild = new node_1.Note({
                fname: "foo.one",
                stub: true,
            });
            const fooGrandChild = new node_1.Note({
                fname: "foo.one.alpha",
            });
            fooChild.addChild(fooGrandChild);
            foo.addChild(fooChild);
            root.addChild(foo);
            return { root, foo, fooChild, fooGrandChild };
        };
        describe("noStub = false", () => {
            test("grandchild -> parent", () => {
                const resp = node_1.DNodeUtils.findClosestParent("foo.one.alpha", notes);
                resp.fname = "foo.one";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
            test("grandchild -> domain root", () => {
                const resp = node_1.DNodeUtils.findClosestParent("baz.one.alpha", notes);
                resp.fname = "baz";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
            test("grandchild -> root", () => {
                const resp = node_1.DNodeUtils.findClosestParent("bond.one.alpha", notes);
                resp.fname = "root";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
        });
        describe("noStub = true", () => {
            const noStubs = true;
            test("grandchild -> parent", () => {
                const resp = node_1.DNodeUtils.findClosestParent("foo.one.alpha", notes, {
                    noStubs,
                });
                resp.fname = "foo.one";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
            test("grandchild -> domain root", () => {
                const resp = node_1.DNodeUtils.findClosestParent("baz.one.alpha", notes, {
                    noStubs,
                });
                resp.fname = "baz";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
            test("grandchild -> root", () => {
                const resp = node_1.DNodeUtils.findClosestParent("bond.one.alpha", notes, {
                    noStubs,
                });
                resp.fname = "root";
                testUtils_1.expectSnapshot(expect, "main", resp);
            });
            test("parent is stub", () => {
                const notes = createNotesWithStub();
                expect(node_1.DNodeUtils.findClosestParent("foo.one.alpha", notes, {
                    noStubs,
                }).fname).toEqual("foo");
            });
            test("grandparent is stub", () => {
                const notes = createNotesWithStub();
                notes.foo.stub = true;
                expect(node_1.DNodeUtils.findClosestParent("foo.one.alpha", notes, {
                    noStubs,
                }).fname).toEqual("root");
            });
        });
    });
});
describe("SchemaUtils", () => {
    let notes;
    let schemas;
    beforeEach(() => {
        notes = setupNotes();
        schemas = setupSchema();
    });
    describe("string", () => {
        test("node: domain", () => {
            const fooSchema = node_1.SchemaUtils.matchNote("foo", schemas);
            testUtils_1.expectSnapshot(expect, "schemas", lodash_1.default.values(schemas));
            expect(fooSchema).toEqual(schemas.foo);
        });
        test("end with dot", () => {
            const fooSchema = node_1.SchemaUtils.matchNote("foo.", schemas);
            expect(fooSchema).toEqual(schemas.foo);
        });
        test("end full-name, normal schema", () => {
            const fooChildSchema = node_1.SchemaUtils.matchNote("foo.one", schemas);
            expect(fooChildSchema).toEqual(schemas.fooChild);
        });
        test("end with dot, namespace schema", () => {
            const barSchema = node_1.SchemaUtils.matchNote("bar.", schemas);
            expect(barSchema).toEqual(schemas.bar);
        });
        test("end mid-name, namespace schema", () => {
            const barSchema = node_1.SchemaUtils.matchNote("bar.foo", schemas);
            expect(barSchema).toEqual(schemas.bar);
        });
        test("match pattern", () => {
            const match = node_1.SchemaUtils.matchNote("baaaz", schemas);
            expect(match).toEqual(schemas.baz);
        });
        test("match complex pattern", () => {
            const fname = "journal.schema.yml";
            const journalSchema = new node_1.Schema({
                id: "journal",
                fname,
                parent: null,
                data: { pattern: "journal" },
            });
            const year = new node_1.Schema({
                id: "year",
                fname,
                data: { pattern: "[0-2][0-9][0-9][0-9]" },
            });
            const month = new node_1.Schema({
                id: "month",
                fname,
                data: { pattern: "[0-9][0-9]" },
            });
            const day = new node_1.Schema({
                id: "day",
                fname,
                data: { pattern: "[0-9][0-9]", namespace: true },
            });
            journalSchema.addChild(year);
            year.addChild(month);
            month.addChild(day);
            const match = node_1.SchemaUtils.matchNote("journal.2020", [journalSchema]);
            expect(match).toEqual(year);
            expect(node_1.SchemaUtils.matchNote("journal.2020.12", [journalSchema])).toEqual(month);
            expect(node_1.SchemaUtils.matchNote("journal.2020.12.12", [journalSchema])).toEqual(day);
            expect(node_1.SchemaUtils.matchNote("journal.2020.12.12.foo", [journalSchema])).toEqual(day);
        });
    });
    describe("note", () => {
        test("matchDomain", () => {
            const fooNote = notes.foo;
            const fooSchema = node_1.SchemaUtils.matchNote(fooNote, schemas);
            testUtils_1.expectSnapshot(expect, "schemas", lodash_1.default.values(schemas));
            expect(fooSchema).toEqual(schemas.foo);
        });
        test("matchChild", () => {
            const note = notes.fooChild;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema).toEqual(schemas.fooChild);
        });
        test("matchChildNamespace", () => {
            const note = notes.barChild;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema).toEqual(schemas.bar);
        });
        test("matchChildNamespace:childAlsoNamespace:exact", () => {
            const note = notes.barChildNamespaceExact;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema.toRawProps()).toEqual(schemas.barChildNamespace.toRawProps());
        });
        test("matchChildNamespace:childAlsoNamespace:child", () => {
            const note = notes.barChildNamespaceExact;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema.toRawProps()).toEqual(schemas.barChildNamespace.toRawProps());
        });
        test("namespace no match grandchild", () => {
            const note = notes.barGrandChild;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema).toEqual(node_1.Schema.createUnkownSchema());
        });
        test("matchGrandChild", () => {
            const note = notes.fooGrandChild;
            const schema = node_1.SchemaUtils.matchNote(note, schemas);
            expect(schema).toEqual(schemas.fooGrandChild);
            const note2 = notes.fooTwoBeta;
            const schema2 = node_1.SchemaUtils.matchNote(note2, schemas);
            expect(schema2).toEqual(node_1.Schema.createUnkownSchema());
        });
    });
});
describe("NoteUtils", () => {
    let notes;
    test("createStubNotes, root -> bar.one", () => {
        var _a;
        notes = setupNotes();
        node_1.NoteUtils.createStubNotes(notes.root, notes.barChild);
        expect(notes.barChild.parent).not.toBeNull();
        expect((_a = notes.barChild.parent) === null || _a === void 0 ? void 0 : _a.stub).toBe(true);
        expect(notes.root.children.length).toEqual(3);
        testUtils_1.expectSnapshot(expect, "barChild", notes.barChild.nodes);
    });
    test("createStubNotes, foo -> foo.two.beta", () => {
        var _a;
        notes = setupNotes();
        node_1.NoteUtils.createStubNotes(notes.foo, notes.fooTwoBeta);
        expect(notes.fooTwoBeta.parent).not.toBeNull();
        expect((_a = notes.fooTwoBeta.parent) === null || _a === void 0 ? void 0 : _a.stub).toBe(true);
        expect(notes.root.children.length).toEqual(2);
        expect(notes.foo.children.length).toEqual(2);
    });
    test("createStubNotes, bar (stub) -> bar.two.beta", () => {
        notes = setupNotes();
        const barStub = node_1.Note.createStub("bar");
        notes.root.addChild(barStub);
        node_1.NoteUtils.createStubNotes(barStub, new node_1.Note({ fname: "bar.two.beta" }));
        const barStubChild = barStub.children[0];
        expect(barStubChild === null || barStubChild === void 0 ? void 0 : barStubChild.stub).toBe(true);
        expect(barStubChild === null || barStubChild === void 0 ? void 0 : barStubChild.fname).toBe("bar.two");
        expect(barStubChild === null || barStubChild === void 0 ? void 0 : barStubChild.children.length).toEqual(1);
    });
});
describe("Note", () => {
    // TODO: for some reason, npm run build says notes is unused
    // @ts-ignore
    let notes;
    let schemas;
    beforeEach(() => {
        notes = setupNotes();
        schemas = setupSchema();
    });
    describe("create", () => {
        test("fromSchema", () => {
            const dirPath = "root";
            const note = node_1.Note.fromSchema(dirPath, schemas.foo);
            expect(note.desc).toEqual(schemas.foo.desc);
            testUtils_1.testUtilsCommonAll.expectSnapshot(expect, "noteFromSchema", note);
        });
    });
});
describe("Schema", () => {
    let schemas;
    beforeEach(() => {
        schemas = setupSchema();
    });
    describe("basic", () => {
        test("unknown schema", () => {
            const schema = node_1.Schema.createUnkownSchema();
            expect(schema.id).toEqual(node_1.UNKNOWN_SCHEMA_ID);
            expect(schema.stub).toBe(true);
            testUtils_1.testUtilsCommonAll.expectSnapshot(expect, "unknown", schema);
        });
        test("render", () => {
            const schema = new node_1.Schema({ fname: "foo" });
            const body = schema.render();
            expect(body).toMatchSnapshot("schema.render");
        });
    });
    describe("domainRoot", () => {
        test("at root", () => {
            const { foo } = schemas;
            expect(foo.domain.id).toEqual(foo.id);
            expect(foo.logicalPath).toEqual("foo");
            expect(foo.renderBody()).toMatchSnapshot("foo_body");
        });
        test("at child", () => {
            const { fooChild, foo } = schemas;
            expect(fooChild.domain.id).toEqual(foo.id);
            expect(fooChild.logicalPath).toEqual("foo/one");
            expect(fooChild.renderBody()).toMatchSnapshot("fooChild_body");
        });
        test("at child namespace", () => {
            const { bar: schema } = schemas;
            expect(schema.logicalPath).toEqual("bar/*");
        });
        test("at grand child", () => {
            const { fooGrandChild, foo } = schemas;
            expect(fooGrandChild.logicalPath).toEqual("foo/one/alpha");
            expect(fooGrandChild.domain.id).toEqual(foo.id);
        });
    });
});
//# sourceMappingURL=node.spec.js.map