"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaUtils = exports.NoteUtils = exports.NodeBuilder = exports.Schema = exports.Note = exports.DNode = exports.DNodeRaw = exports.DNodeUtils = exports.UNKNOWN_SCHEMA_ID = void 0;
/* eslint-disable no-loop-func */
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const moment_1 = __importDefault(require("moment"));
const vscode_uri_1 = require("vscode-uri");
const yamljs_1 = __importDefault(require("yamljs"));
const error_1 = require("./error");
const gray_matter_1 = __importDefault(require("gray-matter"));
const uuid_1 = require("./uuid");
const path_1 = __importDefault(require("path"));
exports.UNKNOWN_SCHEMA_ID = "_UNKNOWN_SCHEMA";
class DNodeUtils {
    /**
     * Last element of path
     *
     * // don't remove extension
     * basename(foo.bar.md) // foo.bar
     *
     * @param nodePath
     * @param rmExtension
     */
    static basename(nodePath, rmExtension) {
        if (rmExtension) {
            const idx = nodePath.lastIndexOf(".md");
            if (idx > 0) {
                nodePath = nodePath.slice(0, idx);
            }
        }
        const [first, ...rest] = nodePath.split(".");
        return lodash_1.default.isEmpty(rest) ? first : rest.slice(-1)[0];
    }
    /**
     * Second last element
     * @param nodePath
     */
    static dirName(nodePath) {
        return nodePath.split(".").slice(0, -1).join(".");
    }
    /**
     * First element
     * eg. domainName(foo.bar.baz) // foo
     * @param nodePath
     */
    static domainName(nodePath) {
        return nodePath.split(".")[0];
    }
    static findClosestParent(fpath, nodes, opts) {
        const cleanOpts = lodash_1.default.defaults(opts, { noStubs: false });
        const dirname = DNodeUtils.dirName(fpath);
        if (dirname === "") {
            return nodes["root"];
        }
        const maybeNode = lodash_1.default.find(nodes, { fname: dirname });
        if ((maybeNode && cleanOpts.noStubs && !(maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.stub)) ||
            (maybeNode && !cleanOpts.noStubs)) {
            return maybeNode;
        }
        return DNodeUtils.findClosestParent(dirname, nodes, cleanOpts);
    }
    /**
     *
     * @param note
     * - pullCustomUp: roll custom attributes to top level, default: false
     * @param opts
     */
    static getMeta(note, opts) {
        const { pullCustomUp, ignoreNullParent } = lodash_1.default.defaults(opts || {}, {
            pullCustomUp: false,
            ignoreNullParent: false,
        });
        let seed = {};
        let fields = [
            "id",
            "title",
            "desc",
            "updated",
            "created",
            "data",
            "fname",
            "stub",
        ];
        if (pullCustomUp) {
            seed = note.custom;
            fields = lodash_1.default.reject(fields, (ent) => ent === "custom");
        }
        const meta = { ...seed, ...lodash_1.default.pick(note, [...fields]) };
        const family = lodash_1.default.pick(note.toRawProps(true, { ignoreNullParent }), [
            "parent",
            "children",
        ]);
        return { ...meta, ...family };
    }
    static getNoteByFname(fname, engine, opts) {
        const out = lodash_1.default.find(lodash_1.default.values(engine.notes), { fname });
        if ((opts === null || opts === void 0 ? void 0 : opts.throwIfEmpty) && lodash_1.default.isUndefined(out)) {
            throw Error(`${fname} not found`);
        }
        return out;
    }
    static getPathUpTo(hpath, numCompoenents) {
        return hpath.split(".").slice(0, numCompoenents).join(".");
    }
    static isRoot(node) {
        return node.id === "root";
    }
    static uri2Fname(uri) {
        return path_1.default.basename(uri.fsPath, ".md");
    }
    static node2Uri(node, engine) {
        return vscode_uri_1.URI.file(path_1.default.join(engine.props.root, node.fname + ".md"));
    }
}
exports.DNodeUtils = DNodeUtils;
class DNodeRaw {
    /**
     *
     * @param nodeOpts
     * @param opts
     *   - returnExtra: if true, return extra properties, default: false
     */
    static createProps(nodeOpts) {
        const { id, desc, fname, updated, created, parent, stub, children, body, data, } = lodash_1.default.defaults(nodeOpts, {
            updated: moment_1.default.now(),
            created: moment_1.default.now(),
            id: uuid_1.genUUID(),
            desc: "",
            children: [],
            stub: false,
            parent: null,
            body: "",
            data: {},
            fname: null,
        });
        // eslint-disable-next-line no-use-before-define
        const title = nodeOpts.title || DNode.defaultTitle(fname);
        const nodePropsItems = {
            id,
            title,
            desc,
            fname,
            updated,
            created,
            parent,
            children,
            stub,
            body,
            data,
        };
        const denylist = ["schemaStub", "type"];
        const custom = lodash_1.default.omit(nodeOpts, lodash_1.default.keys(nodePropsItems).concat(denylist));
        const nodeProps = {
            ...nodePropsItems,
            custom,
        };
        return nodeProps;
    }
}
exports.DNodeRaw = DNodeRaw;
class DNode {
    constructor(opts) {
        const { id, title, desc, fname, type, updated, created, stub, body, data, children, custom, } = lodash_1.default.defaults(opts, DNodeRaw.createProps(lodash_1.default.defaults(opts, { parent: null, children: [] })));
        this.id = id;
        this.title = title;
        this.desc = desc;
        this.fname = fname;
        this.type = type;
        this.updated = updated;
        this.created = created;
        this.parent = opts.parent ? opts.parent : null;
        this.children = children;
        this.body = body;
        this.data = data;
        this.stub = stub;
        this.custom = custom;
        this.uri = vscode_uri_1.URI.parse(`dendron://${fname}.md`);
    }
    static defaultTitle(fname) {
        return lodash_1.default.capitalize(DNodeUtils.basename(fname, true));
    }
    get domain() {
        var _a;
        if (((_a = this.parent) === null || _a === void 0 ? void 0 : _a.id) === "root" || lodash_1.default.isNull(this.parent)) {
            return this;
        }
        return this.parent.domain;
    }
    get basename() {
        return DNodeUtils.basename(this.logicalPath);
    }
    get detail() {
        return "";
    }
    get label() {
        return DNodeUtils.isRoot(this) ? "root" : this.logicalPath;
    }
    /**
     * Self and all children
     */
    get nodes() {
        const out = [this].concat(this.children.map((c) => c.nodes).flat());
        return out;
    }
    /**
     * dot delimited path
     *  - for root node, its ""
     *  - for everything else, its the dot delimited name
     *  - used when showing query
     */
    get logicalPath() {
        if (this.fname === "root") {
            return "";
        }
        else {
            return this.fname;
        }
    }
    get path() {
        return this.fname;
    }
    addChild(node) {
        // only add if new
        if (!this.children.some((ent) => ent.id === node.id)) {
            this.children.push(node);
        }
        // during rename, id will stay the same but parent is set to `null`
        node.parent = this;
    }
    equal(node) {
        const props1 = this.toRawProps();
        const props2 = node.toRawProps();
        return lodash_1.default.every([
            lodash_1.default.isEqual(lodash_1.default.omit(props1, "body"), lodash_1.default.omit(props2, "body")),
            lodash_1.default.trim(props1.body) === lodash_1.default.trim(props2.body),
        ]);
    }
    render() {
        const { body, meta } = this.toNoteProps();
        return gray_matter_1.default.stringify(body || "", meta);
    }
    renderBody() {
        return this.body;
    }
    toDocument() {
        return {
            document: {
                nodes: [
                    {
                        object: "block",
                        type: "paragraph",
                        nodes: [
                            {
                                object: "text",
                                text: this.renderBody(),
                            },
                        ],
                    },
                ],
            },
        };
    }
    toNoteProps() {
        const node = this;
        const body = this.body;
        const props = lodash_1.default.pick(node, [
            "id",
            "title",
            "desc",
            "updated",
            "created",
            "stub",
        ]);
        const { custom } = node;
        const meta = { ...props, ...custom };
        return {
            meta,
            body,
        };
    }
    toRawProps(hideBody, opts) {
        var _a;
        const { ignoreNullParent } = lodash_1.default.defaults(opts, { ignoreNullParent: false });
        const props = lodash_1.default.pick(this, [
            "id",
            "title",
            "desc",
            "type",
            "updated",
            "created",
            "body",
            "fname",
            "data",
            "stub",
            "custom",
        ]);
        let parent;
        if (hideBody) {
            delete props.body;
        }
        if (((_a = this.parent) === null || _a === void 0 ? void 0 : _a.title) === "root") {
            parent = "root";
        }
        else if (this.id === "root") {
            parent = null;
        }
        else {
            // eslint-disable-next-line no-lonely-if
            if (lodash_1.default.isNull(this.parent)) {
                // parent deleted when publishing site
                if (ignoreNullParent || this.id === exports.UNKNOWN_SCHEMA_ID) {
                    parent = null;
                }
                else {
                    throw Error(`${props.fname} has no parent node`);
                }
            }
            else {
                parent = this.parent.id;
            }
        }
        const children = this.children.map((c) => c.id);
        return { ...props, parent, children };
    }
    toRawPropsRecursive(opts) {
        const parent = this.toRawProps(false, opts);
        const children = this.children
            .map((ch) => 
        // @ts-ignore
        ch.toRawPropsRecursive(opts)
        // eslint-disable-next-line function-paren-newline
        )
            .flat();
        // @ts-ignore
        const out = [parent].concat(children);
        return out.flat();
    }
    validate() {
        return true;
    }
}
exports.DNode = DNode;
class Note extends DNode {
    constructor(props) {
        var _a;
        const cleanProps = lodash_1.default.defaults(props, {
            parent: null,
            children: [],
            schemaStub: false,
        });
        super({
            type: "note",
            ...cleanProps,
        });
        this.schemaId = ((_a = props === null || props === void 0 ? void 0 : props.data) === null || _a === void 0 ? void 0 : _a.schemaId) || "-1";
        this.schemaStub = cleanProps.schemaStub;
    }
    static createStub(fname, opts) {
        return new Note({ stub: true, fname, ...opts });
    }
    static createRoot() {
        return new Note({ fname: "root", id: "root", title: "root" });
    }
    static fromSchema(dirpath, schema) {
        const fname = [dirpath, schema.pattern].join(".");
        const note = new Note({
            fname,
            desc: schema.desc,
            schemaStub: true,
            data: { schemaId: schema.id },
        });
        note.schema = schema;
        return note;
    }
    // vscode detail pane
    get detail() {
        if (this.schema && this.schemaStub) {
            return this.schema.desc;
        }
        return this.desc;
    }
    get description() {
        const prefixParts = [];
        if (this.title !== this.fname) {
            prefixParts.push(this.title);
        }
        if (this.stub || this.schemaStub) {
            prefixParts.push("$(gist-new)");
        }
        if (this.schema) {
            // case: unknown schema
            // eslint-disable-next-line no-use-before-define
            if (SchemaUtils.isUnkown(this.schema)) {
                prefixParts.push("$(question)");
                return prefixParts.join(" ");
            }
            // case: recognized schema
            prefixParts.push(`$(repo) ${this.schema.domain.title}`);
            // check if non-domain schema
            if (this.schema.domain.id !== this.schema.id) {
                prefixParts.push("$(breadcrumb-separator)");
                prefixParts.push(this.schema.title);
            }
        }
        return prefixParts.join(" ");
    }
    get domain() {
        return super.domain;
    }
    get url() {
        return `/doc/${this.id}`;
    }
}
exports.Note = Note;
class Schema extends DNode {
    constructor(props) {
        if (props.fname.indexOf(".schema") < 0) {
            props.fname += ".schema";
        }
        super({
            type: "schema",
            ...lodash_1.default.defaults(props, {
                id: Schema.defaultTitle(props.fname),
                title: Schema.defaultTitle(props.fname),
                parent: null,
                children: [],
                data: {},
            }),
        });
    }
    static createRawProps(opts) {
        if (opts.fname.indexOf(".schema") < 0) {
            opts.fname += ".schema";
        }
        const schemaDataOpts = [
            "namespace",
            "pattern",
            "template",
        ];
        const optsWithoutData = lodash_1.default.omit(opts, schemaDataOpts);
        const optsData = lodash_1.default.pick(opts, schemaDataOpts);
        return DNodeRaw.createProps({
            ...lodash_1.default.defaults(optsWithoutData, {
                title: optsWithoutData.id,
                parent: null,
                children: [],
                data: optsData,
            }),
        });
    }
    static createRoot() {
        return new Schema({
            id: "root",
            title: "root",
            fname: "root.schema",
            parent: null,
            children: [],
        });
    }
    /**
     * This is attached to notes that are part of a domain with schema but
     * don't match any schema in it
     */
    static createUnkownSchema() {
        if (lodash_1.default.isUndefined(Schema._UNKNOWN_SCHEMA)) {
            const props = Schema.createRawProps({
                id: exports.UNKNOWN_SCHEMA_ID,
                fname: exports.UNKNOWN_SCHEMA_ID,
                stub: true,
                created: "-1",
                updated: "-1",
            });
            Schema._UNKNOWN_SCHEMA = new Schema({
                ...props,
                parent: null,
                children: [],
            });
        }
        return Schema._UNKNOWN_SCHEMA;
    }
    static defaultTitle(fname) {
        return fname.replace(".schema", "");
    }
    get namespace() {
        var _a;
        return ((_a = this.data) === null || _a === void 0 ? void 0 : _a.namespace) || false;
    }
    get label() {
        return this.id;
    }
    get logicalPath() {
        const part = this.namespace ? `${this.id}/*` : this.id;
        if (this.parent && this.parent.id !== "root") {
            const prefix = this.parent.logicalPath;
            return [prefix, part].join("/");
        }
        else {
            return part;
        }
    }
    get patternMatch() {
        const part = this.namespace ? `${this.pattern}/*` : this.pattern;
        const parent = this.parent;
        if (parent && parent.pattern !== "root") {
            const prefix = parent.patternMatch;
            return [prefix, part].join("/");
        }
        else {
            return part;
        }
    }
    get pattern() {
        var _a;
        return ((_a = this.data.pattern) === null || _a === void 0 ? void 0 : _a.replace(".", "/")) || this.id;
    }
    get url() {
        return `/schema/${this.id}`;
    }
    match(note) {
        // TODO: simple version
        return this.title === note.basename;
    }
    renderBody() {
        const out = lodash_1.default.map(this.toRawPropsRecursive({ ignoreNullParent: true }), 
        // TODO: don't hardcode, this only applies to new schemas
        (props) => {
            return {
                ...lodash_1.default.pick(props, ["id", "title", "desc", "data"]),
                parent: "root",
            };
        });
        return yamljs_1.default.stringify(out, undefined, 4);
    }
    render() {
        const out = lodash_1.default.map(this.toRawPropsRecursive({ ignoreNullParent: true }), 
        // TODO: don't hardcode, this only applies to new schemas
        (props) => {
            const data = props.data;
            return {
                ...lodash_1.default.pick(props, ["id", "title", "desc"]),
                ...data,
                parent: "root",
            };
        });
        return yamljs_1.default.stringify(out, undefined, 4);
    }
}
exports.Schema = Schema;
Schema._UNKNOWN_SCHEMA = undefined;
const matchSchemaProps = (id, item, props) => {
    const out = lodash_1.default.find(props, (p) => lodash_1.default.every([p.id === id, item.fname === p.fname]));
    if (lodash_1.default.isUndefined(out)) {
        throw Error(`bad schema file. no match found for schema with id ${id}. schema file contents: ${JSON.stringify(props)}`);
    }
    return out;
};
// TODO:move to node
function getRoot(nodes) {
    // nodes: {nodes}
    const rootNode = lodash_1.default.find(nodes, (ent) => ent.title === "root" || lodash_1.default.isNull(ent.parent));
    if (!rootNode) {
        throw new error_1.DendronError("no root node found");
    }
    const node = new Note({ ...rootNode, parent: null, children: [] });
    return { node, childrenIds: rootNode.children };
}
/**
 * From nodes, return a connected note tree
 */
class NodeBuilder {
    getDomainsRoot(nodes) {
        return lodash_1.default.filter(nodes, (ent) => ent.parent === "root");
    }
    toNote(item, parents, opts) {
        // _.map(schemas, (v, k) => {
        // });
        const node = new Note({ ...item, parent: null, children: [] });
        // if (node.schemaId) {
        //   node.schema = opts.schemas[node.schemaId];
        // }
        const { parent: parentId, children } = item;
        const parent = lodash_1.default.find(parents, { id: parentId });
        // const parent = undefined;
        if (lodash_1.default.isUndefined(parent)) {
            const error = JSON.stringify({
                msg: "no parent found",
                parentId,
                parents: parents.map((p) => lodash_1.default.omit(p.toRawProps(), "body")),
                item: lodash_1.default.omit(item, "body"),
            });
            throw Error(error);
        }
        // NOTE: parents don't get resolved until this is called
        parent.addChild(node);
        let filteredSchemas = opts.schemas;
        const maybeSchema = SchemaUtils.matchNote(node, opts.schemas);
        if (maybeSchema) {
            node.schema = maybeSchema;
        }
        else {
            node.schema = Schema.createUnkownSchema();
            filteredSchemas = [];
        }
        return { node, parent, children, schemas: filteredSchemas };
    }
    toSchema(item, parent, props) {
        // DEBUG: item: {item}, parents: {parents}
        const node = new Schema({ ...item, parent, children: [] });
        item.children.forEach((chId) => {
            const match = matchSchemaProps(chId, item, props);
            return this.toSchema(match, node, props);
        });
        parent.addChild(node);
        return node;
    }
    buildNoteFromProps(props, opts) {
        const { node: rootNode, childrenIds } = getRoot(props);
        const out = [];
        out.push([rootNode]);
        const getNoteFromId = (id, props) => {
            const nodePropsList = props.filter((ent) => ent.id === id);
            if (nodePropsList.length > 1) {
                const fnames = nodePropsList.map((ent) => ent.fname).join(", ");
                throw Error(`found multiple notes with the same id. please check the following notes: ${fnames}`);
            }
            const nodeProps = nodePropsList[0];
            return nodeProps;
        };
        let parentNodes = [rootNode];
        let noteProps = childrenIds.map((id) => {
            return {
                nodeProps: getNoteFromId(id, props),
                schemas: opts.schemas,
            };
        });
        while (!lodash_1.default.isEmpty(noteProps)) {
            const currentNodes = [];
            noteProps = noteProps
                .map(({ nodeProps, schemas }) => {
                // convert note props to note
                const { node, children, schemas: filteredSchemas } = this.toNote(nodeProps, parentNodes, {
                    schemas,
                });
                currentNodes.push(node);
                return children.map((id) => {
                    return {
                        nodeProps: getNoteFromId(id, props),
                        schemas: filteredSchemas,
                    };
                });
            })
                .flat();
            out.push(currentNodes);
            parentNodes = currentNodes;
        }
        return out.flat();
    }
    buildSchemaFromProps(props) {
        const root = Schema.createRoot();
        const rootDomains = this.getDomainsRoot(props);
        const out = [root];
        rootDomains.forEach((rootRaw) => {
            const domain = this.toSchema(rootRaw, root, props);
            out.push(domain);
            //out = out.concat(domain.nodes as Schema[]);
        });
        // DEBUG ctx: "parseSchema", out:
        return out;
    }
}
exports.NodeBuilder = NodeBuilder;
function createBackLink(note) {
    return {
        type: "note",
        id: "[[" + note.fname + "]]",
    };
}
class NoteUtils {
    static addBackLink(from, to) {
        if (lodash_1.default.isUndefined(from.data.links)) {
            from.data.links = [];
        }
        from.data.links.push(createBackLink(to));
    }
    /**
     * @param from
     * @param to
     */
    static createStubNotes(from, to) {
        const stubNodes = [];
        const fromPath = from.logicalPath;
        const toPath = to.logicalPath;
        const index = toPath.indexOf(fromPath) + fromPath.length;
        const diffPath = lodash_1.default.trimStart(toPath.slice(index), ".").split(".");
        let stubPath = fromPath;
        let parent = from;
        // last element is node
        diffPath.slice(0, -1).forEach((part) => {
            // handle starting from root, path = ""
            if (lodash_1.default.isEmpty(stubPath)) {
                stubPath = part;
            }
            else {
                stubPath += `.${part}`;
            }
            const n = Note.createStub(stubPath);
            stubNodes.push(n);
            parent.addChild(n);
            parent = n;
        });
        parent.addChild(to);
        return stubNodes;
    }
    static protoGetLinks(note, opts) {
        const cleanOpts = lodash_1.default.defaults(opts, { filter: undefined });
        const props = note.custom.props;
        let links = props.links;
        if (cleanOpts.filter) {
            links = links.filter((l) => l.type === cleanOpts.filter);
        }
        return links;
    }
    static protoGetSource(note) {
        const props = note.custom.props;
        const source = props.source;
        return source;
    }
}
exports.NoteUtils = NoteUtils;
class SchemaUtils {
    static fname(nodePath, rmExtension) {
        if (rmExtension) {
            const idx = nodePath.lastIndexOf(".yml");
            if (idx > 0) {
                nodePath = nodePath.slice(0, idx);
            }
        }
        // remove trailing dot
        return nodePath.slice(0, nodePath.lastIndexOf("schema") - 1);
    }
    static isUnkown(schema) {
        return schema.id === exports.UNKNOWN_SCHEMA_ID;
    }
    static applyTemplate(opts) {
        const { template, note, engine } = opts;
        if (template.type === "note") {
            const tempNote = lodash_1.default.find(lodash_1.default.values(engine.notes), { fname: template.id });
            if (lodash_1.default.isUndefined(tempNote)) {
                throw Error(`no template found for ${template}`);
            }
            note.body = tempNote.body;
            return true;
        }
        return false;
    }
    /**
     * Return true if template was applied, false otherwise
     * @param opts
     */
    static matchAndApplyTemplate(opts) {
        const { note, engine } = opts;
        const schemas = SchemaUtils.matchNote(note, engine.schemas);
        if (schemas.data.template) {
            return SchemaUtils.applyTemplate({
                template: schemas.data.template,
                note,
                engine,
            });
        }
        else {
            return false;
        }
    }
    /**
     *
     * @param noteOrPath
     * @param schemas
     * @param opts
     *   - matchNamespace: should match exact namespace note (in addition to wildcard), default: false
     *   - matchPrefix: allow prefix match, default: false
     */
    static matchNote(noteOrPath, schemas, opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            matchNamespace: true,
            matchPrefix: false,
        });
        const schemaList = lodash_1.default.isArray(schemas) ? schemas : lodash_1.default.values(schemas);
        const notePath = lodash_1.default.isString(noteOrPath) ? noteOrPath : noteOrPath.path;
        const notePathClean = notePath.replace(/\./g, "/");
        let match;
        lodash_1.default.find(schemaList, (schemaDomain) => {
            return lodash_1.default.some(schemaDomain.nodes, (schema) => {
                const patternMatch = schema.patternMatch;
                if (schema.namespace && cleanOpts.matchNamespace) {
                    if (minimatch_1.default(notePathClean, lodash_1.default.trimEnd(patternMatch, "/*"))) {
                        match = schema;
                        return true;
                    }
                }
                if (minimatch_1.default(notePathClean, patternMatch)) {
                    match = schema;
                    return true;
                }
                else {
                    return false;
                }
            });
        });
        if (lodash_1.default.isUndefined(match)) {
            return Schema.createUnkownSchema();
        }
        return match;
    }
}
exports.SchemaUtils = SchemaUtils;
//# sourceMappingURL=node.js.map