"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMDExtension = exports.resolvePath = exports.resolveTilde = exports.schema2YMLFile = exports.node2MdFile = exports.node2PropsMdFile = exports.mdFile2NodeProps = exports.getAllFiles = exports.globMatch = exports.deleteFile = exports.fileMeta2Node = exports.writeYAML = exports.readYAML = exports.readMD = exports.cleanFileName = exports.cleanName = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_1 = __importDefault(require("fs"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
/**
 * Make name safe for dendron
 * @param name
 * @param opts
 */
function cleanName(name) {
    name = name.replace(/\//g, ".").toLocaleLowerCase();
    name = name.replace(/ /g, "-");
    return name;
}
exports.cleanName = cleanName;
/**
 *
 * Normalize file name
 * - strip off extension
 * - replace [.\s] with -
 * @param name
 * @param opts
 *   - isDir: dealing with directory
 */
function cleanFileName(name, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, { isDir: false });
    if (!cleanOpts.isDir) {
        const { name: fname, dir } = path_1.default.parse(name);
        // strip off extension
        name = path_1.default.join(dir, fname);
    }
    name = name.replace(/\./g, "-");
    // replace all names already in file name
    //name = name.replace(/\./g, "-");
    name = cleanName(name);
    // if file, only get name (no extension)
    return name;
}
exports.cleanFileName = cleanFileName;
function readMD(fpath) {
    return gray_matter_1.default.read(fpath, {});
}
exports.readMD = readMD;
function readYAML(fpath) {
    return js_yaml_1.default.safeLoad(fs_1.default.readFileSync(fpath, { encoding: "utf8" }), {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
}
exports.readYAML = readYAML;
function writeYAML(fpath, data) {
    const out = js_yaml_1.default.safeDump(data, { indent: 4, schema: js_yaml_1.default.JSON_SCHEMA });
    return fs_1.default.writeFileSync(fpath, out);
}
exports.writeYAML = writeYAML;
function fileMeta2Node(body, meta) {
    const title = meta.name;
    // read id from file or generate one based on thte tile
    const id = common_all_1.genUUID();
    const note = new common_all_1.Note({
        id,
        title,
        desc: "TODO",
        data: {
            schemaId: "-1",
        },
        body,
        fname: meta.name,
    });
    return note;
}
exports.fileMeta2Node = fileMeta2Node;
function deleteFile(fpath) {
    return fs_1.default.unlinkSync(fpath);
}
exports.deleteFile = deleteFile;
function globMatch(patterns, fname) {
    if (lodash_1.default.isString(patterns)) {
        return minimatch_1.default(fname, patterns);
    }
    return lodash_1.default.some(patterns, (pattern) => minimatch_1.default(fname, pattern));
}
exports.globMatch = globMatch;
function getAllFiles(opts) {
    const { root, withFileTypes } = lodash_1.default.defaults(opts, {
        exclude: [".git", "Icon\r", ".*"],
        withFileTypes: false,
    });
    const allFiles = fs_1.default.readdirSync(root, { withFileTypes: true });
    return lodash_1.default.reject(allFiles.map((dirent) => {
        const { name: fname } = dirent;
        // match exclusions
        if (lodash_1.default.some([dirent.isDirectory(), globMatch(opts.exclude || [], fname)])) {
            return null;
        }
        // match inclusion
        if (opts.include && !globMatch(opts.include, fname)) {
            return null;
        }
        if (withFileTypes) {
            return dirent;
        }
        else {
            return dirent.name;
        }
    }), lodash_1.default.isNull);
}
exports.getAllFiles = getAllFiles;
function mdFile2NodeProps(fpath) {
    const { data, content: body } = gray_matter_1.default(fs_1.default.readFileSync(fpath, { encoding: "utf8" }), {
        engines: {
            yaml: {
                // @ts-ignore
                parse: (s) => js_yaml_1.default.safeLoad(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
                stringify: (s) => js_yaml_1.default.safeDump(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
            },
        },
    });
    const { name: fname } = path_1.default.parse(fpath);
    const dataProps = common_all_1.DNodeRaw.createProps({ ...data, fname, body });
    return dataProps;
}
exports.mdFile2NodeProps = mdFile2NodeProps;
function node2PropsMdFile(props, opts) {
    const { root } = opts;
    const { body, fname, custom } = props;
    const filePath = path_1.default.join(root, `${fname}.md`);
    const blacklist = [
        "body",
        "stub",
        "data",
        "custom",
        "fname",
        "parent",
        "children",
    ];
    return fs_1.default.writeFileSync(filePath, gray_matter_1.default.stringify(body || "", { ...lodash_1.default.omit(props, blacklist), ...custom }));
}
exports.node2PropsMdFile = node2PropsMdFile;
/**
 * Convert a node to a MD File. Any custom attributes will be
 * added to the end
 *
 * @param node: node to convert
 * @param opts
 *   - root: root folder where files should be written to
 */
function node2MdFile(node, opts) {
    const { root } = opts;
    const { fname } = node;
    const filePath = path_1.default.join(root, `${fname}.md`);
    return fs_1.default.writeFileSync(filePath, node.render());
}
exports.node2MdFile = node2MdFile;
function schema2YMLFile(schema, opts) {
    const { root } = opts;
    const { fname } = schema;
    const filePath = path_1.default.join(root, `${fname}.yml`);
    const out = schema.render();
    return fs_1.default.writeFileSync(filePath, out);
}
exports.schema2YMLFile = schema2YMLFile;
function resolveTilde(filePath) {
    if (!filePath || typeof filePath !== "string") {
        return "";
    }
    // '~/folder/path' or '~'
    if (filePath[0] === "~" && (filePath[1] === "/" || filePath.length === 1)) {
        return filePath.replace("~", os_1.default.homedir());
    }
    return filePath;
}
exports.resolveTilde = resolveTilde;
/**
 * Resolve file path and resolve relative paths relative to `root`
 * @param filePath
 * @param root
 */
function resolvePath(filePath, root) {
    const platform = os_1.default.platform();
    const isWin = platform === "win32";
    if (filePath[0] === "~") {
        return resolveTilde(filePath);
    }
    else if (path_1.default.isAbsolute(filePath) ||
        (isWin && filePath.startsWith("\\"))) {
        return filePath;
    }
    else {
        if (!root) {
            throw Error("can't use rel path without a workspace root set");
        }
        return path_1.default.join(root, filePath);
    }
}
exports.resolvePath = resolvePath;
function removeMDExtension(nodePath) {
    const idx = nodePath.lastIndexOf(".md");
    if (idx > 0) {
        nodePath = nodePath.slice(0, idx);
    }
    return nodePath;
}
exports.removeMDExtension = removeMDExtension;
//# sourceMappingURL=files.js.map