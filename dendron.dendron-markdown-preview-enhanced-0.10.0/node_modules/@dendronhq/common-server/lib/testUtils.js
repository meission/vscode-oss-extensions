"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngineTestUtils = exports.LernaTestUtils = exports.NodeTestUtils = exports.FileTestUtils = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const tmp_1 = __importDefault(require("tmp"));
const files_1 = require("./files");
const common_all_1 = require("@dendronhq/common-all");
// eslint-disable-next-line no-undef
tmp_1.default.setGracefulCleanup();
class FileTestUtils {
    static async createFiles(root, files) {
        return Promise.all(lodash_1.default.map(files, async (ent) => {
            const fpath = path_1.default.join(root, ent.path);
            return await fs_extra_1.default.ensureFile(fpath);
        }));
    }
    static getFixturesRoot(base) {
        const pkgRoot = FileTestUtils.getPkgRoot(base);
        return path_1.default.join(pkgRoot, "fixtures");
    }
    static getPkgRoot(base, fname) {
        fname = fname || "package.json";
        let acc = 10;
        const lvls = [];
        while (acc > 0) {
            const tryPath = path_1.default.join(base, ...lvls, fname);
            if (fs_extra_1.default.existsSync(tryPath)) {
                return path_1.default.dirname(tryPath);
            }
            acc -= 1;
            lvls.push("..");
        }
        throw Error(`no root found from ${base}`);
    }
    static setupDir(from, to) {
        fs_extra_1.default.copySync(from, to);
    }
    static tmpDir() {
        const dirPath = tmp_1.default.dirSync();
        return dirPath;
    }
}
exports.FileTestUtils = FileTestUtils;
/**
 * Compare files in root with expected
 * @param root
 * @param expected
 * @param opts
 */
FileTestUtils.cmpFiles = (root, expected, opts) => {
    const cleanOpts = lodash_1.default.defaults(opts, { add: [], remove: [], ignore: [] });
    const dirEnts = fs_extra_1.default
        .readdirSync(root)
        .filter((ent) => !lodash_1.default.includes(cleanOpts.ignore, ent));
    return [
        dirEnts.sort(),
        expected
            .concat(cleanOpts.add)
            .filter((ent) => {
            return !lodash_1.default.includes(cleanOpts === null || cleanOpts === void 0 ? void 0 : cleanOpts.remove, ent);
        })
            .sort(),
    ];
};
FileTestUtils.readMDFile = (root, fname) => {
    return gray_matter_1.default.read(path_1.default.join(root, fname));
};
FileTestUtils.readYMLFile = (root, fname) => {
    return files_1.readYAML(path_1.default.join(root, fname));
};
FileTestUtils.writeMDFile = (root, fname, fm, body) => {
    const fmAndBody = gray_matter_1.default.stringify(body, fm);
    return fs_extra_1.default.writeFileSync(path_1.default.join(root, fname), fmAndBody);
};
class NodeTestUtils {
}
exports.NodeTestUtils = NodeTestUtils;
NodeTestUtils.createNotes = (vaultPath, notes, opts) => {
    const cleanOpts = lodash_1.default.defaults(opts, { withBody: true });
    files_1.node2MdFile(new common_all_1.Note({ fname: "root", id: "root", title: "root" }), {
        root: vaultPath,
    });
    notes.map((n) => {
        const body = cleanOpts.withBody ? n.fname + " body" : "";
        // @ts-ignore
        files_1.node2MdFile(new common_all_1.Note({ body, ...n }), {
            root: vaultPath,
        });
    });
};
NodeTestUtils.cleanNodeMeta = (opts) => {
    const { payload, fields } = opts;
    return lodash_1.default.sortBy(lodash_1.default.map(payload, (ent) => lodash_1.default.pick(ent, fields)));
};
NodeTestUtils.assertNodeBody = (opts) => {
    const { expect, payload, expected } = opts;
    expect(lodash_1.default.sortBy(lodash_1.default.map(payload, (ent) => {
        const { body, fname } = lodash_1.default.pick(ent, ["body", "fname"]);
        return {
            fname,
            body: lodash_1.default.trim(body),
        };
    }))).toEqual(expected);
};
class LernaTestUtils {
    static getRootDir() {
        return FileTestUtils.getPkgRoot(__dirname, "lerna.json");
    }
    static getFixturesDir(type) {
        const pathSoFar = path_1.default.join(this.getRootDir(), "fixtures");
        return type ? path_1.default.join(pathSoFar, type) : pathSoFar;
    }
    static fixtureFilesForStore() {
        return fs_extra_1.default.readdirSync(path_1.default.join(LernaTestUtils.getFixturesDir(), "store"));
    }
}
exports.LernaTestUtils = LernaTestUtils;
class EngineTestUtils {
    /**
     * setupStoreDir
     */
    static setupStoreDir(opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            storeDirSrc: "store",
            copyFixtures: true,
        });
        let { storeDirSrc, storeDstPath, copyFixtures } = cleanOpts;
        const fixturesSrcPath = LernaTestUtils.getFixturesDir(storeDirSrc);
        if (lodash_1.default.isUndefined(storeDstPath)) {
            storeDstPath = FileTestUtils.tmpDir().name;
        }
        if (copyFixtures) {
            fs_extra_1.default.copySync(fixturesSrcPath, storeDstPath);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.initDirCb) {
            opts.initDirCb(storeDstPath);
        }
        return storeDstPath;
    }
}
exports.EngineTestUtils = EngineTestUtils;
//# sourceMappingURL=testUtils.js.map